diff --git a/.gitignore b/.gitignore
index a9931bc..3a59d7b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -16,3 +16,9 @@
 *.cproject
 *.DS_Store
 /allPlots.pdf
+.lock-waf_linux2_build
+*.udb
+results/*
+tmp-*
+tmp
+*~
diff --git a/.pylintrc b/.pylintrc
new file mode 100644
index 0000000..9c9aaa1
--- /dev/null
+++ b/.pylintrc
@@ -0,0 +1 @@
+disable-print-statement-use
\ No newline at end of file
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..28193ca
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,4 @@
+{
+    "C_Cpp.errorSquiggles": "Disabled",
+    "python.pythonPath": "/usr/bin/python"
+}
\ No newline at end of file
diff --git a/dcmptcp-ns3.code-workspace b/dcmptcp-ns3.code-workspace
new file mode 100644
index 0000000..a921fa8
--- /dev/null
+++ b/dcmptcp-ns3.code-workspace
@@ -0,0 +1,12 @@
+{
+	"folders": [
+		{
+			"path": "."
+		}
+	],
+	"settings": {
+		"files.associations": {
+			"iostream": "cpp"
+		}
+	}
+}
\ No newline at end of file
diff --git a/scratch/FatTree.cc b/scratch/FatTree.cc
deleted file mode 100644
index 72c2562..0000000
--- a/scratch/FatTree.cc
+++ /dev/null
@@ -1,3787 +0,0 @@
-/*
- * Author: Morteza Kheirkhah <m.kheirkhah@ed.ac.uk>
- */
-
-#include <ctime>
-#include <ctype.h>
-#include <sys/time.h>
-#include <stdint.h>
-#include <fstream>
-#include <string>
-#include <cassert>
-#include <iostream>  // std::cout; std::fixed
-#include <iomanip>   // std::setprecision
-#include <algorithm> // std::min|max
-#include "ns3/log.h"
-#include "ns3/core-module.h"
-#include "ns3/network-module.h"
-#include "ns3/applications-module.h"
-#include "ns3/point-to-point-module.h"
-#include "ns3/internet-module.h"
-#include "ns3/netanim-module.h"
-#include "ns3/mobility-module.h"
-#include "ns3/callback.h"
-#include "ns3/string.h"
-
-#define MAXDATASIZE 1400
-#define MAXPACKETSIZE 1500
-
-using namespace ns3;
-
-NS_LOG_COMPONENT_DEFINE("FatTree");
-
-NodeContainer host[8][4];  // NodeContainer for hosts
-
-typedef enum
-{
-  Core, Aggr, Tor, Host, Core_Aggr, Core_Aggr_Tor, Core_Aggr_Tor_Host
-} Layers_t;
-
-typedef enum
-{
-  NONE, PERMUTATION, STRIDE, RANDOM, SHORT_FLOW, INCAST_STRIDE, INCAST_DIST, RANDOM_DIST, PERMUTATION_DIST, P_FABRIC, P_PERMUTATION
-} TrafficMatrix_t;
-
-typedef enum
-{
-  TCP, MPTCP
-} SocketType_t;
-
-typedef enum
-{
-  SF_NONE, SF_TCP, SF_MPTCP, SF_DCTCP, SF_ECN, SF_XMP
-} ShortFlowType_t;
-
-typedef enum
-{
-  SHORT, LARGE, BACKGROUND
-} FlowType_t;
-
-//-------------------------------- XMP --------------------------------//
-uint32_t g_XmpGamma = 1;
-uint32_t g_XmpBeta = 4;
-//---------------------------- INCAST_DIST ----------------------------//
-double   readArrivalInterval = 50.0;   // ms, doc: 10us ~ 1ms
-uint32_t maxTotalLargeFlows = 2000;
-uint32_t readRequestFlowSize = 2048;   // 2KB
-uint32_t readResponseFlowSize = 65536; // 64KB
-uint32_t jobId = 0;
-uint32_t readFlows = 8; // Number of parallel flows;
-uint32_t totalJobs = 0;
-uint32_t activeJobs = 0;
-uint32_t readJobs = 8;  // Number of parallel jobs;
-uint32_t activeLargeFlows = 0;
-uint32_t peakActiveLarges = 0;
-uint32_t peakActiveJobs = 0;
-uint64_t totalLargeFlows = 0;
-uint32_t largeFlowCap = 4; // each node receives no more than 4 of long flows
-std::vector<Ptr<Node> > hostArray;
-//---------------------------- INCAST_DIST ----------------------------//
-std::map<string, TrafficMatrix_t> stringToTrafficMatrix;
-std::map<string, ShortFlowType_t> stringToShortFlowType;
-std::map<string, SocketType_t> stringToSocketType;
-std::map<string, Layers_t> stringToHotSpotLayers;
-vector<ApplicationContainer> sourceShortFlowApps;
-vector<ApplicationContainer> sourceLargeFlowApps;
-vector<ApplicationContainer> sinkApps;
-vector<uint32_t> dstList;
-vector<pair<double, double> > totalArrival;
-vector<double> poissonArrival;
-uint32_t g_totalArrivals = 0;
-
-// Setup general parameters
-string   g_topology = "FT";
-string   g_simName  = "S0";
-string   g_linkCapacity = "1000Mbps"; // 100Mbps
-string   g_linkDelay = "20us";        // link delay of 20us; Max RTT: 20 * 12 = 240us
-uint32_t g_flowSize = 0;              // 0 i.e., Unlimited used for large flows
-uint32_t g_shortFlowSize = 70000;     // 70Kb
-uint32_t g_simTime = 1;               // default is 20 Seconds
-uint32_t g_seed = 0;                  // RNG seed
-double   g_lamda = 256;               // 256 flows/sec
-uint32_t g_FlowSizeThresh = 1 * 1024 * 1024; // 1MB;
-SocketType_t g_socketType = MPTCP;
-TrafficMatrix_t g_trafficMatrix = SHORT_FLOW;
-TrafficMatrix_t g_shortFlowTM = PERMUTATION;
-TrafficMatrix_t g_backgroundFlowTM = NONE;
-
-uint32_t g_connxLimit = 33; // 33% large flows if it being used
-string g_simInstance = "0"; // Dynamically adjust at cmd
-string g_simStartTime = "NULL";
-bool g_enableLfPlotting = false;
-bool g_enableSfPlotting = false;
-bool g_largeFlowDCTCP = false;
-double g_arrivalUpperBound = 0.2;
-double g_shortFlowStartTime = 0.0;
-ShortFlowType_t g_shortFlowType = SF_NONE;
-bool g_enableRED = false;
-bool g_enableDCTCP= false;
-bool g_enableDTQmark= false;
-double g_REDmaxTh = 10;
-double g_REDminTh = 10;
-double g_REDWeight = 1.0;
-uint32_t g_queueLimit = 100;
-uint32_t g_queueCounter = 0;
-double   g_DCTCPWeight = 1.0 / 16.0;
-double   g_queueSampInterval = 0.001; // 1ms is default
-uint32_t g_queueMaxCounter = static_cast<uint32_t>(round(g_simTime/g_queueSampInterval));
-bool g_dctcpFastReTxRecord = false;
-bool g_hasHostQueueSetup = false;
-bool g_simpleQueueTrace = false;
-uint32_t g_DTQmarkTh = 10;        // Marking threshold with a droptail queue
-bool g_enabledHostMarking = true; // If true, the queues in the host layer would also mark packets.
-bool g_queueModeBytes = false;    // If true, the queues perform per bytes rather than packets.
-bool g_shortFlowSizeUniRandom = true;
-bool g_shortFlowSizeDist = false;
-bool g_enableRatePlotting = false;
-bool g_isSimActive = true;
-bool g_slowDownXmpLike = false;
-bool g_slowDownEcnLike = false;
-bool g_dynamicSubflow = false;
-double   g_rateBeat = 0.1;
-uint32_t g_incastThreshold = 3;
-uint32_t g_incastExitThreshold = 8;
-
-// Cwnd/Rwnd
-uint32_t g_cwndMin = 1;
-uint32_t g_rwndScale = 1;
-
-uint32_t g_rGap = 50;
-
-uint16_t g_torLayerConnx = 0;
-uint16_t g_aggrLayerConnx = 0;
-uint16_t g_coreLayerConnx = 0;
-
-uint32_t AllFlow[3];
-uint32_t LargeFlow[3];
-uint32_t ShortFlow[3];
-
-// Setup MPTCP parameters
-string   g_cc = "RTT_Compensator"; // Uncoupled_TCPs, Linked_Increases, Fully_Coupled
-uint32_t g_subflows = 8;
-uint32_t g_shortFlowSubflows = 1;
-
-// Setup topology parameters
-uint32_t g_ratio = 1;
-uint32_t g_K = 8;                         // No. of switch's ports : 8
-uint32_t g_numPod = g_K;                  // No. of pods           : 8
-uint32_t g_numHost = (g_K / 2) * g_ratio; // Hosts per ToR switch  : 4
-uint32_t g_numToR = g_K / 2;              // ToR switches per pod  : 4
-uint32_t g_numAggr = g_K / 2;             // Aggr switches per pod : 4
-uint32_t g_numCore = g_K / 2;             // Core switches in group: 2
-uint32_t g_numGroup = g_K / 2;            // Core switches in group: 2
-uint32_t g_totalHost = ((g_K * g_K * g_K) / 4) * g_ratio;
-uint32_t g_totalToR = g_numToR * g_numPod;
-uint32_t g_totalAggr = g_numAggr * g_numPod;
-uint32_t g_totalCore = g_numCore * g_numGroup;
-
-// [Second][Metrics][Node][Dev]
-double core_data[25][2][1024][64];
-double aggr_data[25][2][1024][64];
-double tor_data [25][2][1024][64];
-double host_data[25][2][1024][2];
-
-double totalCoreUtil, totalCoreLoss, totalAggrUtil, totalAggrLoss, totalTorUtil, totalTorLoss, totalHostUtil, totalHostLoss = 0.0;
-double meanCoreUtil,  meanCoreLoss,  meanAggrUtil,  meanAggrLoss,  meanTorUtil,  meanTorLoss,  meanHostUtil,  meanHostLoss  = 0.0;
-
-double sumCoreUtil, sumAggrUtil, sumTorUtil, sumHostUtil = 0.0;
-double sumCoreLoss, sumAggrLoss, sumTorLoss, sumHostLoss = 0.0;
-uint32_t countCore, countAggr,   countTor,   countHost   = 0.0;
-
-// NodeContainer to use for link utilisation and loss rate
-NodeContainer core_c;
-NodeContainer Aggr_c;
-NodeContainer Tor_c;
-NodeContainer Host_c;
-
-void FlowExit(Ptr<Node> node, uint32_t index, uint32_t size, double elapse, double rate);
-void SetupShortFlow(MpTcpBulkSendHelper &source, string &socketModelTmp);
-uint32_t TransferData(Ptr<Node> src, Ptr<Node> des, uint32_t size);
-string SetupSimFileName(string input);
-string GetFlowLayer(Ipv4Address ipv4Src, Ipv4Address ipv4Dst);
-string GetSocketModel();
-void cmAnalisys(FlowType_t ft, Ipv4Address ipv4Src, Ipv4Address ipv4Dst);
-uint32_t GetReTxThresh(Ipv4Address ipv4Src, Ipv4Address ipv4Dst);
-uint64_t GetLinkRate(string linkRate);
-string GetKeyFromValueTM(TrafficMatrix_t tm);
-string GetIpv4AddressFromNodeInStr(Ptr<Node> node);
-Ipv4Address GetIpv4AddressFromNode(Ptr<Node> node);
-void SimHeaderWritter(Ptr<OutputStreamWrapper> stream);
-void SimFooterWritter(Ptr<OutputStreamWrapper> stream);
-//---------------------------- pFabric  ----------------------------//
-// variables for pFabric traffic generation
-string   pTraffic = "WEB";  // DM: data mining; WEB: web services
-double   pload = 0.0;       // load to apply to the network, from 0.0 to 1.0 (0%, 100%)
-double   linkSpeed;         // link speed (Mbps), used for pFabric traffic, g_linkCapacity
-int      pFabSeed;          // seed to use for pFabric flow generation
-uint16_t startPort = 50000; // assign increasing port values to flows
-uint64_t g_totalShortFlows = 0;
-uint64_t g_totalLargeFlows = 0;
-
-struct cdfStruct
-{ // contains points of the CDF
-  double yCDF; // value corresponding to the CDF, e.g. flow size (packets)
-  int xFlowSize;
-};
-
-vector<cdfStruct> cdfData; // flow size CDF
-const int meanFlowSize[] = { 5117 * MAXDATASIZE, 1138 * MAXDATASIZE, 134 * MAXDATASIZE };  // data mining, web services, imc
-
-struct pFlow
-{
-  uint32_t iSrc, iDst;  // source and destination IP
-  uint64_t time;        // time at which the flow should start (ms)
-  int size;             // size of the flow (packets)
-  string srcIP, dstIP;  // source and destination IP for the flow
-  int srcPort, dstPort; // source and destination TCP port (from the sender's perspective)
-};
-
-vector<pFlow> flowList; // flows to generate
-int flowNum = 16256;    // number of flows to generate in the simulation, set it from cli
-
-// Functions for pFabric traffic generation
-bool
-GetCDFData (string traf)
-{
-    // populate the traffic array with CDF of flow sizes
-    // perhaps have these read from a file in the future
-    // traf == "DM" or "WEB"
-    cdfStruct temp = {0.0, 0};
-
-    if (traf == "DM") {
-        // use Data Mining traffic, there are 9 elements
-        cdfData.assign(9, temp);   // initialise the list
-        cdfData.at(0).xFlowSize = 1; cdfData.at(0).yCDF = 0.0;
-        cdfData.at(1).xFlowSize = 1; cdfData.at(1).yCDF = 0.5;
-        cdfData.at(2).xFlowSize = 2; cdfData.at(2).yCDF = 0.6;
-        cdfData.at(3).xFlowSize = 3; cdfData.at(3).yCDF = 0.7;
-        cdfData.at(4).xFlowSize = 7; cdfData.at(4).yCDF = 0.8;
-        cdfData.at(5).xFlowSize = 267; cdfData.at(5).yCDF = 0.9;
-        cdfData.at(6).xFlowSize = 2107; cdfData.at(6).yCDF = 0.95;
-        cdfData.at(7).xFlowSize = 66667; cdfData.at(7).yCDF = 0.99;
-        cdfData.at(8).xFlowSize = 666667; cdfData.at(8).yCDF = 1.0;
-    } else if (traf == "WEB") {
-        // use WEB traffic, there are 12 elements
-        cdfData.assign(12, temp);   // initialise the list
-        cdfData.at(0).xFlowSize = 6; cdfData.at(0).yCDF = 0.0;
-        cdfData.at(1).xFlowSize = 6; cdfData.at(1).yCDF = 0.15;
-        cdfData.at(2).xFlowSize = 13; cdfData.at(2).yCDF = 0.2;
-        cdfData.at(3).xFlowSize = 19; cdfData.at(3).yCDF = 0.3;
-        cdfData.at(4).xFlowSize = 33; cdfData.at(4).yCDF = 0.4;
-        cdfData.at(5).xFlowSize = 53; cdfData.at(5).yCDF = 0.53;
-        cdfData.at(6).xFlowSize = 133; cdfData.at(6).yCDF = 0.6;
-        cdfData.at(7).xFlowSize = 667; cdfData.at(7).yCDF = 0.7;
-        cdfData.at(8).xFlowSize = 1333; cdfData.at(8).yCDF = 0.8;
-        cdfData.at(9).xFlowSize = 3333; cdfData.at(9).yCDF = 0.9;
-        cdfData.at(10).xFlowSize = 6667; cdfData.at(10).yCDF = 0.97;
-        cdfData.at(11).xFlowSize = 20000; cdfData.at(11).yCDF = 1.0;
-    } else if (traf == "IMC") {
-    // use IMC traffic, there are 12 elements
-        cdfData.assign(12, temp);   // initialise the list
-        cdfData.at(0).xFlowSize  = 1; cdfData.at(0).yCDF  = 0.0;
-        cdfData.at(1).xFlowSize  = 1; cdfData.at(1).yCDF  = 0.5;
-        cdfData.at(2).xFlowSize  = 2; cdfData.at(2).yCDF  = 0.6;
-        cdfData.at(3).xFlowSize  = 3; cdfData.at(3).yCDF  = 0.7;
-        cdfData.at(4).xFlowSize  = 5; cdfData.at(4).yCDF  = 0.75;
-        cdfData.at(5).xFlowSize  = 7; cdfData.at(5).yCDF  = 0.8;
-        cdfData.at(6).xFlowSize  = 40;  cdfData.at(6).yCDF  = 0.8125;
-        cdfData.at(7).xFlowSize  = 72;  cdfData.at(7).yCDF  = 0.8250;
-        cdfData.at(8).xFlowSize  = 137; cdfData.at(8).yCDF  = 0.85;
-        cdfData.at(9).xFlowSize  = 267; cdfData.at(9).yCDF  = 0.9;
-        cdfData.at(10).xFlowSize = 1187;  cdfData.at(10).yCDF = 0.95;
-        cdfData.at(11).xFlowSize = 2107;  cdfData.at(11).yCDF = 1.0;
-    } else {
-        // bad option
-        cout << "Bad option in GetCDFData(...)" << endl;
-        exit(EXIT_FAILURE);
-    }
-    cout << "Got " << traf << " flow size CDF data" << endl;
-    return true;
-}
-
-bool
-PrintPFlowsToFile(string file)
-{ // print flows generated with the pFabric model to file
-  ofstream write(file.c_str());
-  if (write.is_open())
-    { // put a header in the file
-      write << "#time\tsrcNode\tdstNode\tsize\tsrcIP\t\tdstIP\t\tsrcPort\tdstPort";
-      write << "\n";
-      for (int i = 0; i < flowNum; i++)
-        {
-          write << flowList.at(i).time;
-          write << "\t" << flowList.at(i).iSrc;
-          write << "\t" << flowList.at(i).iDst;
-          write << "\t" << flowList.at(i).size;
-          write << "\t" << flowList.at(i).srcIP;
-          write << "\t" << flowList.at(i).dstIP;
-          write << "\t" << flowList.at(i).srcPort;
-          write << "\t" << flowList.at(i).dstPort;
-          write << "\n";
-        }
-      write.close();
-    }
-  else
-    {
-      cout << "Could not open file to save pFlows" << endl;
-      return false;
-    }
-  return true;
-}
-
-double
-GetITTime (double r, double l, int mFS, double load = 1.0)
-{ // get the inter-arrival time between every flow (time to start each flow)
-  // uses mean flow size to figure out parameters for poisson distribution
-  // also take into account a load value representing how much bandwidth of the channel is to be used in average
-  // if load is not specified uses 1.0
-  // use exponential distribution function to figure out flow inter-arrival time
-  // flows are in order of generation, inter-arrival time dictates the arrival time between flows
-  // x = log(1-u)/(-lambda)
-  double temp;  // milliseconds of inter-flow arrival
-  temp = log (1 - r) / (-l);
-  return temp;
-}
-
-uint64_t
-ExtrapolateFlowSize (double c)
-{ // finds the correct flow size to attribute to a particular value of CDF
-  // returns the size of the flow to be generated, in packets
-  double diff = 1.0;  // maximum difference for any two CDF value is 1
-  int index = 0;
-  int size = 0;       // size of the CDF array
-  if (pTraffic == "DM")
-    {
-      size = 9;
-    }
-  else if (pTraffic == "WEB")
-    {
-      size = 12;
-    }
-  else if (pTraffic == "IMC")
-    {
-      size = 12;
-    }
-  // find the closest value of CDF to c
-  for (int i = 0; i < size; i++)
-    {
-      if (abs (cdfData.at (i).yCDF - c) < diff)
-        {
-          // new smallest found
-          diff = abs (cdfData.at (i).yCDF - c);
-          index = i;
-        }
-      else
-        {
-          break;
-        }
-    }
-  // use linear extrapolation to find a value between the points
-  // use this equation X = (Y - Yk-1)/(Yk - Yk-1) * (Xk - Xk-1) + Xk-1
-  // X is the desired flow size and Y is the actual CDF from random number
-  // need to assign only correct values for X, Y, Xk, Yk, Xk-1, Yk-1
-  double x = 0, y = 0, xk = 0, yk = 0, xk1 = 0, yk1 = 0;
-  y = c;
-  diff = -(cdfData.at (index).yCDF - y);
-  if (diff == 0.0)
-    { // rare, but can happen, give the exact flow size from CDF
-      xk = cdfData.at (index).xFlowSize;
-      yk = cdfData.at (index).yCDF;
-      xk1 = 0.0;
-      yk1 = 0.0;
-    }
-  else if (diff < 0.0)
-    { // between index and previous sample
-      xk = cdfData.at (index).xFlowSize;
-      yk = cdfData.at (index).yCDF;
-      xk1 = cdfData.at (index - 1).xFlowSize;
-      yk1 = cdfData.at (index - 1).yCDF;
-    }
-  else if (diff > 0.0)
-    { // between index and next sample
-      xk = cdfData.at (index + 1).xFlowSize;
-      yk = cdfData.at (index + 1).yCDF;
-      xk1 = cdfData.at (index).xFlowSize;
-      yk1 = cdfData.at (index).yCDF;
-    }
-  // calculate flow size
-  if (y == 0)
-    {
-      x = 1;    // unlikely but can cause problem if not accounted for
-    }
-  else
-    {
-      x = ((y - yk1) / (yk - yk1)) * (xk - xk1) + xk1;  // see above for comment pls
-    }
-  // return flow size in packets
-  return (uint64_t) round (x);
-}
-
-string
-Ipv4ToString (int add)
-{ // from an ipv4 address in integer form, return IP address xxx.xxx.xxx.xxx
-  // cannot find it in the ns3 libraries
-  // cout << "Ipv4ToString(...) " << add << endl;
-  ostringstream ostr;
-  ostr << ((add & 0xFF000000) >> 24) << ".";
-  ostr << ((add & 0xFF0000) >> 16) << ".";
-  ostr << ((add & 0xFF00) >> 8) << ".";
-  ostr << (add & 0xFF);
-  return ostr.str ();
-}
-
-void
-PreComputePFlows(string type, const NodeContainer &allHosts)
-{
-  // compute pFabric flows using the traffic type specified
-  // type="WEB" for web services, type="DM" for data mining
-  // num is number of flows to generate
-  cout << "PreComputePFlows(...) " << flowNum << endl;
-  if (type == "WEB" || type == "DM" || type == "IMC")
-    {
-      int meanFS = 0;
-      if (pTraffic == "DM")
-        {
-          meanFS = 0;
-        }
-      else if (pTraffic == "WEB")
-        {
-          meanFS = 1;
-        }
-      else if (pTraffic == "IMC")
-        {
-          meanFS = 2;
-        }
-      // get lambda and mean inter-arrival time. Lambda is per host, not universal
-      double lambda = ((linkSpeed * pload)
-          / (meanFlowSize[meanFS] * 8.0 / MAXDATASIZE * MAXPACKETSIZE))
-          / (g_totalHost - 1);
-      double intArr = 1 / lambda * 1000;
-      cout << "lambda (per server): " << lambda << endl;
-      cout << "Average intArr (per server): " << intArr << " ms" << endl;
-
-      int tmp = (int) ((g_totalHost) * (g_totalHost - 1));
-      cout << "flowNum: " << flowNum << "\ttmp: " << tmp << endl;
-      // check if the number of flows entered is too small
-      if (flowNum < tmp)
-        {
-          flowNum = (int) (tmp);
-          cout << "flowNum is changed to " << flowNum << endl;
-        }
-      // a flow is valid if time != -1.0 or size != -1, for error checking
-      pFlow temp =
-        { 0, 0, 0, -1, "0.0.0.0", "0.0.0.0", 0, 0 };
-      flowList.assign (flowNum, temp);   // initialise the list
-
-      uint64_t total[g_totalHost];  // starting time of the last flow gemerated, for every source
-      uint16_t p = startPort;     // port number to assign to a flow
-      int totalFlows = 0;   // just to count
-
-      // initialise total[]
-      for (int i = 0; i < (int) g_totalHost; i++)
-        {
-          total[i] = 0;
-        }
-      // generate flow specs
-      for (int i = 0; i < (int) (flowNum / ((g_totalHost) * (g_totalHost - 1))); i++)
-        { // this makes sure that flow generation is uniform
-          for (int iS = 0; iS < (int) g_totalHost; iS++)
-            {    // iS defines which node will be source
-              for (int iD = 0; iD < (int) g_totalHost; iD++)
-                {  // iD defines which node will be destination
-                  if (iS != iD)
-                    { // do not allow a flow to have same source and destination
-                      double r1 = drand48 ();
-                      uint64_t delay = (uint64_t) (GetITTime (r1, lambda, meanFlowSize[meanFS], pload) * 1000); // flow inter-arrival time
-                      total[iS] += delay;        // flow time
-                      double r2 = drand48 ();    // could use r1 too
-                      uint64_t size = ExtrapolateFlowSize (r2);  // get random flow size from CDF
-
-                      // record the flow time and size
-                      pFlow temp;
-                      temp.time = total[iS];
-                      //temp.delay = delay;
-                      temp.size = size;
-                      temp.srcPort = 0;       // I do not know the source port number ahead of time
-                      temp.dstPort = iD + 1;       // I do not know the source port number ahead of time
-                      temp.iSrc = iS;
-                      temp.iDst = iD;
-                      // get src and dst IP
-                      Ptr<Node> srcNode = allHosts.Get (iS);  // get src IP, it complains if called "srcNode"
-                      Ptr<Ipv4> ipv4Client = srcNode->GetObject<Ipv4> ();
-                      Ipv4InterfaceAddress iaddrClient = ipv4Client->GetAddress (1, 0); // (0, 0) is loopback
-                      Ipv4Address ipv4AddrClient = iaddrClient.GetLocal ();
-                      temp.srcIP = Ipv4ToString (ipv4AddrClient.Get ());
-
-                      Ptr<Node> dstNode = allHosts.Get (iD);
-                      Ptr<Ipv4> ipv4Server = dstNode->GetObject<Ipv4> ();
-                      Ipv4InterfaceAddress iaddrServer = ipv4Server->GetAddress (1, 0);
-                      Ipv4Address ipv4AddrServer = iaddrServer.GetLocal ();
-                      temp.dstIP = Ipv4ToString (ipv4AddrServer.Get ());
-                      flowList.at (totalFlows) = temp;
-                      p++;
-                      totalFlows++;
-                    }
-                }
-            }
-        }
-    }
-  else
-    {
-      cout << "Bad traffic selection at PreComputePFlows(...)" << cout;
-      exit (EXIT_FAILURE);
-    }
-}
-
-//-------------------------   P_PERMUTATION  -------------------------//
-double
-CalculateLambda()
-{
-  return g_lamda;
-}
-
-void
-ComputePermutationFlows ()
-{
-  flowNum = g_totalHost * (g_totalHost-1); // total flows = each host * host's flows
-  pFlow temp = { 0, 0, 0, -1, "0.0.0.0", "0.0.0.0", 0, 0 };
-  flowList.assign (flowNum, temp);   // initialise the list
-
-  int totalFlows = 0; // just to count the scheduled flows
-
-  uint64_t totalDelay[g_totalHost]; // starting time of the last flow generated, for every source
-  for (int i = 0; i < (int) g_totalHost; i++)
-    { // initialise totalDelay[]
-      totalDelay[i] = 0;
-    }
-
-  static UniformVariable uniformPermutation;
-  std::vector<Ptr<Node> > des = hostArray;
-  uint32_t totalHost = des.size ();
-  assert(totalHost == g_totalHost);
-  uint32_t s = 0, d = 0;
-  uint32_t hostFlows = 0; // flows per host
-  uint32_t connFailed = 0;
-  while (totalHost)
-    {
-      d = uniformPermutation.GetInteger (0, totalHost - 1);
-      cout << "Src -> Dst (" << hostArray[s]->GetId() << " -> " << des[d]->GetId() << ")" << endl;
-
-      // try to prevent a source connecting to itself (as needed in Permutation)
-      if (s == d)
-        {
-          if (connFailed > 10000) exit(1); // better to exit in such cases
-          connFailed++;
-          cout << "src == dst (" << connFailed << ")" << endl;
-          continue;
-        }
-      assert (s != d);
-
-      // computes for a fixed number of flows per host (== g_totalHost-1)
-      while (hostFlows < g_totalHost-1)
-        {
-          uint64_t delay = (uint64_t) (exponential(CalculateLambda()) * 1000); // next arrival (ms)
-          totalDelay[s] += delay;  // flow scheduling time
-          uint64_t eFlowSize = ExtrapolateFlowSize (drand48 ()); // get random flow size from CDF
-
-          pFlow temp;
-          temp.time = totalDelay[s]; // (ms)
-          temp.size = eFlowSize;
-          temp.srcPort = 0; // set at run time
-          temp.dstPort = 0; // set at run time
-          temp.iSrc = s;
-          temp.iDst = d;
-          temp.srcIP = GetIpv4AddressFromNodeInStr (hostArray[s]);
-          temp.dstIP = GetIpv4AddressFromNodeInStr (des[d]);
-          flowList.at (totalFlows) = temp;
-          totalFlows++;
-          hostFlows++;
-        }
-      s++;                         // move on to the next source
-      Ptr<Node> tmp = des[d];      // save current des node
-      des[d] = des[totalHost - 1]; // move the last des node to the current des node
-      des[totalHost - 1] = tmp;    // move saved des to the last des node
-      totalHost--;                 // never use the last des node again
-      hostFlows = 0;               // reset hostFlows for the next source
-      connFailed = 0;              // reset connection failure for the next source
-    }
-}
-
-void
-ExecutePermutationFlows (const NodeContainer &allHosts)
-{
-  cout << "ExecutePermutationFlows(...)" << endl;
-  for (int i = 0; i < flowNum; i++)
-    { // get source and destination of each computed flow
-      int src = flowList.at (i).iSrc;
-      int dst = flowList.at (i).iDst;
-      double sendTime = flowList.at (i).time;  // this is in ms
-      uint64_t fSize = flowList.at (i).size;
-      uint64_t flowSizeBytes = fSize * MAXDATASIZE;
-      uint32_t flowId = i;
-      uint16_t port = dst + 1;
-
-      Ipv4Address ipv4AddrClient = GetIpv4AddressFromNode (allHosts.Get (src));
-      Ipv4Address ipv4AddrServer = GetIpv4AddressFromNode (allHosts.Get (dst));
-
-      MpTcpBulkSendHelper source ("ns3::TcpSocketFactory", InetSocketAddress (Ipv4Address (ipv4AddrServer), port));
-      source.SetAttribute ("MaxBytes", UintegerValue (flowSizeBytes)); // use computed flow size
-      string socketModelTmp = GetSocketModel ();
-      source.SetAttribute ("SocketModel", StringValue (socketModelTmp));
-
-      if (flowSizeBytes < g_FlowSizeThresh)
-        { // Short flow group
-          ++g_totalShortFlows;
-          source.SetAttribute ("FlowType", StringValue ("Short"));
-          cmAnalisys (SHORT, ipv4AddrClient, ipv4AddrServer);
-
-          if (g_shortFlowType != SF_NONE)
-            { // IssuePermutation()
-              SetupShortFlow(source, socketModelTmp);
-            }
-        }
-      else
-        { // Large flows group
-          ++g_totalLargeFlows;
-          source.SetAttribute ("FlowType", StringValue ("Large")); // do I keep this with pFabric? YES
-          cmAnalisys (LARGE, ipv4AddrClient, ipv4AddrServer);
-          // IssuePermutation()
-          if (g_slowDownEcnLike)
-            source.SetAttribute ("SlowDownEcnLike", BooleanValue (g_slowDownEcnLike));
-        }
-      source.SetAttribute ("FlowId", UintegerValue (flowId));
-      string flowLayer = GetFlowLayer (ipv4AddrClient, ipv4AddrServer);
-      source.SetAttribute ("FlowLayer", StringValue (flowLayer));
-      source.SetAttribute ("OutputFileName", StringValue (SetupSimFileName ("RESULT"))); // change this?
-      source.SetAttribute ("OutputFileNameDctcp", StringValue (SetupSimFileName ("DCTCP")));
-
-      // Schedule application start
-      ApplicationContainer tmp = source.Install (allHosts.Get (src)); // install application on src node
-      tmp.Start (Seconds (sendTime / 1000.0));
-      Ptr<MpTcpBulkSendApplication> app = DynamicCast<MpTcpBulkSendApplication>(tmp.Get(0));
-      app->m_Notify = MakeCallback (FlowExit); // Keep track of completed flows
-      sourceLargeFlowApps.push_back (tmp);
-    }
-  cout << "\nSimulation is performing with [" << pTraffic << "] workload over a Permutation matrix...\n" << endl;
-}
-
-void
-SetupRightSubflows(uint32_t &sfsf, uint32_t &lfsf)
-{
-  switch (g_socketType)
-    {
-  case MPTCP:
-    sfsf = g_shortFlowSubflows;
-    lfsf = g_subflows;
-    break;
-  case TCP:
-    sfsf = 1;
-    lfsf = 1;
-    break;
-  default:
-    break;
-    }
-}
-
-void
-AddNameToHosts()
-{
-  int host = 0;
-  int tor = 0;
-  stringstream name;
-  for (uint32_t p = 0; p < g_numPod; p++)
-    {
-      for (uint32_t t = 0; t < g_numToR; t++)
-        {
-          name << "tor-" << p << "-" << t;
-          Names::Add (name.str (), Tor_c.Get (tor));
-          name.str ("");
-          name << "aggre-" << p << "-" << t;
-          Names::Add (name.str (), Aggr_c.Get (tor));
-          tor++;
-          name.str ("");
-          for (uint32_t h = 0; h < g_numHost; h++)
-            { // Hosts
-              name << "host-" << p << "-" << t << "-" << h;
-              Names::Add (name.str (), Host_c.Get (host));
-              host++;
-              name.str ("");
-            }
-        }
-    }
-}
-
-Ipv4Address
-GetIpv4AddressFromNode(Ptr<Node> node)
-{
-  Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
-  Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4->GetAddress (1, 0);
-  Ipv4Address ipv4Address = ipv4InterfaceAddressDst.GetLocal ();
-  return ipv4Address;
-}
-
-string
-GetIpv4AddressFromNodeInStr(Ptr<Node> node)
-{
-  Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
-  Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4->GetAddress (1, 0);
-  Ipv4Address ipv4Address = ipv4InterfaceAddressDst.GetLocal ();
-  return Ipv4ToString(ipv4Address.Get());
-}
-
-void
-InitHostArray(const NodeContainer &Host_c)
-{
-  for (uint32_t i = 0; i < Host_c.GetN (); i++)
-    {
-      Host_c.Get (i)->m_locked = 0;
-      hostArray.push_back (Host_c.Get (i));
-    }
-}
-
-// Note: flow size must be less than flowSizeThreshold
-uint32_t
-GetShortFlowSize()
-{
-  static UniformVariable uniformFlowSize (1, g_FlowSizeThresh/1024); // 1KB ~ 1024KB, lasting max ~20ms @ 100Mbps
-  return static_cast<uint32_t> (uniformFlowSize.GetValue () * 1024); // 1024~ 1048576 B
-}
-
-// Note: flow size must be large than flowSizeThreshold
-uint32_t
-LargeFlowSize()
-{
-  if (g_trafficMatrix == PERMUTATION_DIST)
-    {
-      if (g_linkCapacity == "100Mbps")
-        {
-          static UniformVariable uniformFlowSize (6, 51);   // 64M ~ 512M, or lasting for 0.5s ~ 4s
-          return static_cast<uint32_t> (uniformFlowSize.GetValue () * 1024 * 1024);
-        }
-      else
-        { // g_linkCapacity == "1000Mbps"
-          static UniformVariable uniformFlowSize (64, 512); // 64M ~ 512M, or lasting for 0.5s ~ 4s
-          return static_cast<uint32_t> (uniformFlowSize.GetValue () * 1024 * 1024);
-        }
-    }
-  else
-    { // g_trafficMatrix == RANDOM_DIST or INCAST_DIST
-      if (g_linkCapacity == "100Mbps")
-        {
-          static ParetoVariable paretoFlowSize (2.0, 1.5, 8.0); // 2/3*9M=6M,    2*96M=18M,   8*9M=72M
-          double pareto = paretoFlowSize.GetValue ();
-          return static_cast<uint32_t> (pareto * 9 * 1024 * 1024);
-        }
-      else
-        { // g_linkCapacity == "1000Mbps"
-          static ParetoVariable paretoFlowSize (2.0, 1.5, 8.0); // 2/3*96M=64M,  2*96M=192M,  8*96M=768M
-          double pareto = paretoFlowSize.GetValue ();
-          return static_cast<uint32_t> (pareto * 96 * 1024 * 1024);
-        }
-    }
-  cout << "LargeFlowSize() -> TM is not match...exit(100) will be called...check you simulation parameters!" << endl;
-  exit (100);
-  return 0;
-}
-
-void
-LocateHostCoordinates(Ptr<Node> node, uint32_t& ipod, uint32_t& itor, uint32_t& ihost)
-{
-  NS_LOG_FUNCTION_NOARGS();
-  uint32_t addr = GetIpv4AddressFromNode(node).Get();
-  ipod = (addr & 0x00FF0000) >> 16;
-  itor = (addr & 0x0000FF00) >> 8;
-  ihost= (addr & 0x000000FF);
-//ihost= ((addr & 0x000000FF) - 2) / nHostAddr;
-//cout << "LocateHostCoordinates()-> "<< GetIpv4AddressFromNode (node) << " = 10." << ipod << "." << itor << "." << ihost << endl;
-}
-
-Ptr<Node>
-RandomPickHost(uint32_t& ipod, uint32_t& itor, uint32_t& ihost)
-{
-  NS_LOG_FUNCTION_NOARGS();
-  static UniformVariable uniformPod (0, g_K);
-  static UniformVariable uniformTor (0, g_K / 2);
-  static UniformVariable uniformHost (0, g_K - (g_K/2)); // upLinksOfTOR = K/2
-  static UniformVariable uniformArray (0, g_K * (g_K / 2) * (g_K - (g_K/2))); // upLinksOfTOR = K/2
-  // locally : pick one node randomly from node container
-  if (ipod != (uint32_t) -1 && itor != (uint32_t) -1 && ihost != (uint32_t) -1)
-    {
-      uint32_t i = static_cast<uint32_t> (uniformArray.GetValue ());
-      LocateHostCoordinates (hostArray.at (i), ipod, itor, ihost);
-      return hostArray[i];
-    }
-  // globally: pick one pod, tor and host randomly from their corresponding containers
-  if (ipod == (uint32_t) -1)
-    ipod = static_cast<uint32_t> (uniformPod.GetValue ());
-  if (itor == (uint32_t) -1)
-    itor = static_cast<uint32_t> (uniformTor.GetValue ());
-  if (ihost == (uint32_t) -1)
-    ihost = static_cast<uint32_t> (uniformHost.GetValue ());
-  return host[ipod][itor].Get (ihost);
-}
-
-void
-PermutationTraffic()
-{
-  static UniformVariable uniformPermutation;
-  std::vector<Ptr<Node> > des = hostArray;
-  uint32_t size = des.size();
-  uint32_t s = 0, d = 0;
-  while (size)
-    {
-      d = uniformPermutation.GetInteger(0, size - 1);
-      TransferData(hostArray[s], des[d], LargeFlowSize());
-      s++;
-      Ptr<Node> tmp = des[d];
-      des[d] = des[size - 1];
-      des[size - 1] = tmp;
-      size--;
-    }
-}
-
-bool
-IssueLargeFlows(Ptr<Node> src, Ptr<Node> des, double prob)
-{
-  NS_LOG_FUNCTION_NOARGS();
-  static UniformVariable uniformVar (0, 1.0);
-  if (uniformVar.GetValue () > prob)
-    return false;
-  uint32_t ipod, itor, ihost;
-  while (!src || src == des)
-    { // Pick Random Source
-      ipod = 0, itor = 0, ihost = 0;
-      src = RandomPickHost (ipod, itor, ihost);
-    }
-  while (!des || src == des)
-    { // Pick Random Destination
-      ipod = 0, itor = 0, ihost = 0;
-      des = RandomPickHost (ipod, itor, ihost);
-      if (largeFlowCap > 0 && des->m_locked >= largeFlowCap)
-        des = 0; // re-select one
-    }
-  NS_ASSERT (src != des);
-  uint32_t appid = TransferData (src, des, LargeFlowSize ());
-  des->m_locked++; // how many large flows are destined to des node ?
-  src->m_largeFlows[appid] = des;
-  return true;
-}
-
-void
-IssueNotInnerRackFlows(Ptr<Node> src)
-{
-  NS_LOG_FUNCTION_NOARGS();
-  uint32_t ipod, itor, ihost, dpod, dtor, dhost;
-  LocateHostCoordinates (src, ipod, itor, ihost);
-  Ptr<Node> des = 0;
-  do
-    {
-      dpod = -1, dtor = -1, dhost = -1;
-      des = RandomPickHost (dpod, dtor, dhost);
-//      if (largeFlowCap > 0 && des->m_locked >= largeFlowCap)
-//        continue;
-    }
-  while ((ipod == dpod && itor == dtor) || (largeFlowCap > 0 && des->m_locked >= largeFlowCap));
-  IssueLargeFlows (src, des, 1.0);
-}
-
-void
-IssuePermutation (const NodeContainer &allHosts)
-{
-  ComputePermutationFlows ();
-  ExecutePermutationFlows (allHosts);
-  PrintPFlowsToFile (SetupSimFileName ("FLOW_LIST"));
-}
-
-void
-SetupShortFlow(MpTcpBulkSendHelper &source, string &socketModelTmp)
-{ // By activating "sfltcp", all transport schemes will use TCP for short flows
-  if (g_shortFlowType != SF_NONE)
-      { // ShortFlowConfig()
-        switch (g_shortFlowType)
-          {
-        case SF_TCP:
-          socketModelTmp = "TCP";
-          source.SetAttribute ("DCTCP", BooleanValue (false));
-          source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-          break;
-        case SF_DCTCP:
-          socketModelTmp = "DCTCP";
-          source.SetAttribute ("DCTCP", BooleanValue (true));
-          source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-          break;
-        case SF_XMP:
-          socketModelTmp = "XMP";
-          source.SetAttribute ("DCTCP", BooleanValue (false));
-          source.SetAttribute ("CongestionControl", StringValue ("XMP"));
-          break;
-        case SF_ECN:
-          socketModelTmp = "ECN";
-          source.SetAttribute ("DCTCP", BooleanValue (true));
-          source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-          source.SetAttribute ("SlowDownEcnLike", BooleanValue (true));
-          break;
-        default:
-          break;
-          }
-        g_shortFlowSubflows = 1;
-        source.SetAttribute ("MaxSubflows", UintegerValue (g_shortFlowSubflows));
-        source.SetAttribute ("SocketModel", StringValue (socketModelTmp));
-      }
-}
-
-void
-IssuePFabric (const NodeContainer &allHosts)
-{
-  pFabSeed = g_seed;  // take seed from above in the code
-  linkSpeed = static_cast<double>(GetLinkRate (g_linkCapacity));
-
-  cout << "Generating pFabric flows for " << g_totalHost << " hosts";
-  cout << "\tload: " << pload;
-  cout << "\tpFabSeed: " << pFabSeed;
-  cout << endl;
-
-  srand48 (pFabSeed); // set seed for random number generator
-//GetCDFData (pTraffic); // populate CDF table [we populate it within the main]
-
-  // pre-compute pFabric flows
-  cout << "Computing " << flowNum << " flows...";
-  PreComputePFlows (pTraffic, allHosts);
-  PrintPFlowsToFile (SetupSimFileName ("FLOW_LIST"));
-  cout << "DONE" << endl;
-  // prepare the sending applications on every host
-  // I have essentially copied this part from what is done below
-  // sink apps are installed earlier, before pFabric generation traffic code
-  // this could be combined with the flow generation loops, keeping them separate can avoid confusion
-  for (int i = 0; i < flowNum; i++)
-    { // cout << "Installing flow " << i+1 << " / " << flowNum << endl;
-      // get flow source and destination
-      int src = flowList.at (i).iSrc;
-      int dst = flowList.at (i).iDst;
-      double sendTime = flowList.at (i).time;  // this is in ms
-      uint64_t fSize = flowList.at (i).size;
-      uint64_t flowSizeBytes = fSize * MAXDATASIZE;
-      uint32_t flowId = i;
-      uint16_t port = dst + 1;
-
-      Ptr<Node> srcNode = allHosts.Get (src);  // get src IP, it complains if called "srcNode"
-      Ptr<Ipv4> ipv4Client = srcNode->GetObject<Ipv4> ();
-      Ipv4InterfaceAddress iaddrClient = ipv4Client->GetAddress (1, 0);  // (0, 0) is loopback
-      Ipv4Address ipv4AddrClient = iaddrClient.GetLocal ();
-
-      Ptr<Node> dstNode = allHosts.Get (dst);
-      Ptr<Ipv4> ipv4Server = dstNode->GetObject<Ipv4> ();
-      Ipv4InterfaceAddress iaddrServer = ipv4Server->GetAddress (1, 0);
-      Ipv4Address ipv4AddrServer = iaddrServer.GetLocal ();
-      // set up application attributes
-      // for InetSocketAddress(<address>, <dstport>)
-      // use the sinks made previously
-      MpTcpBulkSendHelper source ("ns3::TcpSocketFactory", InetSocketAddress (Ipv4Address (ipv4AddrServer), port));
-      source.SetAttribute ("MaxBytes", UintegerValue (flowSizeBytes));  // use computed flow size
-      string socketModelTmp = GetSocketModel();
-      source.SetAttribute("SocketModel", StringValue(socketModelTmp));
-
-      if (flowSizeBytes < g_FlowSizeThresh)
-        {
-          ++g_totalShortFlows;
-          source.SetAttribute ("FlowType", StringValue ("Short"));  // do I keep this with pFabric? YES
-          cmAnalisys (SHORT, ipv4AddrClient, ipv4AddrServer);
-
-          // By activating "sfltcp", all transport schemes will use TCP for short flows
-          if (g_shortFlowType == SF_TCP || g_shortFlowType == SF_DCTCP)
-            { // IssuePFabric()
-              if (g_shortFlowType == SF_TCP )
-                {
-                  socketModelTmp = "TCP";
-                  source.SetAttribute ("DCTCP", BooleanValue (false)); // DCTCP is disable by default
-                }
-              if (g_shortFlowType == SF_DCTCP)
-                {
-                  socketModelTmp = "DCTCP";
-                  source.SetAttribute ("DCTCP", BooleanValue (true)); // DCTCP is disable by default
-                }
-              g_shortFlowSubflows = 1;
-              source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-              source.SetAttribute ("MaxSubflows", UintegerValue (g_shortFlowSubflows));
-              source.SetAttribute ("SocketModel", StringValue (socketModelTmp));
-            }
-        }
-      else
-        {
-          ++g_totalLargeFlows;
-          source.SetAttribute ("FlowType", StringValue ("Large"));  // do I keep this with pFabric? YES
-          cmAnalisys (LARGE, ipv4AddrClient, ipv4AddrServer);
-          // IssuePFabric()
-          if (g_slowDownEcnLike)
-            source.SetAttribute ("SlowDownEcnLike", BooleanValue (g_slowDownEcnLike));
-        }
-      source.SetAttribute ("FlowId", UintegerValue (flowId));
-      string flowLayer = GetFlowLayer(ipv4AddrClient, ipv4AddrServer);
-      source.SetAttribute("FlowLayer", StringValue(flowLayer));
-      source.SetAttribute ("OutputFileName", StringValue (SetupSimFileName ("RESULT")));   // change this?
-      source.SetAttribute ("OutputFileNameDctcp", StringValue (SetupSimFileName ("DCTCP")));
-
-      // schedule application start
-      ApplicationContainer tmp = source.Install (allHosts.Get (src)); // install application on src node
-      tmp.Start (Seconds (sendTime / 1000.0));
-      sourceLargeFlowApps.push_back (tmp);
-    }
-  cout << "\nSimulation is performing with " << pTraffic << " traffic matrix (pFabric) ...\n" << endl;
-}
-
-void
-IssueDistributedRead()
-{
-  NS_LOG_FUNCTION_NOARGS();
-  static UniformVariable uniformVar;
-//static ExponentialVariable expArrival(readArrivalInterval, 10*readArrivalInterval); // ms
-  static LogNormalVariable logNormalArrival (
-      log (readArrivalInterval) - 0.5 * log (1.0 + 10.0 * readArrivalInterval / (readArrivalInterval * readArrivalInterval)),
-      sqrt (log (1.0 + 10.0 * readArrivalInterval / (readArrivalInterval * readArrivalInterval))));
-
-  std::vector<Ptr<Node> > hosts = hostArray;
-  uint32_t totalhost = hosts.size ();
-  // randomly pick a client node
-  uint32_t idx = uniformVar.GetInteger (0, totalhost - 1);
-  Ptr<Node> client = hosts[idx];
-  hosts[idx] = hosts[totalhost - 1];
-  totalhost--;
-  // create a read job
-  DatacenterJob_t* job = new DatacenterJob_t;
-  job->tmBegin = Simulator::Now ();
-  job->requestNode = client;
-  job->flowNum = readFlows;
-  job->jobId = ++jobId;
-  job->nextJobArrival = std::min (10.0 * readArrivalInterval, logNormalArrival.GetValue ()); // ms
-  // randomly pick some server nodes
-  for (uint32_t i = 0; i < job->flowNum; i++)
-    {
-      idx = uniformVar.GetInteger (0, totalhost - 1);
-      Ptr<Node> server = hosts[idx];
-      hosts[idx] = hosts[totalhost - 1];
-      totalhost--;
-      // issue requests
-      uint32_t appid = TransferData (client, server, readRequestFlowSize);
-      NS_ASSERT(appid != (uint32_t ) -1 && job->requestFlows.find (appid) == job->requestFlows.end () && client->m_dcJobs.find (appid) == client->m_dcJobs.end ());
-      job->requestFlows[appid] = server;
-      client->m_dcJobs[appid] = job;
-    }
-  activeJobs++;
-  peakActiveJobs = std::max (peakActiveJobs, activeJobs);
-  cout << Simulator::Now ().GetSeconds () << " " << "Jobs: " << totalJobs << "/"
-       << peakActiveJobs << "/" << activeJobs << " " << "NextArrival: "
-       << job->nextJobArrival << "ms" << std::endl;
-}
-
-void
-OutPutJobCompletion(double jct, uint32_t client, uint32_t jobId)
-{
-  Ptr<OutputStreamWrapper> stream = Create<OutputStreamWrapper> (SetupSimFileName ("JOB"), std::ios::app);
-  ostream *os = stream->GetStream ();
-  *os << Simulator::Now ().GetSeconds () << " " << jct << " [$" << client << "$][+" << jobId << "+]" << "[-" << jct << "-]" << endl;
-}
-
-void
-FlowExit(Ptr<Node> node, uint32_t index, uint32_t size, double elapse, double rate)
-{
-  //cout << node->GetId () << " " << index << " " << size << " " << endl;
-}
-
-void
-TransferExit(Ptr<Node> node, uint32_t index, uint32_t size, double elapse, double rate)
-{
-  NS_LOG_FUNCTION(node->GetId()<< index << size);
-  // Jobs
-  std::map<uint32_t, DatacenterJob_t*>::iterator itJob;
-  itJob = node->m_dcJobs.find (index);
-  if (itJob != node->m_dcJobs.end ())
-    {
-      DatacenterJob_t* job = (DatacenterJob_t*) itJob->second;
-      node->m_dcJobs.erase (itJob);
-      if (job->requestNode == node) // request exits
-        {
-          std::map<uint32_t, Ptr<Node> >::iterator itRequest;
-          itRequest = job->requestFlows.find (index);
-          NS_ASSERT(itRequest != job->requestFlows.end ());
-          Ptr<Node> server = (Ptr<Node> ) itRequest->second;
-          job->requestFlows.erase (itRequest);
-          // issue respond flows
-          uint32_t appid = TransferData (server, node, readResponseFlowSize);
-          NS_ASSERT(appid != (uint32_t ) -1 && server->m_dcJobs.find (appid) == server->m_dcJobs.end ());
-          server->m_dcJobs[appid] = job;
-        }
-      else // respond exits
-        {
-          job->flowNum--;
-          if (job->flowNum == 0) // job exits
-            {
-              NS_ASSERT(job->requestFlows.size () == 0);
-              double completionTime = Simulator::Now ().GetSeconds () - job->tmBegin.GetSeconds ();
-              completionTime *= 1000.0;
-              double nextArrival = job->nextJobArrival; //ms
-              OutPutJobCompletion (completionTime, job->requestNode->GetId (), job->jobId); // Add JCT to _JOB.data
-              uint32_t tmtId = job->jobId;
-              job->requestNode = 0;
-              delete job;
-              activeJobs--;
-              totalJobs++;
-              std::clog << Simulator::Now ().GetSeconds () << " Jobs: " << totalJobs << "/" << peakActiveJobs << "/" << activeJobs
-                  << " JobId: " << tmtId << " JobTime: " << completionTime << "ms NextJobArrival: " << nextArrival << "ms" << std::endl;
-              // issue the next job
-              if (g_trafficMatrix == INCAST_STRIDE)
-                {
-                  if (Simulator::Now().GetSeconds() <  (static_cast<double>(g_simTime)))
-                    Simulator::Schedule (Seconds (nextArrival / 1000.0), &IssueDistributedRead);
-//                  if (Simulator::Now ().GetSeconds () > g_simTime)
-//                    {
-//                      cout << "Stop -> ST[" << Simulator::Now ().GetSeconds () << "] TM[" << GetKeyFromValueTM (g_trafficMatrix)
-//                          << "] TotalJobs[" << totalJobs << "] ActiveJobs[" << activeJobs << "]" << endl;
-//                      g_isSimActive = false;
-//                      Simulator::Stop (Seconds (0.0));
-//                    }
-                }
-              else
-                {
-                  if (totalLargeFlows + activeLargeFlows < maxTotalLargeFlows)
-                    Simulator::Schedule (Seconds (nextArrival / 1000.0), &IssueDistributedRead);
-                }
-            }
-        }
-    }
-
-  // Large flows
-  std::map<uint32_t, Ptr<Node> >::iterator itLarge;
-  itLarge = node->m_largeFlows.find (index);
-  if (itLarge != node->m_largeFlows.end ())
-    {
-      Ptr<Node> desNode = itLarge->second;
-      node->m_largeFlows.erase (itLarge);
-      desNode->m_locked--;
-    }
-  if (size > g_FlowSizeThresh)
-    {
-      activeLargeFlows--;
-      totalLargeFlows++;
-      cout << Simulator::Now ().GetSeconds () << " LargeFlows: "
-           << totalLargeFlows << "/" << peakActiveLarges << "/"
-           << activeLargeFlows << " " << "Exit: " << size << " " << elapse << " "
-           << rate << std::endl;
-    }
-
-  // cleanup app
-  //node->RemoveApplication (index);
-
-  if (g_trafficMatrix == INCAST_DIST)
-    {
-      if (totalLargeFlows + activeLargeFlows < maxTotalLargeFlows)
-        { // issue a new large flow
-          if (size > g_FlowSizeThresh)
-            Simulator::ScheduleNow (&IssueNotInnerRackFlows, node);
-        }
-      else
-        { // simulator exits
-          if (activeJobs + activeLargeFlows == 0)
-            {
-              g_isSimActive = false;
-              Simulator::Stop(Seconds(0.0));
-            }
-        }
-    }
-  else if (g_trafficMatrix == PERMUTATION_DIST)
-    {
-      if (activeLargeFlows == 0)
-        {
-          if (totalLargeFlows >= maxTotalLargeFlows)
-            Simulator::Stop (Seconds (0.0));
-          else
-            Simulator::ScheduleNow (&PermutationTraffic);
-        }
-    }
-  else if (g_trafficMatrix == RANDOM_DIST)
-    {
-      if (totalLargeFlows + activeLargeFlows < maxTotalLargeFlows)
-        IssueLargeFlows (node, 0, 1.0);
-      else if (activeLargeFlows == 0)
-        Simulator::Stop (Seconds (0.0));
-    }
-  else
-    {
-//      if (activeJobs + activeLargeFlows == 0)
-//        {
-//          cout << "Traffic Matrix is undefined -> Simulator exit" << endl;
-//          g_isSimActive = false;
-//          Simulator::Stop (Seconds (0.0));
-//        }
-    }
-}
-
-uint32_t
-TransferData(Ptr<Node> src, Ptr<Node> des, uint32_t flowSize)
-{
-  NS_LOG_FUNCTION(src->GetId() << des->GetId() << flowSize );
-  if (src == des)
-    return -1;
-
-  Ipv4Address ipv4AddressDst = GetIpv4AddressFromNode(des);
-  Ipv4Address ipv4AddressSrc = GetIpv4AddressFromNode(src);
-
-  static ObjectFactory appFactory ("ns3::MpTcpBulkSendApplication");
-  Ptr<MpTcpBulkSendApplication> app = appFactory.Create<MpTcpBulkSendApplication> ();
-  app->SetAttribute ("Remote", AddressValue (InetSocketAddress (ipv4AddressDst, des->GetId () + 1)));
-  app->SetAttribute ("MaxBytes", UintegerValue (flowSize)); // Zero is unlimited.
-  string socketModelTmp = GetSocketModel();
-  app->SetAttribute("SocketModel", StringValue(socketModelTmp));
-
-  string flowType;
-  uint32_t sfsf = 0, lfsf = 0;
-  SetupRightSubflows(sfsf, lfsf);
-  if (flowSize > 0 && flowSize <= g_FlowSizeThresh)
-    {
-      flowType = "Short";
-      app->SetAttribute("MaxSubflows", UintegerValue(sfsf));
-      app->SetAttribute("DCTCP", BooleanValue(false));  // false by default - dctcp is not active for SF
-
-      // By activating "sfltcp", all transport schemes will use TCP for short flows
-      if (g_shortFlowType == SF_TCP || g_shortFlowType == SF_DCTCP || g_shortFlowType == SF_ECN)
-        { // TransferData ()
-          if (g_shortFlowType == SF_TCP)
-            {
-              socketModelTmp = "TCP";
-              app->SetAttribute ("DCTCP", BooleanValue (false)); // All short flows are standard TCP (no dctcp)
-            }
-          if (g_shortFlowType == SF_DCTCP)
-            {
-              socketModelTmp = "DCTCP";
-              app->SetAttribute ("DCTCP", BooleanValue (true)); // All short flows are standard TCP (no dctcp)
-            }
-          if (g_shortFlowType == SF_ECN)
-            {
-              socketModelTmp = "ECN";
-              app->SetAttribute ("DCTCP", BooleanValue (true));
-              app->SetAttribute ("SlowDownEcnLike", BooleanValue (true));
-            }
-          g_shortFlowSubflows = 1;
-          app->SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-          app->SetAttribute ("MaxSubflows", UintegerValue (g_shortFlowSubflows));
-          app->SetAttribute ("SocketModel", StringValue (socketModelTmp));
-        }
-    }
-  else
-    {
-      flowType = "Large";
-      app->SetAttribute("MaxSubflows", UintegerValue(lfsf));
-      activeLargeFlows++;
-      peakActiveLarges = std::max (peakActiveLarges, activeLargeFlows);
-
-      // TransferData()
-      if (g_slowDownEcnLike)
-        app->SetAttribute ("SlowDownEcnLike", BooleanValue (g_slowDownEcnLike));
-    }
-  app->SetAttribute("FlowType", StringValue(flowType));
-  int flowId = src->GetNApplications();
-  app->SetAttribute("FlowId", UintegerValue (flowId));
-  string flowLayer = GetFlowLayer(ipv4AddressSrc, ipv4AddressDst);
-  app->SetAttribute("FlowLayer", StringValue(flowLayer));
-  string tempString = SetupSimFileName("RESULT");
-  app->SetAttribute("OutputFileName", StringValue(tempString));
-  app->SetAttribute("OutputFileNameDctcp", StringValue(SetupSimFileName("DCTCP")));
-
-  if (flowType == "Short")
-    cmAnalisys(SHORT, ipv4AddressSrc, ipv4AddressDst);
-  else
-    cmAnalisys(LARGE, ipv4AddressSrc, ipv4AddressDst);
-
-  app->SetStartTime(Seconds (0.0));
-  if (g_trafficMatrix == INCAST_STRIDE)
-    app->SetStopTime (Seconds (g_simTime));
-
-  app->m_Notify = MakeCallback (TransferExit);
-  app->m_index = src->AddApplication (app); //  this node will generate start/stop events.
-
-  if (flowType == "Large")
-    {
-      cout << Simulator::Now ().GetSeconds () << " " << "LargeFlows: " << totalLargeFlows << "/" << peakActiveLarges << "/"
-           << activeLargeFlows << " " << "Transfer: " << flowSize << " [" << Names::FindName (src) << " " << Names::FindName (des)
-           << "] {" << des->m_locked << "} [" << src->GetId () << " -> " << des->GetId () << "] AppId[" << app->m_index << "]"
-           << std::endl;
-    }
-  return app->m_index;
-}
-
-string
-isActive(bool param)
-{
-  if (param)
-    return "On";
-  else
-    return "Off";
-}
-
-uint64_t
-GetLinkRate(string linkRate)
-{
-  DataRate tmp(linkRate);
-  return tmp.GetBitRate();
-}
-
-void
-PrintLinkRate(Ptr<Node> node)
-{
-  Ptr<NetDevice> dev;
-  DataRateValue str; // StringValue str;
-  uint32_t devices = node->GetNDevices();
-  for (uint32_t i = 1; i < devices; i++)
-    {
-      dev = node->GetDevice(i);
-      dev->GetAttribute(string("DataRate"), str);
-      cout << "Device(" << i << ") ->" << str.Get().GetBitRate() / 1000000 << "Mbps" << endl;
-    }
-}
-
-// SF_NONE, SF_TCP, SF_MPTCP, SF_DCTCP, SF_ECN, SF_XMP
-void
-SetupStringToSFT()
-{
-  stringToShortFlowType["NONE"] = SF_NONE;
-  stringToShortFlowType["TCP"] = SF_TCP;
-  stringToShortFlowType["MPTCP"] = SF_MPTCP;
-  stringToShortFlowType["DCTCP"] = SF_DCTCP;
-  stringToShortFlowType["ECN"] = SF_ECN;
-  stringToShortFlowType["XMP"] = SF_XMP;
-}
-
-// PERMUTATION, PERMUTATION_LIMIT, STRIDE, RANDOM, SHORT_FLOW
-void
-SetupStringToTM()
-{
-  stringToTrafficMatrix["PERMUTATION"] = PERMUTATION;
-  stringToTrafficMatrix["STRIDE"] = STRIDE;
-  stringToTrafficMatrix["RANDOM"] = RANDOM;
-  stringToTrafficMatrix["SHORT_FLOW"] = SHORT_FLOW;
-  stringToTrafficMatrix["NONE"] = NONE;
-  stringToTrafficMatrix["INCAST_STRIDE"] = INCAST_STRIDE;
-  stringToTrafficMatrix["INCAST_DIST"] = INCAST_DIST;
-  stringToTrafficMatrix["RANDOM_DIST"] = RANDOM_DIST;
-  stringToTrafficMatrix["PERMUTATION_DIST"] = PERMUTATION_DIST;
-  stringToTrafficMatrix["P_FABRIC"] = P_FABRIC;
-  stringToTrafficMatrix["P_PERMUTATION"] = P_PERMUTATION;
-}
-
-void
-SetupStringToST()
-{
-  stringToSocketType["TCP"] = TCP;
-  stringToSocketType["MPTCP"] = MPTCP;
-}
-
-void
-SetupStringToHSL()
-{
-  stringToHotSpotLayers["Host"] = Host;
-  stringToHotSpotLayers["Tor"]  = Tor;
-  stringToHotSpotLayers["Aggr"] = Aggr;
-  stringToHotSpotLayers["Core"] = Core;
-}
-
-string
-GetKeyFromValueSFT(ShortFlowType_t sft)
-{
-  map<string, ShortFlowType_t>::const_iterator it = stringToShortFlowType.begin();
-  for (; it != stringToShortFlowType.end(); it++)
-    {
-      if (it->second == sft)
-        return it->first;
-    }
-  return "";
-}
-
-string
-GetKeyFromValueTM(TrafficMatrix_t tm)
-{
-  map<string, TrafficMatrix_t>::const_iterator it = stringToTrafficMatrix.begin();
-  for (; it != stringToTrafficMatrix.end(); it++)
-    {
-      if (it->second == tm)
-        return it->first;
-    }
-  return "";
-}
-
-string
-GetKeyFromValueST(SocketType_t st)
-{
-  map<string, SocketType_t>::const_iterator it = stringToSocketType.begin();
-  for (; it != stringToSocketType.end(); it++)
-    {
-      if (it->second == st)
-        return it->first;
-    }
-  return "";
-}
-
-string
-GetKeyFromValueHSL(Layers_t tl)
-{
-  map<string, Layers_t>::const_iterator it = stringToHotSpotLayers.begin();
-  for (; it != stringToHotSpotLayers.end(); it++)
-    {
-      if (it->second == tl)
-        return it->first;
-    }
-  return "";
-}
-
-string
-SetupSimFileName(string input)
-{
-  ostringstream oss;
-  oss.str ("");
-  oss << g_simName << "_" << g_topology << "_" << g_totalHost << "_"
-      << GetSocketModel () << "_" << GetKeyFromValueTM (g_trafficMatrix) << "_"
-      << input << "_" << g_simInstance << ".data";
-  string tmp = oss.str ();
-  oss.str ("");
-  return tmp;
-}
-
-uint32_t
-GetReTxThresh(Ipv4Address ipv4Src, Ipv4Address ipv4Dst)
-{
-  uint8_t src[4];
-  ipv4Src.Serialize(src);
-  uint8_t dst[4];
-  ipv4Dst.Serialize(dst);
-  if (src[1] == dst[1] && src[2] == dst[2])
-    {
-      return 0;
-    }
-  else if (src[1] == dst[1])
-    {
-      return g_numAggr; // 4
-    }
-  else
-    {
-      return g_totalCore; // 16
-    }
-}
-
-string
-GetSocketModel ()
-{
-  string socketmodel = "NULL";
-  switch (g_socketType)
-    {
-  case MPTCP:
-    if (g_enableDCTCP)
-      socketmodel = "DCMPTCP";
-    else
-      socketmodel = "MPTCP";
-    break;
-  case TCP:
-    if (g_enableDCTCP)
-      socketmodel = "DCTCP";
-    else
-      socketmodel = "TCP";
-    break;
-  default:
-    break;
-    }
-  return socketmodel;
-}
-
-string
-GetFlowLayer(Ipv4Address ipv4Src, Ipv4Address ipv4Dst)
-{
-  uint8_t src[4];
-  ipv4Src.Serialize(src);
-  uint8_t dst[4];
-  ipv4Dst.Serialize(dst);
-  if (src[1] == dst[1] && src[2] == dst[2])
-    {
-      return "TOR";
-    }
-  else if (src[1] == dst[1])
-    {
-      return "AGGR"; // 4
-    }
-  else
-    {
-      return "CORE"; // 16
-    }
-}
-
-uint32_t
-GetSubflows(Ipv4Address ipv4Src, Ipv4Address ipv4Dst)
-{
-  uint8_t src[4];
-  ipv4Src.Serialize(src);
-  uint8_t dst[4];
-  ipv4Dst.Serialize(dst);
-  if (src[1] == dst[1] && src[2] == dst[2])
-    {
-      return 1;
-    }
-  else if (src[1] == dst[1])
-    {
-      return std::min((int)g_numAggr, 8);   // min (4, 8)
-    }
-  else
-    {
-      return std::min((int)g_totalCore, 8); // min (16, 8)
-    }
-}
-
-void
-cmAnalisys(FlowType_t ft, Ipv4Address ipv4Src, Ipv4Address ipv4Dst)
-{
-  uint8_t src[4];
-  ipv4Src.Serialize(src);
-  uint8_t dst[4];
-  ipv4Dst.Serialize(dst);
-
-  switch (ft)
-    {
-  case SHORT:
-    if (src[1] == dst[1] && src[2] == dst[2])
-      {
-        ShortFlow[0]++;
-        AllFlow[0]++;
-      }
-    else if (src[1] == dst[1])
-      {
-        ShortFlow[1]++;
-        AllFlow[1]++;
-      }
-    else if (src[1] != dst[1])
-      {
-        ShortFlow[2]++;
-        AllFlow[2]++;
-      }
-    else
-      exit(1);
-    break;
-  case LARGE:
-    if (src[1] == dst[1] && src[2] == dst[2])
-      {
-        LargeFlow[0]++;
-        AllFlow[0]++;
-      }
-    else if (src[1] == dst[1])
-      {
-        LargeFlow[1]++;
-        AllFlow[1]++;
-      }
-    else if (src[1] != dst[1])
-      {
-        LargeFlow[2]++;
-        AllFlow[2]++;
-      }
-    else
-      exit(1);
-    break;
-  default:
-    exit(1);
-    break;
-    }
-}
-
-void
-OutPutCMStat()
-{
-  double totalLF = LargeFlow[0] + LargeFlow[1] + LargeFlow[2];
-  double totalSF = ShortFlow[0] + ShortFlow[1] + ShortFlow[2];
-  double totalAF = AllFlow[0] + AllFlow[1] + AllFlow[2];
-  // Large Flows
-  double LargeTorPercentage = round(((LargeFlow[0] / totalLF) * 100));
-  double LargeAggrPercentage = round(((LargeFlow[1] / totalLF) * 100));
-  double LargeCorePercentage = round(((LargeFlow[2] / totalLF) * 100));
-  // Short Flows
-  double ShortTorPercentage = round(((ShortFlow[0] / totalSF) * 100));
-  double ShortAggrPercentage = round(((ShortFlow[1] / totalSF) * 100));
-  double ShortCorePercentage = round(((ShortFlow[2] / totalSF) * 100));
-  // All Flows
-  double AllTorPercentage = round(((AllFlow[0] / totalAF) * 100));
-  double AllAggrPercentage = round(((AllFlow[1] / totalAF) * 100));
-  double AllCorePercentage = round(((AllFlow[2] / totalAF) * 100));
-
-  Ptr<OutputStreamWrapper> stream = Create<OutputStreamWrapper>(SetupSimFileName("CM"), std::ios::out);
-  SimHeaderWritter(stream);
-  ostream *osCM = stream->GetStream();
-  *osCM << "FlowType\t"    << "ToR\t" << "Aggr\t" << "Core"   << endl;
-  *osCM << "[(Large)]\t[!" << LargeTorPercentage  << "!]\t[@" << LargeAggrPercentage << "@]\t[#" << LargeCorePercentage << "#]" << endl;
-  *osCM << "[(Short)]\t[!" << ShortTorPercentage  << "!]\t[@" << ShortAggrPercentage << "@]\t[#" << ShortCorePercentage << "#]" << endl;
-  *osCM << "[(All)]\t[!"   << AllTorPercentage    << "!]\t[@" << AllAggrPercentage   << "@]\t[#" << AllCorePercentage   << "#]" << endl;
-  SimFooterWritter(stream);
-}
-
-void
-OutPutCore()
-{
-  Ptr<OutputStreamWrapper> stream = Create<OutputStreamWrapper>(SetupSimFileName("CORE"), std::ios::out);
-  ostream *os = stream->GetStream();
-  for (uint32_t s = 0; s <= g_simTime; s++)            // [Seconds]
-    {
-      *os << s;
-      for (uint32_t m = 0; m < 2; m++)                 // [Metrics]
-        {
-          for (uint32_t n = 0; n < core_c.GetN(); n++) // [Node]
-            {
-              for (uint32_t d = 1; d <= g_K; d++)      // [Dev]
-                {
-
-                  if (s == 0)
-                    *os << " " << "Link" << d;
-                  else
-                    {
-                      *os << "    " << core_data[s][m][n][d];
-                      if (m == 0)        // Utilization
-                        totalCoreUtil += core_data[s][m][n][d];
-                      else if (m == 1)   // Loss
-                        totalCoreLoss += core_data[s][m][n][d];
-                    }
-                }
-            }
-        }
-      *os << endl;
-    }
-}
-
-void
-OutPutAggr()
-{
-  Ptr<OutputStreamWrapper> stream_aggr = Create<OutputStreamWrapper>(SetupSimFileName("AGGR"), std::ios::out);
-  ostream *os_aggr = stream_aggr->GetStream();
-  for (uint32_t s = 0; s <= g_simTime; s++)            // [Seconds]
-    {
-      *os_aggr << s;
-      for (uint32_t m = 0; m < 2; m++)                 // [Metrics]
-        {
-          for (uint32_t n = 0; n < Aggr_c.GetN(); n++) // [Node]
-            {
-              for (uint32_t d = 1; d <= g_K; d++)      // [Dev]
-                {
-
-                  if (s == 0)
-                    *os_aggr << " " << "Link" << d;
-                  else
-                    {
-                      *os_aggr << "    " << aggr_data[s][m][n][d];
-                      if (m == 0)        // Utilization
-                        totalAggrUtil += aggr_data[s][m][n][d];
-                      else if (m == 1)   // Loss
-                        totalAggrLoss += aggr_data[s][m][n][d];
-                    }
-                }
-            }
-        }
-      *os_aggr << endl;
-    }
-}
-
-void
-OutPutTor()
-{
-  Ptr<OutputStreamWrapper> stream_tor = Create<OutputStreamWrapper>(SetupSimFileName("TOR"), std::ios::out);
-  ostream *os_tor = stream_tor->GetStream();
-  for (uint32_t s = 0; s <= g_simTime; s++)            // [Seconds]
-    {
-      *os_tor << s;
-      for (uint32_t m = 0; m < 2; m++)                 // [Metrics]
-        {
-          for (uint32_t n = 0; n < Tor_c.GetN(); n++)  // [Node]
-            {
-              for (uint32_t d = 1; d <= g_K; d++)      // [Dev]
-                {
-                  if (s == 0)
-                    *os_tor << " " << "Link" << d;
-                  else
-                    {
-                      *os_tor << "    " << tor_data[s][m][n][d];
-                      if (m == 0)        // ToR Utilization
-                        totalTorUtil += tor_data[s][m][n][d];
-                      else if (m == 1)   // ToR Loss
-                        totalTorLoss += tor_data[s][m][n][d];
-                    }
-                }
-            }
-        }
-      *os_tor << endl;
-    }
-}
-
-void
-OutPutHost(){
-  Ptr<OutputStreamWrapper> stream_host = Create<OutputStreamWrapper>(SetupSimFileName("HOST"), std::ios::out);
-    ostream *os_host = stream_host->GetStream();
-    for (uint32_t s = 0; s <= g_simTime; s++)            // [Seconds]
-      {
-        *os_host << s;
-        for (uint32_t m = 0; m < 2; m++)                 // [Metrics]
-          {
-            for (uint32_t n = 0; n < Host_c.GetN(); n++) // [Node]
-              {
-                for (uint32_t d = 1; d <= 1; d++)        // [Dev]
-                  {
-                    if (s == 0)
-                      *os_host << " " << "Link" << d;
-                    else
-                      {
-                        *os_host << "    " << host_data[s][m][n][d];
-                        if (m == 0)      // host Utilization
-                          totalHostUtil += host_data[s][m][n][d];
-                        else if (m == 1) // host Loss
-                          totalHostLoss += host_data[s][m][n][d];
-                      }
-                  }
-              }
-          }
-        *os_host << endl;
-      }
-}
-
-void
-PrintCMStat()
-{
-  const char * format = "%s \t%.1f \t%.1f \t%.1f    \t%03d \n";
-  printf("\n");
-  printf("FlowType\tTOR\tAggr\tCore   \t\tTotal\n");
-  printf("--------\t----\t----\t-------\t\t-----\n");
-  printf(format, "Large   ", round(LargeFlow[0]), round(LargeFlow[1]), round(LargeFlow[2]), g_totalLargeFlows);
-  printf(format, "Short   ", round(ShortFlow[0]), round(ShortFlow[1]), round(ShortFlow[2]), g_totalShortFlows);
-  printf(format, "All     ", round(AllFlow[0]), round(AllFlow[1]), round(AllFlow[2]), g_totalLargeFlows + g_totalShortFlows);
-  printf("\n");
-}
-
-void
-PrintSimParams()
-{
-  string shortFlowPlot = isActive(g_enableSfPlotting);
-  string largeFlowPlot = isActive(g_enableLfPlotting);
-  string redQ = isActive(g_enableRED);
-  string dctcpT = isActive(g_enableDCTCP);
-
-  cout << endl;
-  cout << "Socket Type      : " << GetKeyFromValueST(g_socketType).c_str() << endl;
-  cout << "SF Subflows      : " << g_shortFlowSubflows << endl;
-  cout << "LF Subflows      : " << g_subflows << endl;
-  cout << "Link Rate        : " << g_linkCapacity << endl;
-  cout << "Switching Thrsh  : " << g_FlowSizeThresh << "B" <<endl;
-  cout << "Traffic Matrix   : " << GetKeyFromValueTM(g_trafficMatrix).c_str() << endl;
-  cout << "ShortFlow TM     : " << GetKeyFromValueTM(g_shortFlowTM).c_str() << endl;
-  cout << "Bandwidth Ratio  : " << g_ratio << ":1" << endl;
-  cout << "QueueModeBytes   : " << isActive(g_queueModeBytes) << endl;
-  cout << "RED              : " << redQ.c_str() << endl;
-  cout << "DCTCP            : " << dctcpT.c_str() << endl;
-  cout << "XMP's Beta       : " << g_XmpBeta << endl;
-  cout << "XMP's Gamma      : " << g_XmpGamma << endl;
-  cout << "Host Marking     : " << isActive(g_enabledHostMarking) << endl;
-  cout << "ShortFlowType    : " << GetKeyFromValueSFT(g_shortFlowType).c_str() << endl;
-  cout << "SF SizeRandom    : " << isActive(g_shortFlowSizeUniRandom) << endl;
-  cout << "SF SizeDist      : " << isActive(g_shortFlowSizeDist) << endl;
-  cout << "LongFlows        : " << g_connxLimit << "% of totalhosts" << endl;
-  cout << "Seed             : " << g_seed << endl;
-  cout << "Instance         : " << g_simInstance << endl;
-  cout << "ReadFlows        : " << readFlows << endl;
-  cout << "ReadArrivalInterv: " << readArrivalInterval << endl;
-  cout << "LargeFlowCap     : " << largeFlowCap << endl;
-  cout << "DynamicSubflow   : " << isActive(g_dynamicSubflow) << endl;
-  cout << "IncastThreshold  : " << g_incastThreshold << endl;
-  cout << "IncastExitThresh : " << g_incastExitThreshold << endl;
-  cout << "CwndMin          : " << g_cwndMin << endl;
-  cout << "RcwndScale       : " << g_rwndScale << endl;
-  cout << "------------------ " << endl;
-  cout << "SF Plot          : " << shortFlowPlot.c_str() << endl;
-  cout << "LF Plot          : " << largeFlowPlot.c_str() << endl;
-  cout << "SimDuration      : " << g_simTime << endl;
-  cout << "QsampInterval    : " << g_queueSampInterval << endl;
-  cout << "QmaxCounter      : " << g_queueMaxCounter << endl;
-  cout << "SlowDownXmpLike  : " << isActive (g_slowDownXmpLike) << endl;
-  cout << "SlowDownEcnLike  : " << isActive (g_slowDownEcnLike) << endl;
-  cout << "---- pFabric ----- " << endl;
-  cout << "pFabricLoad      : " << pload << endl;
-  cout << "pFabricTM        : " << pTraffic << endl;
-  cout << endl;
-}
-
-void
-SimTimeMonitor()
-{
-  NS_LOG_UNCOND("ClockTime: " << Simulator::Now().GetSeconds());
-  double now = Simulator::Now().GetSeconds();
-  cout << "[" << g_simName << "](" << g_topology << "){" << g_totalHost << "}[" << GetSocketModel() << "]{"
-      << GetKeyFromValueTM(g_trafficMatrix)
-      << "} -> SimClock: " << now << endl;
-  if (now < g_simTime)
-    Simulator::Schedule(Seconds(0.1), &SimTimeMonitor);
-}
-
-vector<connection*>*
-GetShortCM(vector<connection*>* CM)
-{
-  vector<connection*>* ret = new vector<connection*>();
-  vector<connection*>::iterator it;
-
-  for (it = (*CM).begin(); it != (*CM).end(); it++)
-    {
-      if ((*it)->large == true)
-        {
-          continue;
-        }
-      else
-        ret->push_back((*it));
-    }
-  return ret;
-}
-
-void
-ShortFlowConfig(vector<connection*>* CM, const NodeContainer &allHosts)
-{
-  int cmSize = (*CM).size();
-  int pos;
-  connection* connx;
-  pos = rand() % cmSize;
-  connx = (*CM).at(pos);
-  int src = connx->src;
-  int dst = connx->dst;
-  assert(connx->large == false);
-
-  // src setup
-  Ptr<Node> srcNode = allHosts.Get(src);
-  Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
-  Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
-  Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
-
-  // dst setup
-  Ptr<Node> dstNode = allHosts.Get(dst);
-  Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
-  Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
-  Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
-
-  // Assign flowId
-  int flowId = srcNode->GetNApplications();
-
-  // Source
-  if (g_shortFlowSizeUniRandom)
-    g_shortFlowSize = GetShortFlowSize (); // @ShortFlowConfig()
-  if (g_shortFlowSizeDist)
-    { // It throws an error if both --sfrand and --sfdist are active
-      assert(g_shortFlowSizeUniRandom == 0);
-      g_shortFlowSize = ExtrapolateFlowSize (drand48 ()) * MAXDATASIZE; // Sizes are per byte
-    }
-
-  MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), dstNode->GetId() + 1));
-  source.SetAttribute("MaxBytes", UintegerValue(g_shortFlowSize));
-  source.SetAttribute("FlowId", UintegerValue(flowId));
-
-  source.SetAttribute("MaxSubflows", UintegerValue(g_shortFlowSubflows));
-
-  string socketModelTmp = GetSocketModel();
-  source.SetAttribute("SocketModel", StringValue(socketModelTmp));
-
-  if (g_shortFlowType != SF_NONE)
-    { // ShortFlowConfig()
-      switch (g_shortFlowType)
-        {
-      case SF_TCP:
-        socketModelTmp = "TCP";
-        source.SetAttribute ("DCTCP", BooleanValue (false));
-        source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-        break;
-      case SF_DCTCP:
-        socketModelTmp = "DCTCP";
-        source.SetAttribute ("DCTCP", BooleanValue (true));
-        source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-        break;
-      case SF_XMP:
-        socketModelTmp = "XMP";
-        source.SetAttribute ("DCTCP", BooleanValue (false));
-        source.SetAttribute ("CongestionControl", StringValue ("XMP"));
-        break;
-      case SF_ECN:
-        socketModelTmp = "ECN";
-        source.SetAttribute ("DCTCP", BooleanValue (true));
-        source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-        source.SetAttribute ("SlowDownEcnLike", BooleanValue (true));
-        break;
-      default:
-        break;
-        }
-      g_shortFlowSubflows = 1;
-      source.SetAttribute ("MaxSubflows", UintegerValue (g_shortFlowSubflows));
-      source.SetAttribute ("SocketModel", StringValue (socketModelTmp));
-    }
-
-  source.SetAttribute("FlowType", StringValue("Short"));
-  string flowLayer = GetFlowLayer(ipv4AddressSrc, ipv4AddressDst);
-  source.SetAttribute("FlowLayer", StringValue(flowLayer));
-  string tempString = SetupSimFileName("RESULT");
-  source.SetAttribute("OutputFileName", StringValue(tempString));
-  source.SetAttribute("OutputFileNameDctcp", StringValue(SetupSimFileName("DCTCP")));
-
-  cmAnalisys(SHORT, ipv4AddressSrc, ipv4AddressDst);
-  ApplicationContainer tmp = source.Install(srcNode);
-
-  // Start
-  tmp.Get(0)->SetStartTime(Seconds(0));
-
-  // STOP
-  double diff = (double) g_simTime - Simulator::Now().GetSeconds();
-  double nextStop = (diff > 0) ? diff : 0;
-  tmp.Get(0)->SetStopTime(Seconds(nextStop));
-
-  sourceShortFlowApps.push_back(tmp); //sourceShortFlowApps[src][dst].push_back(tmp);
-
-  // Schedule next arrival
-  if (Simulator::Now().GetSeconds() <  (static_cast<double>(g_simTime) - g_arrivalUpperBound))
-    {
-      double nextEvent = exponential(g_lamda);
-      cout << "[" << GetKeyFromValueST (g_socketType) << "]{" << GetKeyFromValueTM (g_shortFlowTM) << "}[" << flowLayer
-          << "] SFT[" << GetKeyFromValueSFT(g_shortFlowType)<< "] SFSF[" << g_shortFlowSubflows
-          << "] SockModel[" << socketModelTmp << "] StartNow: " << Simulator::Now ().GetSeconds ()
-          << " Stop: " << nextStop << " (" << src << " -> " << dst << ") NextArrival: " << nextEvent << " flowSize(KB): " << g_shortFlowSize/1024 << endl;
-      Simulator::Schedule(Seconds(nextEvent), &ShortFlowConfig, CM, allHosts);
-    }
-}
-
-Ptr<Queue>
-FindQueue(Ptr<NetDevice> dev)
-{
-  PointerValue ptr;
-  dev->GetAttribute("TxQueue", ptr);
-  return ptr.Get<Queue>();
-}
-
-void
-SetupHostQueues ()
-{ // No marking at host layer
-  if (g_enableRED && g_enableDCTCP && !g_hasHostQueueSetup)
-    {
-      for (uint32_t i = 0; i < Host_c.GetN (); i++)
-        { // dev = 1 as loop back interface should not be counted here.
-          for (uint32_t j = 1; j < Host_c.Get (i)->GetNDevices (); j++)
-            {
-              Ptr<Queue> txQueue = FindQueue (Host_c.Get (i)->GetDevice (j));
-              Ptr<RedQueue> red = DynamicCast<RedQueue> (txQueue);
-
-              if (g_queueModeBytes)
-                {
-                  red->SetTh (200 * MAXDATASIZE, 200 * MAXDATASIZE);
-                  red->SetQueueLimit (g_queueLimit * MAXDATASIZE);
-                }
-              else
-                {
-                  red->SetTh (200, 200);
-                  red->SetQueueLimit (g_queueLimit);
-                }
-
-              DoubleValue max, min;
-              UintegerValue limit;
-              red->GetAttribute ("MinTh", min);
-              red->GetAttribute ("MaxTh", max);
-              red->GetAttribute ("QueueLimit", limit);
-              cout << "Host(" << i << ") RedQueue[" << j << "] Max: " << max.Get () << " Min: " << min.Get () << " Limit: "
-                  << limit.Get () << endl;
-            }
-        } // end of loop
-      // We only setup Host's RED queues once
-      g_hasHostQueueSetup = true;
-    } // enf of Host's if block
-  if (!g_enableRED && g_enableDCTCP && !g_hasHostQueueSetup)
-      {
-        for (uint32_t i = 0; i < Host_c.GetN (); i++)
-          { // dev = 1 as loop back interface should not be counted here.
-            for (uint32_t j = 1; j < Host_c.Get (i)->GetNDevices (); j++)
-              {
-                Ptr<Queue> txQueue = FindQueue (Host_c.Get (i)->GetDevice (j));
-                Ptr<DropTailQueue> dTail = DynamicCast<DropTailQueue> (txQueue);
-                BooleanValue isMarkableOld;
-                dTail->GetAttribute("Marking", isMarkableOld);
-                dTail->SetMarking(false);
-                BooleanValue isMarkableNew;
-                UintegerValue threhsold, maxPkts;
-                dTail->GetAttribute("Marking", isMarkableNew);
-                dTail->GetAttribute("MarkingTh", threhsold);
-                dTail->GetAttribute("MaxPackets", maxPkts);
-                cout << "Host(" << i << ") DropTailQueue[" << j << "] MaxPkts[" << maxPkts.Get() << "] MarkingTh["
-                     << threhsold.Get() << "] Marking: " << isActive(isMarkableOld.Get()) << " -> " << isActive(isMarkableNew.Get())
-                     << "" << endl;
-              }
-          } // end of loop
-        // We only setup Host's DropTail queues once
-        g_hasHostQueueSetup = true;
-      } // enf of Host's if block
-}
-
-void
-SimpleQueueTraces (const Layers_t &layer)
-{ // Currently, we look at core's queues only (uplinks and downlinks)
-  Ptr<OutputStreamWrapper> stream = Create<OutputStreamWrapper> (SetupSimFileName ("QUEUE"), std::ios::out | std::ios::app);
-  ostream* os = stream->GetStream ();
-
-  *os << g_queueCounter << " " << Simulator::Now ().GetMilliSeconds () << " ";
-  if (layer == Core || layer >= Core_Aggr)
-    {
-      for (uint32_t i = 0; i < core_c.GetN (); i++)
-        { // j should be 1 as the loopback interface should not be counted
-          for (uint32_t j = 1; j < core_c.Get (i)->GetNDevices (); j++)
-            {
-              Ptr<Queue> txQueue = FindQueue (core_c.Get (i)->GetDevice (j));
-              if (g_queueCounter == 0.0)
-                *os << "C" << i << "-" << j << " ";
-              else
-                *os << txQueue->GetNPackets () << " ";
-            }
-        } // end of loop
-    } //end of the core's if block
-  if (layer == Aggr || layer >= Core_Aggr)
-    {
-      for (uint32_t i = 0; i < Aggr_c.GetN (); i++)
-        { // j should 1 as loopback interface should not be counted
-          uint32_t numAggrDevices = Aggr_c.Get (i)->GetNDevices ();
-          uint32_t numAggrUplinks = (Aggr_c.Get (i)->GetNDevices () - 1) / 2;
-          for (uint32_t j = 1; j < numAggrDevices; j++)
-            {
-              //cout << "Aggr[" << i << "] numDevs[" << numAggrDevices << "] numUplinks[" << numAggrUplinks << "]" << endl;
-              Ptr<Queue> txQueue = FindQueue (Aggr_c.Get (i)->GetDevice (j));
-              if (j > numAggrUplinks)
-                { // It should work well when K is even like 8, 10, 12 and etc.
-                  if (g_queueCounter == 0.0)
-                    *os << "A" << i << "-" << j << " ";
-                  else
-                    *os << txQueue->GetNPackets () << " ";
-                }
-            }
-        } // end of loop
-    } //end of Aggr's if block
-
-  if (layer == Tor || layer >= Core_Aggr_Tor)
-    {
-      for (uint32_t i = 0; i < Tor_c.GetN(); i++)
-        { // j should 1 as loopback interface should not be counted
-          for (uint32_t j = 1; j <= g_numHost; j++)
-            { // Loop through the number of hosts per tor.
-              //cout << "Aggr[" << i << "] numDevs[" << numAggrDevices << "] numUplinks[" << numAggrUplinks << "]" << endl;
-              Ptr<Queue> txQueue = FindQueue(Tor_c.Get(i)->GetDevice(j));
-              if (g_queueCounter == 0.0)
-                *os << "T" << i << "-" << j << " ";
-              else
-                *os << txQueue->GetNPackets() << " ";
-            }
-        } // end of loop
-    } //end of Aggr's if block
-  *os << endl;
-  // Update g_queueCounter once...
-  g_queueCounter++;
-
-  if ((g_queueCounter < g_queueMaxCounter && ((uint32_t) Simulator::Now().GetSeconds() < g_simTime))
-      || (g_trafficMatrix == INCAST_DIST && g_isSimActive))
-    {
-      Simulator::Schedule(Seconds(g_queueSampInterval), &SimpleQueueTraces, layer);
-    }
-}
-
-void
-SetupTracesNew(const Layers_t &layer)
-{ // This works with traffic matrix > INCAST_DIST. This includes pFabric TMs
-  uint32_t T = (uint32_t) Simulator::Now().GetSeconds();
-  double sumUtil = 0.0;
-  if (layer == Core || layer >= Core_Aggr)
-    {
-      Ptr<OutputStreamWrapper> streamUtil = Create<OutputStreamWrapper> (SetupSimFileName ("CORE_UTIL"),
-                                                                         std::ios::out | std::ios::app);
-      ostream* osUtil = streamUtil->GetStream ();
-      Ptr<OutputStreamWrapper> streamLoss = Create<OutputStreamWrapper> (SetupSimFileName ("CORE_LOSS"),
-                                                                         std::ios::out | std::ios::app);
-      ostream* osLoss = streamLoss->GetStream ();
-      *osUtil << T << "\t";
-      *osLoss << T << "\t";
-      for (uint32_t i = 0; i < core_c.GetN (); i++)
-        { // j should 1 as lookback interface should not be counted
-          for (uint32_t j = 1; j < core_c.Get (i)->GetNDevices (); j++)
-            {
-              Ptr<Queue> txQueue = FindQueue (core_c.Get (i)->GetDevice (j));
-              uint32_t totalDropBytes = txQueue->GetTotalDroppedBytes ();
-              uint32_t totalRxBytes = txQueue->GetTotalReceivedBytes ();
-              uint32_t totalBytes = totalRxBytes + totalDropBytes;
-              if (T == 0)
-                {
-                  *osUtil << "C" << i << "-" << "L" << j << "\t";
-                  *osLoss << "C" << i << "-" << "L" << j << "\t";
-                }
-              else
-                {
-                  double util = (((double) totalRxBytes * 8 * 100) / GetLinkRate (g_linkCapacity));
-                  double loss = (((double) totalDropBytes / totalBytes) * 100);
-                  if (isNaN (util)) util = 0;
-                  if (isNaN (loss)) loss = 0;
-                  sumUtil += util;
-                  *osUtil << util << "\t";
-                  *osLoss << loss << "\t";
-                  txQueue->ResetStatistics (); // Reset txQueue
-
-                  sumCoreUtil += util;
-                  sumCoreLoss += loss;
-                  countCore++;
-                }
-            }
-        }
-      *osUtil << endl;
-      *osLoss << endl;
-    }
-  if (layer == Aggr || layer >= Core_Aggr)
-    {
-      Ptr<OutputStreamWrapper> streamUtil = Create<OutputStreamWrapper> (SetupSimFileName ("AGGR_UTIL"),
-                                                                         std::ios::out | std::ios::app);
-      ostream* osUtil = streamUtil->GetStream ();
-      Ptr<OutputStreamWrapper> streamLoss = Create<OutputStreamWrapper> (SetupSimFileName ("AGGR_LOSS"),
-                                                                         std::ios::out | std::ios::app);
-      ostream* osLoss = streamLoss->GetStream ();
-      *osUtil << T << "\t";
-      *osLoss << T << "\t";
-      for (uint32_t i = 0; i < Aggr_c.GetN (); i++)
-        { // j = 1 as loop back interface should not be counted
-          for (uint32_t j = 1; j < Aggr_c.Get (i)->GetNDevices (); j++)
-            {
-              Ptr<Queue> txQueue = FindQueue (Aggr_c.Get (i)->GetDevice (j));
-              uint32_t totalDropBytes = txQueue->GetTotalDroppedBytes ();
-              uint32_t totalRxBytes = txQueue->GetTotalReceivedBytes ();
-              uint32_t totalBytes = totalRxBytes + totalDropBytes;
-              if (T == 0)
-                {
-                  *osUtil << "A" << i << "-" << "L" << j << "\t";
-                  *osLoss << "A" << i << "-" << "L" << j << "\t";
-                }
-              else
-                {
-                  double util = (((double) totalRxBytes * 8 * 100) / GetLinkRate (g_linkCapacity));
-                  double loss = (((double) totalDropBytes / totalBytes) * 100);
-                  if (isNaN (util)) util = 0;
-                  if (isNaN (loss)) loss = 0;
-                  sumUtil += util;
-                  *osUtil << util << "\t";
-                  *osLoss << loss << "\t";
-                  txQueue->ResetStatistics ();
-
-                  sumAggrUtil += util;
-                  sumAggrLoss+= loss;
-                  countAggr++;
-                }
-            }
-        }
-      *osUtil << endl;
-      *osLoss << endl;
-    }
-  if (layer == Tor  || layer >= Core_Aggr_Tor)
-    {
-      Ptr<OutputStreamWrapper> streamUtil = Create<OutputStreamWrapper> (SetupSimFileName ("TOR_UTIL"),
-                                                                         std::ios::out | std::ios::app);
-      ostream* osUtil = streamUtil->GetStream ();
-      Ptr<OutputStreamWrapper> streamLoss = Create<OutputStreamWrapper> (SetupSimFileName ("TOR_LOSS"),
-                                                                         std::ios::out | std::ios::app);
-      ostream* osLoss = streamLoss->GetStream ();
-      *osUtil << T << "\t";
-      *osLoss << T << "\t";
-      for (uint32_t i = 0; i < Tor_c.GetN(); i++)
-        { // dev = 1 as loop back interface should not be counted here.
-          for (uint32_t j = 1; j < Tor_c.Get(i)->GetNDevices(); j++)
-            {
-              Ptr<Queue> txQueue = FindQueue(Tor_c.Get(i)->GetDevice(j));
-              uint32_t totalDropBytes = txQueue->GetTotalDroppedBytes();
-              uint32_t totalRxBytes = txQueue->GetTotalReceivedBytes();
-              uint32_t totalBytes = totalRxBytes + totalDropBytes;
-              if (T == 0)
-                {
-                  *osUtil << "T" << i << "-" << "L" << j << "\t";
-                  *osLoss << "T" << i << "-" << "L" << j << "\t";
-                }
-              else
-                {
-                  double util = (((double) totalRxBytes * 8 * 100) / GetLinkRate(g_linkCapacity));
-                  double loss = (((double) totalDropBytes / totalBytes) * 100);
-                  if (isNaN (util)) util = 0;
-                  if (isNaN (loss)) loss = 0;
-                  sumUtil += util;
-                  *osUtil << util << "\t";
-                  *osLoss << loss << "\t";
-                  txQueue->ResetStatistics ();
-
-                  sumTorUtil += util;
-                  sumTorLoss += loss;
-                  countTor++;
-                }
-            }
-        }
-      *osUtil << endl;
-      *osLoss << endl;
-    }
-  if (layer == Host || layer >= Core_Aggr_Tor_Host)
-    {
-      Ptr<OutputStreamWrapper> streamUtil = Create<OutputStreamWrapper> (SetupSimFileName ("HOST_UTIL"),
-                                                                         std::ios::out | std::ios::app);
-      ostream* osUtil = streamUtil->GetStream ();
-      Ptr<OutputStreamWrapper> streamLoss = Create<OutputStreamWrapper> (SetupSimFileName ("HOST_LOSS"),
-                                                                         std::ios::out | std::ios::app);
-      ostream* osLoss = streamLoss->GetStream ();
-      *osUtil << T << "\t";
-      *osLoss << T << "\t";
-      for (uint32_t i = 0; i < Host_c.GetN(); i++)
-        { // dev = 1 as loop back interface should not be counted here.
-          for (uint32_t j = 1; j < Host_c.Get(i)->GetNDevices(); j++)
-            {
-              Ptr<Queue> txQueue = FindQueue(Host_c.Get(i)->GetDevice(j));
-              uint32_t totalDropBytes = txQueue->GetTotalDroppedBytes();
-              uint32_t totalRxBytes = txQueue->GetTotalReceivedBytes();
-              uint32_t totalBytes = totalRxBytes + totalDropBytes;
-              if (T == 0)
-                {
-                  *osUtil << "H" << i << "-" << "L" << j << "\t";
-                  *osLoss << "H" << i << "-" << "L" << j << "\t";
-                }
-              else
-                {
-                  double util = (((double) totalRxBytes * 8 * 100) / GetLinkRate (g_linkCapacity));
-                  double loss = (((double) totalDropBytes / totalBytes) * 100);
-                  if (isNaN (util)) util = 0.0;
-                  if (isNaN (loss)) loss = 0.0;
-                  sumUtil += util;
-                  *osUtil << util << "\t";
-                  *osLoss << loss << "\t";
-                  txQueue->ResetStatistics ();
-
-                  sumHostUtil += util;
-                  sumHostLoss += loss;
-                  countHost++;
-                }
-            }
-        }
-      *osUtil << endl;
-      *osLoss << endl;
-    }
-  if (g_isSimActive == false)
-    {
-      cout << "Time[" << Simulator::Now ().GetSeconds () << "] " << "sumUtil["
-           << sumUtil << "] "
-           << "=> No Active Flows => Simulation will be stopped now!" << endl;
-      Simulator::Stop (Seconds (0.0));
-    }
-  else
-    Simulator::Schedule (Seconds (1), &SetupTracesNew, layer);
-}
-
-// [Second][Node][Dev][Metrics]
-void
-SetupTraces(const Layers_t &layer)
-{
-  uint32_t T = (uint32_t) Simulator::Now().GetSeconds();
-  if (layer == Core || layer >= Core_Aggr)
-    {
-      for (uint32_t i = 0; i < core_c.GetN(); i++)
-        { // j should 1 as lookback interface should not be counted
-          for (uint32_t j = 1; j < core_c.Get(i)->GetNDevices(); j++)
-            {
-              Ptr<Queue> txQueue = FindQueue(core_c.Get(i)->GetDevice(j));
-              uint32_t totalDropBytes = txQueue->GetTotalDroppedBytes();
-              uint32_t totalRxBytes = txQueue->GetTotalReceivedBytes();
-              uint32_t totalBytes = totalRxBytes + totalDropBytes;
-              core_data[T][0][i][j] = (((double) totalRxBytes * 8 * 100) / GetLinkRate(g_linkCapacity)); // Link Utilization
-              core_data[T][1][i][j] = (((double) totalDropBytes / totalBytes) * 100); // LossRate
-              // Make sure util is not nan
-              if (isNaN(core_data[T][0][i][j]))
-                core_data[T][0][i][j] = 0;
-              // Make sure loss is not nan
-              if (isNaN(core_data[T][1][i][j]))
-                core_data[T][1][i][j] = 0;
-              // Reset txQueue
-              txQueue->ResetStatistics();
-            }
-        }
-    }
-  if (layer == Aggr || layer >= Core_Aggr)
-    {
-      for (uint32_t i = 0; i < Aggr_c.GetN(); i++)
-        { // j = 1 as loop back interface should not be counted
-          for (uint32_t j = 1; j < Aggr_c.Get(i)->GetNDevices(); j++)
-            {
-              Ptr<Queue> txQueue = FindQueue(Aggr_c.Get(i)->GetDevice(j));
-              uint32_t totalDropBytes = txQueue->GetTotalDroppedBytes();
-              uint32_t totalRxBytes = txQueue->GetTotalReceivedBytes();
-              uint32_t totalBytes = totalRxBytes + totalDropBytes;
-              aggr_data[T][0][i][j] = (((double) totalRxBytes * 8 * 100) / GetLinkRate(g_linkCapacity));  // Link Utilization
-              aggr_data[T][1][i][j] = (((double) totalDropBytes / totalBytes) * 100);  // LossRate
-              // Make sure aggregation util is not nan
-              if (isNaN(aggr_data[T][0][i][j]))
-                aggr_data[T][0][i][j] = 0;
-              // Make sure aggregation loss is not nan
-              if (isNaN(aggr_data[T][1][i][j]))
-                aggr_data[T][1][i][j] = 0;
-              txQueue->ResetStatistics();
-            }
-        }
-    }
-  if (layer == Tor || layer >= Core_Aggr_Tor)
-    {
-      for (uint32_t i = 0; i < Tor_c.GetN(); i++)
-        { // dev = 1 as loop back interface should not be counted here.
-          for (uint32_t j = 1; j < Tor_c.Get(i)->GetNDevices(); j++)
-            {
-              Ptr<Queue> txQueue = FindQueue(Tor_c.Get(i)->GetDevice(j));
-              uint32_t totalDropBytes = txQueue->GetTotalDroppedBytes();
-              uint32_t totalRxBytes = txQueue->GetTotalReceivedBytes();
-              uint32_t totalBytes = totalRxBytes + totalDropBytes;
-              tor_data[T][0][i][j] = (((double) totalRxBytes * 8 * 100) / GetLinkRate(g_linkCapacity));
-              tor_data[T][1][i][j] = (((double) totalDropBytes / totalBytes) * 100);
-              // Make sure ToR util is not nan
-              if (isNaN(tor_data[T][0][i][j]))
-                tor_data[T][0][i][j] = 0;
-              // Make sure ToR loss is not nan
-              if (isNaN(tor_data[T][1][i][j]))
-                tor_data[T][1][i][j] = 0;
-              txQueue->ResetStatistics();
-            }
-        }
-    }
-  if (layer == Host || layer >= Core_Aggr_Tor_Host)
-    {
-      for (uint32_t i = 0; i < Host_c.GetN(); i++)
-        { // dev = 1 as loop back interface should not be counted here.
-          for (uint32_t j = 1; j < Host_c.Get(i)->GetNDevices(); j++)
-            {
-              Ptr<Queue> txQueue = FindQueue(Host_c.Get(i)->GetDevice(j));
-              uint32_t totalDropBytes = txQueue->GetTotalDroppedBytes();
-              uint32_t totalRxBytes = txQueue->GetTotalReceivedBytes();
-              uint32_t totalBytes = totalRxBytes + totalDropBytes;
-              double util = (((double) totalRxBytes * 8 * 100) / GetLinkRate(g_linkCapacity));
-              double loss = (((double) totalDropBytes / totalBytes) * 100);
-              if (isNaN(util))
-                util = 0;
-              if (isNaN(loss))
-                loss = 0;
-              host_data[T][0][i][j] = util;
-              host_data[T][1][i][j] = loss;
-
-              txQueue->ResetStatistics();
-            }
-        }
-    }
-  if (T < g_simTime)
-    Simulator::Schedule(Seconds(1), &SetupTraces, layer);
-}
-
-string
-GetDateTimeNow()
-{
-  time_t T = time(0);
-  struct tm* now = localtime(&T);
-  string simStartDate = asctime(now);
-  return simStartDate.substr(0, 24);
-}
-
-void
-SetSimStartTime()
-{
-  g_simStartTime = GetDateTimeNow();
-}
-
-string
-GetSimStartTime()
-{
-  return g_simStartTime;
-}
-
-void
-SimHeaderWritter(Ptr<OutputStreamWrapper> stream)
-{
-  ostream *os = stream->GetStream();
-  *os << "SimStart["        << g_simStartTime                         << "] "
-      << "SimName["         << g_simName                              << "] "
-      << "Topology["        << g_topology                             << "] "
-      << "TotalHost["       << g_totalHost                            << "] "
-      << "SockType["        << GetKeyFromValueST(g_socketType)        << "] "
-      << "TM["              << GetKeyFromValueTM(g_trafficMatrix)     << "] "
-      << "Ratio["           << g_ratio                                << "] "
-      << "SFSize["          << g_shortFlowSize                        << "] "
-      << "LFSize["          << g_flowSize                             << "] "
-      << "LR["              << g_linkCapacity                         << "] "
-      << "LD["              << g_linkDelay                            << "] "
-      << "Lambda["          << g_lamda                                << "] "
-      << "SimTime["         << g_simTime                              << "] "
-      << "LFLimit["         << g_connxLimit                           << "] "
-      << "FlowSizeThresh["  << g_FlowSizeThresh                       << "] "
-      << "SFSF["            << g_shortFlowSubflows                    << "] "
-      << "LFSF["            << g_subflows                             << "] "
-      << "DCTCP["           << isActive(g_enableDCTCP)                << "] "
-      << "RED["             << isActive(g_enableRED)                  << "] "
-      << "Gamma["           << g_XmpGamma                             << "] "
-      << "Beta["            << g_XmpBeta                              << "] "
-      << "QMB["             << isActive(g_queueModeBytes)             << "] "
-      << "HM["              << isActive(g_enabledHostMarking)         << "] "
-      << "LFDCTCP["         << isActive(g_largeFlowDCTCP)             << "] "
-      << "SFT["             << GetKeyFromValueSFT(g_shortFlowType)    << "] "
-      << "SFRand["          << isActive(g_shortFlowSizeUniRandom)     << "] "
-      << "RedMinTh["        << g_REDminTh                             << "] "
-      << "RedMaxTh["        << g_REDmaxTh                             << "] "
-      << "DctcpWeight["     << g_DCTCPWeight                          << "] "
-      << "Seed["            << g_seed                                 << "] "
-      << "Instance["        << g_simInstance                          << "] "
-      << "cwndMin["         << g_cwndMin                              << "] "
-      << "rcwndScale["      << g_rwndScale                            << "] "
-      << "DynamicSubflow["  << g_dynamicSubflow                       << "] "
-      << "IncastThreshold[" << g_incastThreshold                      << "] "
-      << "IncastExitThresh["<< g_incastExitThreshold                  << "] "
-      << "CC["              << g_cc                                   << "] "
-      << "ReadFlows["       << readFlows                              << "] "
-      << "ReadInterval["    << readArrivalInterval                    << "] "
-      << "LargeFlowCap["    << largeFlowCap                           << "] "
-      << "ShortFlowTM["     << GetKeyFromValueTM(g_shortFlowTM)       << "] "
-      << "LFTM["            << GetKeyFromValueTM(g_backgroundFlowTM)  << "] "
-      << "HostPerToR["      << g_numHost                              << "] "
-			<< "pload["           << pload                                  << "] "
-			<< "ptraffic["        << pTraffic                               << "] "
-			<< endl;
-}
-
-void
-SimFooterWritter(Ptr<OutputStreamWrapper> stream)
-{
-  ostream *os = stream->GetStream();
-  *os << "SimEnd [" << GetDateTimeNow() << "] AllFlows[" << sourceLargeFlowApps.size() + sourceShortFlowApps.size()
-      << "] LargeFlow[" << sourceLargeFlowApps.size() << "] ShortFlows[" << sourceShortFlowApps.size() << "]  CoreUtil["
-      << meanCoreUtil << "] CoreLoss[" << meanCoreLoss << "] AggrUtil[" << meanAggrUtil << "] AggrLoss[" << meanAggrLoss << "]"
-      << endl;
-}
-
-void
-SimOverallResultWritter()
-{
-  Ptr<OutputStreamWrapper> stream = Create<OutputStreamWrapper>(SetupSimFileName("OVERALL"), std::ios::out | std::ios::app);
-  SimHeaderWritter(stream);
-  ostream *os = stream->GetStream();
-  if (g_trafficMatrix < INCAST_DIST)
-    {
-      meanCoreUtil = totalCoreUtil / (g_simTime * g_totalCore * g_K);
-      meanCoreLoss = totalCoreLoss / (g_simTime * g_totalCore * g_K);
-      if (isNaN (meanCoreUtil))
-        meanCoreUtil = 0;
-      if (isNaN (meanCoreLoss))
-        meanCoreLoss = 0;
-      meanAggrUtil = totalAggrUtil / (g_simTime * g_totalAggr * g_K);
-      meanAggrLoss = totalAggrLoss / (g_simTime * g_totalAggr * g_K);
-      if (isNaN (meanAggrUtil))
-        meanAggrUtil = 0;
-      if (isNaN (meanAggrLoss))
-        meanAggrLoss = 0;
-      meanTorUtil = totalTorUtil / (g_simTime * g_totalToR * (g_numAggr + g_numHost));
-      meanTorLoss = totalTorLoss / (g_simTime * g_totalToR * (g_numAggr + g_numHost));
-      if (isNaN (meanTorUtil))
-        meanTorUtil = 0;
-      if (isNaN (meanTorLoss))
-        meanTorLoss = 0;
-      meanHostUtil = totalHostUtil / (g_simTime * g_totalHost);
-      meanHostLoss = totalHostLoss / (g_simTime * g_totalHost);
-      if (isNaN (meanHostUtil))
-        meanHostUtil = 0;
-      if (isNaN (meanHostLoss))
-        meanHostLoss = 0;
-  }
-  else
-    { // g_trafficMatrix > INCAST_DIST, e.g. P_FABRIC
-      meanCoreUtil = sumCoreUtil / countCore;
-      meanCoreLoss = sumCoreLoss / countCore;
-      if (isNaN (meanCoreUtil)) meanCoreUtil = 0;
-      if (isNaN (meanCoreLoss)) meanCoreLoss = 0;
-      meanAggrUtil = sumAggrUtil / countAggr;
-      meanAggrLoss = sumAggrLoss / countAggr;
-      if (isNaN (meanAggrUtil)) meanAggrUtil = 0;
-      if (isNaN (meanAggrLoss)) meanAggrLoss = 0;
-      meanTorUtil  = sumTorUtil  / countTor;
-      meanTorLoss  = sumTorLoss  / countTor;
-      if (isNaN (meanTorUtil)) meanTorUtil = 0;
-      if (isNaN (meanTorLoss)) meanTorLoss = 0;
-      meanHostUtil = sumHostUtil / countHost;
-      meanHostLoss = sumHostLoss / countHost;
-      if (isNaN (meanHostUtil)) meanHostUtil = 0;
-      if (isNaN (meanHostLoss)) meanHostLoss = 0;
-    }
-  *os << "CoreUtil [!"     << meanCoreUtil << "!]\nCoreLoss [@" << meanCoreLoss << "@]\nAggrUtil [#" << meanAggrUtil
-      << "#]\nAggrLoss [$" << meanAggrLoss << "$]\nTorUtil [%"  << meanTorUtil  << "%]\nTorLoss [^"  << meanTorLoss
-      << "^]\nHostUtil [&" << meanHostUtil << "&]\nHostLoss [*" << meanHostLoss << "*]" << endl;
-  SimFooterWritter(stream);
-}
-
-void
-OutPutPoissonDist()
-{
-  Ptr<OutputStreamWrapper> stream = Create<OutputStreamWrapper>(SetupSimFileName("POISSON"), std::ios::out);
-  ostream *os = stream->GetStream();
-  for (uint32_t i = 0; i < poissonArrival.size(); i++)
-    {
-      if (i>0)
-        *os << i << "\t" << poissonArrival[i] << endl;
-    }
-}
-
-void
-OutPutTotalArrivals()
-{
-  Ptr<OutputStreamWrapper> stream = Create<OutputStreamWrapper>(SetupSimFileName("ARRIVAL"), std::ios::out);
-  ostream *os = stream->GetStream();
-  for (uint32_t i = 0; i < totalArrival.size(); i++)
-    *os << totalArrival[i].first << "\t" << totalArrival[i].second << endl;
-}
-
-void
-OutPutArrivalsPerHost(vector<connection*>* CM, const NodeContainer &allHosts)
-{
-  Ptr<OutputStreamWrapper> stream = Create<OutputStreamWrapper>(SetupSimFileName("AVERAGE"), std::ios::out);
-  ostream *os = stream->GetStream();
-  for (uint32_t i = 0; i < CM->size(); i++)
-    {
-      connection* connx = (*CM).at(i);
-      Ptr<Node> srcNode = allHosts.Get(connx->src);
-      uint32_t appId = srcNode->GetNApplications();
-      *os << srcNode->GetId() << "\t"<< appId << endl;
-    }
-}
-
-void
-SimResultHeaderGenerator()
-{
-  Ptr<OutputStreamWrapper> streamSimParam = Create<OutputStreamWrapper>(SetupSimFileName("RESULT"),
-      std::ios::out | std::ios::app);
-  SimHeaderWritter(streamSimParam);
-}
-
-void
-SimResultFooterGenerator()
-{
-  Ptr<OutputStreamWrapper> streamSimParam = Create<OutputStreamWrapper>(SetupSimFileName("RESULT"),
-      std::ios::out | std::ios::app);
-  SimFooterWritter(streamSimParam);
-}
-
-// Setup cmd callbacks
-bool
-SetNumPort(std::string input)
-{
-  cout << "SwitchPort: " << g_K << " -> " << input << endl;
-  g_K = atoi(input.c_str());
-  // Setup topology parameters
-  g_numPod = g_K;                    // Pods:                        8
-  g_numHost = (g_K / 2) * g_ratio;   // Host per ToR switch:         4
-  g_numToR = g_K / 2;                // ToR swtiches per pod:        4
-  g_numAggr = g_K / 2;               // Aggr switches per pod:       4
-  g_numCore = g_K / 2;               // Core switches in group:      2
-  g_numGroup = g_K / 2;              // Core switches in group:      2
-  g_totalHost = ((g_K * g_K * g_K) / 4) * g_ratio;
-  g_totalToR = g_numToR * g_numPod;
-  g_totalAggr = g_numAggr * g_numPod;
-  g_totalCore = g_numCore * g_numGroup;
-  return true;
-}
-
-bool
-SetNumSubflow(std::string input)
-{
-  cout << "Subflows         : " << g_subflows << " -> " << input << endl;
-  g_subflows = atoi(input.c_str());
-  return true;
-}
-
-bool
-SetCongestionControl(std::string input)
-{
-  cout << "CongestionControl: " << g_cc << " -> " << input << endl;
-  g_cc = input;
-  return true;
-}
-
-bool
-SetFlowSize(std::string input)
-{
-  cout << "FlowSize         : " << g_flowSize << " -> " << input << endl;
-  g_flowSize = atoi(input.c_str());
-  return true;
-}
-
-bool
-SetShortFlowSize(std::string input)
-{
-  g_shortFlowSize = atoi(input.c_str()) * 1000;
-  cout << "ShortFlowSize    : " << g_shortFlowSize << endl;
-  return true;
-}
-
-bool
-SetSimTime(std::string input)
-{
-  cout << "SimDuration      : " << g_simTime << " -> " << input << endl;
-  g_simTime = atoi(input.c_str());
-  g_queueMaxCounter = static_cast<uint32_t>(round(g_simTime/g_queueSampInterval));
-  return true;
-}
-
-bool
-SetLamda(std::string input)
-{
-  cout << "Lamda            : " << g_lamda << " -> " << input << endl;
-  g_lamda = atoi(input.c_str());
-  return true;
-}
-
-bool
-SetTrafficMatrix(std::string input)
-{
-  cout << "TrafficMatrix    : " << GetKeyFromValueTM(g_trafficMatrix) << " -> " << input << endl;
-  if (stringToTrafficMatrix.count(input) != 0)
-    {
-      g_trafficMatrix = stringToTrafficMatrix[input];
-    }
-  else
-    NS_FATAL_ERROR("Input for setting up traffic matrix has spelling issue - try again!");
-  return true;
-}
-
-bool
-SetSFTM(std::string input)
-{
-  cout << "ShortFlowTM      : " << GetKeyFromValueTM(g_shortFlowTM) << " -> " << input << endl;
-  if (stringToTrafficMatrix.count(input) != 0)
-    {
-      g_shortFlowTM = stringToTrafficMatrix[input];
-    }
-  else
-    {
-      cerr << "Input for setting up short flow raffic matrix has spelling issue - try again!" << endl;
-    }
-  return true;
-}
-
-bool
-SetSocketType(std::string input)
-{
-  cout << "SocketType       : " << GetKeyFromValueST(g_socketType) << " -> " << input << endl;
-  if (stringToSocketType.count(input) != 0)
-    {
-      g_socketType = stringToSocketType[input];
-    }
-  else
-    NS_FATAL_ERROR("Input for setting up socket type has spelling issue - try again!");
-  return true;
-}
-
-bool
-SetSimInstance(std::string input)
-{
-  cout << "SimInstance      : " << g_simInstance << " -> " << input << endl;
-  g_simInstance = input;
-  return true;
-}
-
-bool
-SetConnxLimit(std::string input)
-{
-  cout << "ConnectionLimit  : " << g_connxLimit << " -> " << input << endl;
-  g_connxLimit = atoi(input.c_str());
-  return true;
-}
-
-bool
-SetRatio(std::string input)
-{
-  cout << "Bandwidth ratio  : " << g_ratio << " -> " << input << endl;
-  g_ratio = atoi(input.c_str());
-  g_numHost = (g_K / 2) * g_ratio;
-  g_totalHost = ((g_K * g_K * g_K) / 4) * g_ratio;
-  return true;
-}
-
-bool
-SetLinkRate(std::string input)
-{
-  cout << "Link rate        : " << g_linkCapacity << " -> " << input+"Mbps" << endl;
-  g_linkCapacity = input+"Mbps";
-  return true;
-}
-
-bool
-SetSimName(std::string input)
-{
-  cout << "SimName          : " << g_simName << " -> " << input << endl;
-  g_simName = input;
-  return true;
-}
-
-bool
-SetSFSF(std::string input)
-{
-  cout << "shortFlowSubflows: " << g_shortFlowSubflows << " -> " << input << endl;
-  g_shortFlowSubflows = atoi(input.c_str());
-  return true;
-}
-
-bool
-SetLfPlot(std::string input)
-{
-  cout << "LargeFlowPlotting: " << g_enableLfPlotting << " -> " << input << endl;
-  g_enableLfPlotting = atoi(input.c_str());
-  return true;
-}
-
-bool
-SetSfPlot(std::string input)
-{
-  cout << "ShortFlowPlotting: " << g_enableSfPlotting << " -> " << input << endl;
-  g_enableSfPlotting = atoi(input.c_str());
-  return true;
-}
-
-bool
-SetRandomGap(std::string input)
-{
-  cout << "SetRandomGap     : " << g_rGap << " -> " << input << endl;
-  g_rGap = atoi(input.c_str());
-  return true;
-}
-
-bool
-SetArrivalUpperBound(std::string input)
-{
-  cout << "SetUpperBound    : " << g_arrivalUpperBound << " -> " << input << endl;
-  g_arrivalUpperBound = atof(input.c_str());
-  return true;
-}
-
-bool
-SetShortFlowDCTCP(std::string input)
-{ // Only for backward compatibility reason
-  if (atoi (input.c_str ()) == 0)
-    {
-      cout << "ShortFlowDCTCP   : " << GetKeyFromValueSFT (g_shortFlowType) << " -> " << "SF_NONE" << endl;
-      g_shortFlowType = SF_NONE;
-    }
-  else
-    {
-      cout << "ShortFlowDCTCP   : " << GetKeyFromValueSFT (g_shortFlowType) << " -> " << "SF_DCTCP" << endl;
-      g_shortFlowType = SF_DCTCP;
-    }
-  return true;
-}
-
-bool
-SetLargeFlowDCTCP(std::string input)
-{
-  cout << "LargeFlowDCTCP   : " << g_largeFlowDCTCP << " -> " << input << endl;
-  g_largeFlowDCTCP = atoi(input.c_str());
-  return true;
-}
-
-bool
-SetSFST(std::string input)
-{
-  cout << "SetSFST          : " << g_shortFlowStartTime << " -> " << input << endl;
-  g_shortFlowStartTime = atof(input.c_str());
-  return true;
-}
-
-bool
-SetFlowSizeThresh(std::string input)
-{
-  g_FlowSizeThresh = atoi(input.c_str());
-  g_FlowSizeThresh = g_FlowSizeThresh * 1024;
-  cout << "SetFlowSizeThresh: " << g_FlowSizeThresh/(double)1024 << "KB" <<endl;
-  return true;
-}
-
-bool
-SetRED(std::string input)
-{
-  cout << "Enable RED Queue : " << g_enableRED << " -> " << input << endl;
-  g_enableRED = atoi(input.c_str());
-  return true;
-}
-
-bool
-SetDCTCP(std::string input)
-{
-  cout << "Enable DCTCP     : " << g_enableDCTCP << " -> " << input << endl;
-  g_enableDCTCP = atoi(input.c_str());
-  return true;
-}
-bool
-SetDctcpRecord(std::string input)
-{
-  cout << "EnableDctcpRecord: " << g_dctcpFastReTxRecord << " -> " << input << endl;
-  g_dctcpFastReTxRecord = atoi(input.c_str());
-  return true;
-}
-
-bool
-SetREDmin(std::string input)
-{
-  cout << "RED Min Threshold: " << g_REDminTh << " -> " << input << endl;
-  g_REDminTh = atof(input.c_str());
-  return true;
-}
-
-bool
-SetREDmax(std::string input)
-{
-  cout << "RED Max Threshold: " << g_REDmaxTh << " -> " << input << endl;
-  g_REDmaxTh = atof(input.c_str());
-  return true;
-}
-
-bool
-SetDTQ(std::string input)
-{
-  cout << "DTQ              : " << g_enableDTQmark << " -> " << input << endl;
-  g_enableDTQmark = atoi (input.c_str ());
-  return true;
-}
-
-
-bool
-SetDTQMarkTh(std::string input)
-{
-  cout << "DTQmarkTh        : " << g_DTQmarkTh << " -> " << input << endl;
-  g_DTQmarkTh = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetDCTCPweight(std::string input)
-{
-  cout << "DCTCP Weight     : " << g_DCTCPWeight << " -> " << input << endl;
-  g_DCTCPWeight = atof(input.c_str());
-  return true;
-}
-
-bool
-SetREDweight(std::string input)
-{
-  cout << "RED Max Weight   : " << g_REDWeight << " -> " << input << endl;
-  g_REDWeight = atof(input.c_str());
-  return true;
-}
-
-bool
-SetQueueLimit(std::string input)
-{
-  cout << "QueueLimit       : " << g_queueLimit << " -> " << input << endl;
-  g_queueLimit = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetQueueSampInterval(std::string input)
-{
-  cout << "QueueSampInter   : " << g_queueSampInterval << " -> " << input << endl;
-  g_queueSampInterval = atof(input.c_str());
-  g_queueMaxCounter = static_cast<uint32_t>(round(g_simTime/g_queueSampInterval));
-  return true;
-}
-
-bool
-SetHostMarking (std::string input)
-{
-  cout << "HostMarking      : " << g_enabledHostMarking << " -> " << input << endl;
-  g_enabledHostMarking = atoi (input.c_str ());
-  return true;
-}
-bool
-SetSimpleQueueTrace (std::string input)
-{
-  cout << "SimpleQueueTrace : " << g_simpleQueueTrace << " -> " << input << endl;
-  g_simpleQueueTrace = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetQueueMode (std::string input)
-{
-  cout << "QueueModeBytes   : " << g_queueModeBytes << " -> " << input << endl;
-  g_queueModeBytes = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetFabricTM (std::string input)
-{
-  cout << "Set pFabric TM   : " << pTraffic << " -> " << input << endl;
-  pTraffic = input;
-  return true;
-}
-
-bool
-SetFabricLoad (std::string input)
-{
-  cout << "Set pFabric Load : " << pload << " -> " << input << endl;
-  pload = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetFabricFlowNum (std::string input)
-{
-  cout << "Set pFabric flow#: " << flowNum << " -> " << input << endl;
-  flowNum = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetShortFlowLegacyTcp (std::string input)
-{ // Only for backward compatibility reason
-  if (atoi (input.c_str ()) == 0)
-    {
-      cout << "ShortFlowLegcyTcp: " << GetKeyFromValueSFT (g_shortFlowType) << " -> " << "SF_NONE" << endl;
-      g_shortFlowType = SF_NONE;
-    }
-  else
-    {
-      cout << "ShortFlowLegcyTcp: " << GetKeyFromValueSFT (g_shortFlowType) << " -> " << "SF_TCP" << endl;
-      g_shortFlowType = SF_TCP;
-    }
-  return true;
-}
-
-bool
-SetShortFlowSizeUniRandom (std::string input)
-{
-  cout << "ShortFlowSizeRand: " << g_shortFlowSizeUniRandom << " -> " << input << endl;
-  g_shortFlowSizeUniRandom = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetShortFlowSizeDist (std::string input)
-{
-  cout << "ShortFlowSizeDist: " << g_shortFlowSizeDist << " -> " << input << endl;
-  g_shortFlowSizeDist = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetLargeFlowCap (std::string input)
-{
-  cout << "LargeFlowCap     : " << largeFlowCap << " -> " << input << endl;
-  largeFlowCap = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetReadFlows (std::string input)
-{
-  cout << "ReadFlows        : " << readFlows << " -> " << input << endl;
-  readFlows = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetMaxTotalLargeFlows (std::string input)
-{
-  cout << "MaxTotalLargeFlow: " << maxTotalLargeFlows << " -> " << input << endl;
-  maxTotalLargeFlows = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetXmpGamma (std::string input)
-{
-  cout << "XMP's Gamma      : " << g_XmpGamma << " -> " << input << endl;
-  g_XmpGamma = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetXmpBeta (std::string input)
-{
-  cout << "XMP's Beta       : " << g_XmpBeta << " -> " << input << endl;
-  g_XmpBeta = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetRatePlot (std::string input)
-{
-  cout << "RatePlotting     : " << g_enableRatePlotting << " -> " << input << endl;
-  g_enableRatePlotting = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetRateBeat (std::string input)
-{
-  cout << "RateBeat         : " << g_rateBeat << " -> " << input << endl;
-  g_rateBeat = atof (input.c_str ());
-  return true;
-}
-bool
-SetSDXL (std::string input)
-{
-  cout << "SlowDownXMPLike  : " << g_slowDownXmpLike << " -> " << input << endl;
-  g_slowDownXmpLike = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetSDEL (std::string input)
-{
-  cout << "SlowDownEcnLike  : " << g_slowDownEcnLike << " -> " << input << endl;
-  g_slowDownEcnLike = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetShortFlowType(std::string input)
-{
-  cout << "ShortFlowType    : " << GetKeyFromValueSFT (g_shortFlowType) << " -> " << input << endl;
-  if (stringToShortFlowType.count (input) != 0)
-    {
-      g_shortFlowType = stringToShortFlowType[input];
-    }
-  else
-    NS_FATAL_ERROR("Input for setting up short flow type has spelling issue - try again!");
-  return true;
-}
-
-bool
-SetDynamicSubflow (std::string input)
-{
-  cout << "DynamicSubflow   : " << g_dynamicSubflow << " -> " << input << endl;
-  g_dynamicSubflow = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetRcwndScale (std::string input)
-{
-  cout << "RwndScale        : " << g_rwndScale << " -> " << input << endl;
-  g_rwndScale = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetCwndMin (std::string input)
-{
-  cout << "CwndMin          : " << g_cwndMin << " -> " << input << endl;
-  g_cwndMin = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetIncastThreshold (std::string input)
-{
-  cout << "Incast Threshold : " << g_incastThreshold << " -> " << input << endl;
-  g_incastThreshold = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetReadArrivalInterval (std::string input)
-{
-  cout << "ReadArrivalInterv: " << readArrivalInterval << " -> " << input << endl;
-  readArrivalInterval = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetReadRequestFlowSize (std::string input)
-{
-  cout << "ReadRequestSize : " << readRequestFlowSize << " -> " << input << endl;
-  readRequestFlowSize = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetReadResponseFlowSize (std::string input)
-{
-  cout << "ReadResponseSize : " << readResponseFlowSize << " -> " << input << endl;
-  readResponseFlowSize = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetReadJobs (std::string input)
-{
-  cout << "ReadJobs         : " << readJobs << " -> " << input << endl;
-  readJobs = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetIncastExitThreshold (std::string input)
-{
-  cout << "IncastExitThresh : " << g_incastExitThreshold << " -> " << input << endl;
-  g_incastExitThreshold = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetLinkDelay (std::string input)
-{
-  cout << "LinkDelay        : " << g_linkDelay << " -> " << input+"us" << endl;
-  g_linkDelay = input+"us";
-  return true;
-}
-
-// Main
-int
-main(int argc, char *argv[])
-{
-  SetupStringToTM(); // Should be done before cmd parsing
-  SetupStringToST();
-  SetupStringToHSL();
-  SetupStringToSFT();
-  SetSimStartTime();
-
-  // Enable log components
-  LogComponentEnable("FatTree", LOG_ALL);
-
-  // Set up command line parameters
-  CommandLine cmd;
-  cmd.AddValue("rj", "Number of parallel Jobs ", MakeCallback(SetReadJobs));
-  cmd.AddValue("rrqs", "ReadReQuestSize  ", MakeCallback(SetReadRequestFlowSize));
-  cmd.AddValue("rrss", "ReadReSponseSize ", MakeCallback(SetReadResponseFlowSize));
-  cmd.AddValue("rai", "Read Arrival Interval ", MakeCallback(SetReadArrivalInterval));
-  cmd.AddValue("iet", "Incast Threshold ",MakeCallback(SetIncastExitThreshold));
-  cmd.AddValue("it", "Incast Threshold ", MakeCallback(SetIncastThreshold));
-  cmd.AddValue("cwndmin", "Minimum cwnd size", MakeCallback (SetCwndMin));
-  cmd.AddValue("rwndscale", "Rwnd scale factor", MakeCallback (SetRcwndScale));
-  cmd.AddValue("ds", "Dynamic Subflow ", MakeCallback(SetDynamicSubflow));
-  cmd.AddValue("sft", "Set short flow type ", MakeCallback(SetShortFlowType));
-  cmd.AddValue("sdel", " slow down ecn like", MakeCallback (SetSDEL));
-  cmd.AddValue("sdxl", " slow down xmp like", MakeCallback (SetSDXL));
-  cmd.AddValue("ratebeat", " Activate Rate Plotting", MakeCallback (SetRateBeat));
-  cmd.AddValue("rateplot", " Activate Rate Plotting", MakeCallback (SetRatePlot));
-  cmd.AddValue("sp", "Number of Switch Port", MakeCallback(SetNumPort));
-  cmd.AddValue("sf", "Number of MPTCP SubFlows", MakeCallback(SetNumSubflow));
-  cmd.AddValue("cc", "MPTCP Congestion Control algorithm", MakeCallback(SetCongestionControl));
-  cmd.AddValue("fs", "Flow Size", MakeCallback(SetFlowSize));
-  cmd.AddValue("sfs", "Short Flow Size", MakeCallback(SetShortFlowSize));
-  cmd.AddValue("st", "Simulation Time", MakeCallback(SetSimTime));
-  cmd.AddValue("lamda", "Set lamda param for poisson process", MakeCallback(SetLamda));
-  cmd.AddValue("cm", "Set traffic matrix", MakeCallback(SetTrafficMatrix));
-  cmd.AddValue("sfcm", "Set short flow traffic matrix", MakeCallback(SetSFTM));
-  cmd.AddValue("socket", "Set socket type ", MakeCallback(SetSocketType));
-  cmd.AddValue("i", "Set simulation instance number as a string", MakeCallback(SetSimInstance));
-  cmd.AddValue("cl", "Set connection limit for large flows", MakeCallback(SetConnxLimit));
-  cmd.AddValue("ratio", "Set over subscription ratio", MakeCallback(SetRatio));
-  cmd.AddValue("lr", "Set p2p link rate", MakeCallback(SetLinkRate));
-  cmd.AddValue("ld", "Set Link Delay", MakeCallback (SetLinkDelay));
-  cmd.AddValue("sim", "Set sim name", MakeCallback(SetSimName));
-  cmd.AddValue("sfsf", "Set num of subflows for shortflow", MakeCallback(SetSFSF));
-  cmd.AddValue("lfplot", "Activate plotting at MpTcpSocketBase", MakeCallback(SetLfPlot));
-  cmd.AddValue("sfplot", "Activate short flow plotting at MpTcpSocketBase", MakeCallback(SetSfPlot));
-  cmd.AddValue("rgap", "Set rando gap between subflows setup", MakeCallback(SetRandomGap));
-  cmd.AddValue("aub", "Set arrival upper bound", MakeCallback(SetArrivalUpperBound));
-  cmd.AddValue("sfdctcp", "Enable short flow to use DCTCP", MakeCallback(SetShortFlowDCTCP)); // backward compatibility
-  cmd.AddValue("lfdctcp", "Enable large flow to use DCTCP", MakeCallback(SetLargeFlowDCTCP));
-  cmd.AddValue("sfst", "Short flow start time", MakeCallback(SetSFST));
-  cmd.AddValue("sfth", "Switching point", MakeCallback(SetFlowSizeThresh));
-  cmd.AddValue("red", "Enable RED Queue Disiplone", MakeCallback(SetRED));
-  cmd.AddValue("dctcp", "Enable DCTCP Capability", MakeCallback(SetDCTCP));
-  cmd.AddValue("redmax", "RED Max Threshold", MakeCallback(SetREDmax));
-  cmd.AddValue("redmin", "RED min Threshold", MakeCallback(SetREDmin));
-  cmd.AddValue("ql", "Queue Limit (RED or DT)", MakeCallback(SetQueueLimit));
-  cmd.AddValue("redweight", "RED Weight", MakeCallback(SetREDweight));
-  cmd.AddValue("DCTCPweight", "DCTCP Weight", MakeCallback(SetDCTCPweight));
-  cmd.AddValue("qsi", "Queue Sampling Interval", MakeCallback(SetQueueSampInterval));
-  cmd.AddValue("record", "Enable DCTCP Record of Fraction and Alpha", MakeCallback(SetDctcpRecord));
-  cmd.AddValue("hm", "Enable Host Marking Capability", MakeCallback(SetHostMarking));
-  cmd.AddValue("sqt", "Enable Simple Queue Tracing", MakeCallback(SetSimpleQueueTrace));
-  cmd.AddValue("qmb", "QUEUE_MODE_BYTES", MakeCallback(SetQueueMode));
-  cmd.AddValue("dtq", "DropTailQueue Marking Threshold", MakeCallback(SetDTQ));
-  cmd.AddValue("dtqmt", "DropTailQueue Marking Threshold", MakeCallback(SetDTQMarkTh));
-  cmd.AddValue("ptraffic", "PFabric Traffic Matrices", MakeCallback(SetFabricTM));
-  cmd.AddValue("pload", "PFabric Loads", MakeCallback(SetFabricLoad));
-  cmd.AddValue("pflow", "PFabric Flow Number", MakeCallback(SetFabricFlowNum));
-  cmd.AddValue("sfltcp","Short Flow Legacy TCP", MakeCallback(SetShortFlowLegacyTcp)); // backward compatibility
-  cmd.AddValue("sfrand","Short Flow Size Uniform Random", MakeCallback(SetShortFlowSizeUniRandom));
-  cmd.AddValue("sfdist","Short Flow Size Distribution", MakeCallback(SetShortFlowSizeDist));
-  cmd.AddValue("lfcap" ," Large Flow Cap", MakeCallback(SetLargeFlowCap));
-  cmd.AddValue("readflows" ," Number of parallel flows for a incast job", MakeCallback(SetReadFlows));
-  cmd.AddValue("maxtlf" ," Maximum number of total large flows", MakeCallback(SetMaxTotalLargeFlows));
-  cmd.AddValue("gamma"," XMP's gamma", MakeCallback(SetXmpGamma));
-  cmd.AddValue("beta" ," XMP's beta",  MakeCallback(SetXmpBeta));
-
-  cmd.Parse(argc, argv);
-
-  Config::SetDefault ("ns3::MpTcpSocketBase::IncastExitThresh", UintegerValue(g_incastExitThreshold));
-  Config::SetDefault ("ns3::MpTcpSocketBase::IncastThresh", UintegerValue(g_incastThreshold));
-  Config::SetDefault ("ns3::MpTcpSocketBase::CwndMin", UintegerValue (g_cwndMin));
-  Config::SetDefault ("ns3::MpTcpSocketBase::RwndScale", UintegerValue (g_rwndScale));
-  Config::SetDefault ("ns3::MpTcpSocketBase::DynamicSubflow", BooleanValue(g_dynamicSubflow));
-  Config::SetDefault ("ns3::MpTcpSocketBase::gamma", UintegerValue(g_XmpGamma));
-  Config::SetDefault ("ns3::MpTcpSocketBase::beta", UintegerValue (g_XmpBeta));
-  Config::SetDefault ("ns3::MpTcpSocketBase::SlowDownXmpLike", BooleanValue (g_slowDownXmpLike));
-  Config::SetDefault ("ns3::MpTcpSocketBase::RatePlotSf", BooleanValue (g_enableRatePlotting));
-  Config::SetDefault ("ns3::MpTcpSocketBase::RatePlotCl", BooleanValue (g_enableRatePlotting));
-  Config::SetDefault ("ns3::MpTcpSocketBase::RateInterval", DoubleValue (g_rateBeat));
-
-  // Set up default simulation parameters
-  Config::SetDefault("ns3::Ipv4GlobalRouting::FlowEcmpRouting", BooleanValue(true));
-  Config::SetDefault("ns3::TcpSocket::SegmentSize", UintegerValue(MAXDATASIZE));
-  Config::SetDefault("ns3::TcpSocket::DelAckCount", UintegerValue(0));
-  Config::SetDefault("ns3::DropTailQueue::Mode", StringValue("QUEUE_MODE_PACKETS"));
-  Config::SetDefault("ns3::DropTailQueue::MaxPackets", UintegerValue(g_queueLimit));
-  if (g_queueModeBytes)
-    {
-      Config::SetDefault("ns3::DropTailQueue::Mode", StringValue("QUEUE_MODE_BYTES"));
-      Config::SetDefault("ns3::DropTailQueue::MaxBytes", UintegerValue(g_queueLimit * MAXDATASIZE));
-    }
-  Config::SetDefault("ns3::MpTcpSocketBase::LargePlotting", BooleanValue(g_enableLfPlotting));
-  Config::SetDefault("ns3::MpTcpSocketBase::ShortPlotting", BooleanValue(g_enableSfPlotting));
-  Config::SetDefault("ns3::MpTcpSocketBase::RandomGap", UintegerValue(g_rGap));
-  Config::SetDefault("ns3::Ipv4GlobalRouting::RespondToInterfaceEvents", BooleanValue (true));
-  if (g_trafficMatrix >= INCAST_DIST)
-    { // Goodput of LFs should be calculated when all outstanding data has been acked!
-      Config::SetDefault ("ns3::MpTcpSocketBase::BackgroundFlow", BooleanValue (false));
-    }
-  if (g_dctcpFastReTxRecord)
-    { // Danger - check this carefully for normal run
-      Config::SetDefault("ns3::MpTcpSocketBase::DctcpFastReTxRecord", BooleanValue(g_dctcpFastReTxRecord));
-      Config::SetDefault("ns3::RedQueue::UseCurrent", BooleanValue(true));
-    }
-  if (g_enableDCTCP)
-    {
-      Config::SetDefault("ns3::MpTcpSocketBase::DCTCP", BooleanValue(g_enableDCTCP)); //Sink Control
-      Config::SetDefault("ns3::MpTcpBulkSendApplication::DCTCP", BooleanValue(g_enableDCTCP));// Source Control
-      Config::SetDefault("ns3::MpTcpSocketBase::DCTCPWeight", DoubleValue(g_DCTCPWeight));
-      Config::SetDefault("ns3::RedQueue::UseCurrent", BooleanValue(true));
-    }
-  if (g_enableRED)
-    {
-      Config::SetDefault("ns3::RedQueue::Mode", StringValue("QUEUE_MODE_PACKETS"));
-      Config::SetDefault("ns3::RedQueue::QueueLimit", UintegerValue(g_queueLimit));
-      Config::SetDefault("ns3::RedQueue::MeanPktSize", UintegerValue(MAXDATASIZE));
-      Config::SetDefault("ns3::RedQueue::Wait", BooleanValue(true));
-      Config::SetDefault("ns3::RedQueue::Gentle", BooleanValue(false));
-      Config::SetDefault("ns3::RedQueue::QW", DoubleValue(g_REDWeight));
-      Config::SetDefault("ns3::RedQueue::MinTh", DoubleValue(g_REDminTh));
-      Config::SetDefault("ns3::RedQueue::MaxTh", DoubleValue(g_REDmaxTh));
-      Config::SetDefault("ns3::RedQueue::UseCurrent", BooleanValue(true));
-      if (g_queueModeBytes)
-        {
-          Config::SetDefault("ns3::RedQueue::Mode", StringValue("QUEUE_MODE_BYTES"));
-          Config::SetDefault("ns3::RedQueue::QueueLimit", UintegerValue(g_queueLimit * MAXDATASIZE));
-          Config::SetDefault("ns3::RedQueue::MinTh", DoubleValue(g_REDminTh * MAXDATASIZE));
-          Config::SetDefault("ns3::RedQueue::MaxTh", DoubleValue(g_REDmaxTh * MAXDATASIZE));
-        }
-    }
-  if (g_enableDTQmark)
-    {
-      Config::SetDefault ("ns3::DropTailQueue::Marking", BooleanValue (g_enableDTQmark));
-      Config::SetDefault ("ns3::DropTailQueue::MarkingTh", UintegerValue (g_DTQmarkTh));
-      if (g_queueModeBytes)
-        {
-          Config::SetDefault ("ns3::DropTailQueue::MarkingTh", UintegerValue (g_DTQmarkTh * MAXDATASIZE));
-        }
-    }
-  if (g_cc == "XMP")
-    {
-      assert(g_enableDCTCP == false);
-    }
-
-  switch (g_socketType)
-    {
-  case MPTCP:
-    Config::SetDefault("ns3::TcpL4Protocol::SocketType", TypeIdValue(MpTcpSocketBase::GetTypeId()));
-    Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue(g_cc));
-    Config::SetDefault("ns3::MpTcpBulkSendApplication::CongestionControl", StringValue(g_cc));
-    Config::SetDefault("ns3::MpTcpSocketBase::MaxSubflows", UintegerValue(g_subflows)); // Sink
-    Config::SetDefault("ns3::MpTcpBulkSendApplication::MaxSubflows", UintegerValue((uint8_t)g_subflows));//Source
-    Config::SetDefault("ns3::MpTcpSocketBase::PathManagement", StringValue("NdiffPorts"));
-    break;
-  case TCP:
-    g_subflows = 1; // For TCP, this should be one!
-    g_shortFlowSubflows = 1;
-    Config::SetDefault("ns3::TcpL4Protocol::SocketType", TypeIdValue(MpTcpSocketBase::GetTypeId()));
-    Config::SetDefault("ns3::MpTcpSocketBase::MaxSubflows", UintegerValue(g_subflows)); // For the sink
-    Config::SetDefault("ns3::MpTcpBulkSendApplication::MaxSubflows", UintegerValue(g_subflows)); // TCP need one subflow only
-    Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue("Uncoupled_TCPs"));
-    Config::SetDefault("ns3::MpTcpBulkSendApplication::CongestionControl", StringValue("Uncoupled_TCPs"));
-    Config::SetDefault("ns3::MpTcpSocketBase::PathManagement", StringValue("Default"));
-    break;
-  default:
-    break;
-    }
-
-  g_seed = static_cast<uint32_t>(atoi(g_simInstance.c_str()));
-//RngSeedManager::SetSeed(1); // default is 1
-  RngSeedManager::SetRun(g_seed);
-  cout << "Seed             : " << g_seed << endl;
-  srand(g_seed);
-  cout << "ns3:Seed(" << RngSeedManager::GetSeed () << ") ns3:Run(" << RngSeedManager::GetRun () << ")" << endl;
-
-  GetCDFData (pTraffic);   // populate CDF table
-
-  // SimResult
-  SimResultHeaderGenerator();
-
-  // Initialise animation parameter
-  double xLoc = 0.0;
-  double yLoc = 0.0;
-  
-  cout << endl;
-  cout << "switchPorts      :  " << g_K << endl;
-  cout << "totalCores       :  " << g_totalCore << endl;
-  cout << "totalAggrs       :  " << g_totalAggr << endl;
-  cout << "totalToRs        :  " << g_totalToR << endl;
-  cout << "totalHosts       :  " << g_totalHost << endl;
-
-  PrintSimParams();
-  InternetStackHelper internet;
-// ------------------ Topology Construction ------------------
-  NodeContainer allHosts;
-
-  // Host Layer Nodes
-  for (uint32_t i = 0; i < g_numPod; i++)
-    {
-      for (uint32_t j = 0; j < g_numToR; j++)
-        { // host[g_numPod][g_numToR]
-          host[i][j].Create(g_numHost); // 20 hosts per each ToR switch
-          internet.Install(host[i][j]);
-          allHosts.Add(host[i][j]);     // Add all server to GlobalHostContainer
-          Host_c.Add(host[i][j]);       // Add all server to Host_c for link utilisation
-        }
-    }
-
-  InitHostArray(Host_c);
-
-  // Access layer Nodes
-  NodeContainer tor[g_numPod];          // NodeContainer for ToR switches
-  for (uint32_t i = 0; i < g_numPod; i++)
-    {
-      tor[i].Create(g_numToR);
-      internet.Install(tor[i]);
-      Tor_c.Add(tor[i]);
-    }
-  // Aggregation layer Nodes
-  NodeContainer aggr[g_numPod];         // NodeContainer for aggregation switches
-  for (uint32_t i = 0; i < g_numPod; i++)
-    {
-      aggr[i].Create(g_numAggr);
-      internet.Install(aggr[i]);
-      Aggr_c.Add(aggr[i]);
-    }
-  // Core Layer Nodes
-  NodeContainer core[g_numGroup];       // NodeContainer for core switches
-  for (uint32_t i = 0; i < g_numGroup; i++)
-    {
-      core[i].Create(g_numCore);
-      internet.Install(core[i]);
-      core_c.Add(core[i]);
-    }
-
-// -----------------------------------------------------------
-  AddNameToHosts();
-//------------------------------------------------------------
-// Allocate location to nodes
-  double Dist = 200;
-
-  // CORE SETUP
-  double interval = Dist / ((g_numCore * g_numGroup) + 1);
-  for (uint32_t g = 0; g < g_numGroup; g++)
-    {
-      for (uint32_t c = 0; c < g_numCore; c++)
-        {
-          Ptr<Node> node = core[g].Get(c);
-          Ptr<ConstantPositionMobilityModel> loc = node->GetObject<ConstantPositionMobilityModel>();
-          if (loc == 0)
-            {
-              loc = CreateObject<ConstantPositionMobilityModel>();
-              node->AggregateObject(loc);
-            }
-          xLoc += interval;
-          yLoc = 5;
-          Vector locVec(xLoc, yLoc, 0);
-          loc->SetPosition(locVec);
-        }
-    }
-
-  // AGGR SETUP
-  interval = (Dist / g_numPod) / (g_numAggr + 1);
-  xLoc = interval;
-  for (uint32_t p = 0; p < g_numPod; p++)
-    {
-      xLoc = p * (Dist / g_numPod);
-      for (uint32_t a = 0; a < g_numAggr; a++)
-        {
-          Ptr<Node> node = aggr[p].Get(a);
-          Ptr<ConstantPositionMobilityModel> loc = node->GetObject<ConstantPositionMobilityModel>();
-          if (loc == 0)
-            {
-              loc = CreateObject<ConstantPositionMobilityModel>();
-              node->AggregateObject(loc);
-            }
-          xLoc += interval;
-          yLoc = 38;
-          Vector locVec(xLoc, yLoc, 0);
-          loc->SetPosition(locVec);
-        }
-    }
-
-  // TOR SETUP
-  interval = (Dist / g_numPod) / (g_numToR + 1);
-  xLoc = interval;
-  for (uint32_t p = 0; p < g_numPod; p++)
-    {
-      xLoc = p * (Dist / g_numPod);
-      for (uint32_t t = 0; t < g_numToR; t++)
-        {
-          Ptr<Node> node = tor[p].Get(t);
-          Ptr<ConstantPositionMobilityModel> loc = node->GetObject<ConstantPositionMobilityModel>();
-          if (loc == 0)
-            {
-              loc = CreateObject<ConstantPositionMobilityModel>();
-              node->AggregateObject(loc);
-            }
-          xLoc += interval;
-          yLoc = 50;
-          Vector locVec(xLoc, yLoc, 0);
-          loc->SetPosition(locVec);
-        }
-    }
-
-  // HOSTS SETUP
-  interval = (Dist / g_numPod) / ((2 * g_numToR) + 1);
-  yLoc = 60;
-  for (uint32_t p = 0; p < g_numPod; p++)
-    {
-      xLoc = p * (Dist / g_numPod);
-      yLoc = 60;
-      for (uint32_t t = 0; t < g_numToR; t++)
-        {
-          xLoc += interval;
-          yLoc = 60;
-          double xTmpToR = xLoc;
-          for (uint32_t h = 0; h < g_numHost; h++)
-            {
-              Ptr<Node> node = host[p][t].Get(h);
-              Ptr<ConstantPositionMobilityModel> loc = node->GetObject<ConstantPositionMobilityModel>();
-              if (loc == 0)
-                {
-                  loc = CreateObject<ConstantPositionMobilityModel>();
-                  node->AggregateObject(loc);
-                }
-              if (h % 2 == 0)
-                {
-                  xLoc = xTmpToR;
-                  yLoc += 4;
-                }
-              else
-                xLoc += interval;
-              Vector locVec(xLoc, yLoc, 0);
-              loc->SetPosition(locVec);
-            }
-        }
-    }
-
-  PointToPointHelper p2p;
-  p2p.SetQueue("ns3::DropTailQueue");
-  p2p.SetDeviceAttribute("DataRate", StringValue(g_linkCapacity));
-  p2p.SetChannelAttribute("Delay", StringValue(g_linkDelay));
-
-  if (g_enableRED)
-    {
-      p2p.SetQueue ("ns3::RedQueue", "LinkBandwidth",
-                    StringValue (g_linkCapacity), "LinkDelay",
-                    StringValue (g_linkDelay));
-      p2p.SetDeviceAttribute ("DataRate", StringValue (g_linkCapacity));
-      p2p.SetChannelAttribute ("Delay", StringValue (g_linkDelay));
-  }
-
-  // Initialise address helper
-  Ipv4AddressHelper ipv4Address;
-
-//=========== Connect hosts to ToRs ===========//
-  NetDeviceContainer hostToTorNetDevice[g_numPod][g_numToR][g_numHost];
-//Ipv4InterfaceContainer ipContainer[g_numPod][g_numToR][g_numHost];
-  stringstream ss;
-  for (uint32_t p = 0; p < g_numPod; p++)
-    {
-      for (uint32_t t = 0; t < g_numToR; t++)
-        {
-          ss.str ("");
-          ss << "10." << p << "." << t << "." << "0";
-          string tmp = ss.str ();
-          const char* address = tmp.c_str ();
-          ipv4Address.SetBase (address, "255.255.255.252");
-          for (uint32_t h = 0; h < g_numHost; h++)
-            {
-              hostToTorNetDevice[p][t][h] = p2p.Install (NodeContainer (host[p][t].Get (h), tor[p].Get (t)));
-              ipv4Address.Assign (hostToTorNetDevice[p][t][h]);
-              ipv4Address.NewNetwork ();
-            }
-        }
-    }NS_LOG_INFO("Finished connecting tor switches and hosts");
-//=========== Connect aggregate switches to edge switches ===========//
-  if (g_enableRED)
-    {
-      p2p.SetQueue ("ns3::RedQueue", "LinkBandwidth",
-                    StringValue (g_linkCapacity), "LinkDelay",
-                    StringValue (g_linkDelay));
-      p2p.SetDeviceAttribute ("DataRate", StringValue (g_linkCapacity));
-      p2p.SetChannelAttribute ("Delay", StringValue (g_linkDelay));
-    }
-  NetDeviceContainer ae[g_numPod][g_numAggr][g_numToR];
-//Ipv4InterfaceContainer ipAeContainer[g_numPod][g_numAggr][g_numToR];
-  ipv4Address.SetBase("20.20.0.0", "255.255.255.0");
-  for (uint32_t p = 0; p < g_numPod; p++)
-    {
-      for (uint32_t a = 0; a < g_numAggr; a++) // number of aggr switch per pod
-        {
-          for (uint32_t t = 0; t < g_numToR; t++)
-            {
-              ae[p][a][t] = p2p.Install(aggr[p].Get(a), tor[p].Get(t));
-
-              ipv4Address.Assign(ae[p][a][t]);
-              ipv4Address.NewNetwork();
-            }
-        }
-    }NS_LOG_INFO("Finished connecting tor switches and aggregation");
-
-//=========== Connect core switches to aggregate switches ===========//
-  if (g_enableRED)
-    {
-      p2p.SetQueue ("ns3::RedQueue", "LinkBandwidth",
-                    StringValue (g_linkCapacity), "LinkDelay",
-                    StringValue (g_linkDelay));
-      p2p.SetDeviceAttribute ("DataRate", StringValue (g_linkCapacity));
-      p2p.SetChannelAttribute ("Delay", StringValue (g_linkDelay));
-    }
-  NetDeviceContainer ca[g_numGroup][g_numCore][g_numPod];
-  ipv4Address.SetBase("30.30.0.0", "255.255.255.0");
-  for (uint32_t g = 0; g < g_numGroup; g++)
-    {
-      for (uint32_t c = 0; c < g_numCore; c++)
-        {
-          for (uint32_t p = 0; p < g_numPod; p++)
-            {
-              ca[g][c][p] = p2p.Install(core[g].Get(c), aggr[p].Get(g));
-              ipv4Address.Assign(ca[g][c][p]);
-              ipv4Address.NewNetwork();
-            }
-        }
-    }NS_LOG_INFO("Finished connecting core and aggregation");
-
-// Populate Global Routing
-  Ipv4GlobalRoutingHelper::PopulateRoutingTables();
-
-  if (g_trafficMatrix < INCAST_DIST)
-    SetupTraces (Core_Aggr_Tor_Host);
-  else if (g_trafficMatrix == INCAST_DIST)
-    SetupTracesNew (Core_Aggr_Tor_Host);
-  else
-    {
-      cout << "TrafficMatrix is " << GetKeyFromValueTM (g_trafficMatrix) << " NO TRACING" << endl;
-    }
-
-  if (g_enableDCTCP && !g_enabledHostMarking)
-    SetupHostQueues();
-
-  if (g_simpleQueueTrace && (g_trafficMatrix == INCAST_DIST))
-    SimpleQueueTraces(Tor);
-  else if (g_simpleQueueTrace)
-    SimpleQueueTraces(Core_Aggr_Tor_Host);
-
-//=========== Initialise settings for On/Off Application ===========//
-  // sink application - It would closed doubled the time of source closure!
-  cout << "\nSink App Install on following nodes: " << endl;
-  for (uint32_t i = 0; i < allHosts.GetN(); i++)
-    {
-      MpTcpPacketSinkHelper sink("ns3::TcpSocketFactory",
-          InetSocketAddress(Ipv4Address::GetAny(), (allHosts.Get(i)->GetId() + 1)));
-      ApplicationContainer tmp = sink.Install(allHosts.Get(i));
-      tmp.Start(Seconds(0.0));
-    //tmp.Stop(Seconds(g_simTime + 20)); // This works for pFabric, INCAST_DIST and other TMs
-      sinkApps.push_back(tmp);
-      cout << allHosts.Get(i)->GetId() << " ";
-    }
-  cout << "\n" <<endl;
-
-  ConnectionMatrix* conns = new ConnectionMatrix((int) g_totalHost);
-
-  switch (g_trafficMatrix)
-    {
-  case PERMUTATION:
-    conns->setPermutation();
-    break;
-  case STRIDE:
-    conns->setStride(g_numToR * g_numHost);
-    break;
-  case RANDOM:
-    conns->setRandomConnection(g_totalHost);
-    break;
-  case INCAST_STRIDE:
-    conns->setStride (g_numToR * g_numHost);
-    break;
-  case SHORT_FLOW:
-    if (g_shortFlowTM == PERMUTATION)
-      conns->setPermutation();
-    else if (g_shortFlowTM == STRIDE)
-      conns->setStride(g_numToR * g_numHost);
-    else if (g_shortFlowTM == RANDOM)
-      conns->setRandomConnection(g_totalHost);
-    break;
-  default:
-    break;
-    }
-
-  // Large flows SOURCE applications - They would be closed by g_simTime
-  vector<connection*>* CM = conns->getAllConnections();
-  uint32_t totalLargeConnx;
-  vector<int> tmpVec;
-  int pos;
-  vector<connection*>* shortCM;// = GetShortCM(CM);
-  //
-  if (g_trafficMatrix == P_FABRIC)
-    {
-      IssuePFabric(allHosts);
-    }
-  else if (g_trafficMatrix == P_PERMUTATION)
-    {
-      IssuePermutation (allHosts);
-    }
-  else if (g_trafficMatrix == INCAST_DIST)
-    {
-      for (uint32_t i = 0; i < readJobs; i++)
-        {
-          IssueDistributedRead ();
-        }
-      for (uint32_t i = 0; i < hostArray.size (); i++)
-        {
-          IssueNotInnerRackFlows (hostArray[i]);
-        }
-    }
-  else if (g_trafficMatrix == RANDOM_DIST)
-    {
-      for (uint32_t i = 0; i < hostArray.size (); i++)
-        {
-          IssueLargeFlows (hostArray[i], 0, 1.0);
-        }
-    }
-  else if (g_trafficMatrix == PERMUTATION_DIST)
-    {
-      PermutationTraffic ();
-    }
-  else
-    {// opening big else
-  //
-  if (g_trafficMatrix == SHORT_FLOW)
-    {
-      totalLargeConnx = static_cast<uint32_t> ((CM->size () * g_connxLimit) / 100);
-      cout << "\nCMSize: " << (int) CM->size () << " LargeFlowCM: " << totalLargeConnx << " => " << g_connxLimit << "% of total flows" << endl;
-    }
-  else // Other TM (PERMUTATION, STRIDE, RANDOM); all for large flows
-    {
-      totalLargeConnx = CM->size ();
-      cout << "CMSize: " << (int) CM->size () << " LargeFlowCM: " << totalLargeConnx << " 100% of total flows" << endl;
-    }
-  //
-  for (uint32_t i = 0; i < totalLargeConnx; i++)
-    {
-      do
-        {
-          pos = rand () % CM->size ();
-        }
-      while (find (tmpVec.begin (), tmpVec.end (), pos) != tmpVec.end ());
-      tmpVec.push_back (pos);
-      connection* connection = (*CM).at (pos);
-      int src = connection->src;
-      int dst = connection->dst;
-      connection->large = true;
-      //
-      Ptr<Node> srcNode = allHosts.Get (src);
-      Ptr<Ipv4> ipv4Client = srcNode->GetObject<Ipv4> ();
-      Ipv4InterfaceAddress iaddrClient = ipv4Client->GetAddress (1, 0);
-      Ipv4Address ipv4AddrClient = iaddrClient.GetLocal ();
-      //
-      Ptr<Node> randomServerNode = allHosts.Get (dst);
-      uint32_t flowId = allHosts.Get (src)->GetNApplications ();
-      Ptr<Ipv4> ipv4Server = randomServerNode->GetObject<Ipv4> ();
-      Ipv4InterfaceAddress iaddrServer = ipv4Server->GetAddress (1, 0);
-      Ipv4Address ipv4AddrServer = iaddrServer.GetLocal ();
-
-      MpTcpBulkSendHelper source ("ns3::TcpSocketFactory", InetSocketAddress (Ipv4Address (ipv4AddrServer), randomServerNode->GetId () + 1));
-      source.SetAttribute ("MaxBytes", UintegerValue (g_flowSize));
-      source.SetAttribute ("FlowId", UintegerValue (flowId));
-      //source.SetAttribute("MaxSubflows", UintegerValue(8)); // TCP would not work if it is uncommented
-
-      string socketModelTmp = GetSocketModel ();
-      source.SetAttribute ("SocketModel", StringValue (socketModelTmp));
-
-      int _maxsub = g_subflows;    // Just for debugging purpose
-      int _dctcp = g_enableDCTCP;  // Just for debugging purpose
-
-      // For applicable to long flows
-      if (g_slowDownEcnLike)
-        {
-        }
-      source.SetAttribute ("FlowType", StringValue ("Large"));
-      string flowLayer = GetFlowLayer (ipv4AddrClient, ipv4AddrServer);
-      source.SetAttribute ("FlowLayer", StringValue (flowLayer));
-      source.SetAttribute ("OutputFileName", StringValue (SetupSimFileName ("RESULT")));
-      source.SetAttribute ("OutputFileNameDctcp", StringValue (SetupSimFileName ("DCTCP")));
-      cmAnalisys (LARGE, ipv4AddrClient, ipv4AddrServer);
-      sourceLargeFlowApps.push_back (source.Install (allHosts.Get (src)));
-
-      cout << "LargeFlowCM(" << i + 1 << ") " << allHosts.Get (src)->GetId () << " -> " << randomServerNode->GetId ()
-           << " Subflows: " << _maxsub << " DCTCP: " << isActive (_dctcp) << " FLowLayer: "
-           << flowLayer << " SocketModel[" << socketModelTmp << "]" << endl;
-    }
-  cout << "\nLarge Flow Source App Installs on following nodes: " << endl;
-  for (uint32_t i = 0; i < sourceLargeFlowApps.size (); i++)
-    {
-      Ptr<MpTcpBulkSendApplication> mptcpBulk = DynamicCast<MpTcpBulkSendApplication> (sourceLargeFlowApps[i].Get (0));
-      cout << mptcpBulk->GetNode ()->GetId () << " ";
-      sourceLargeFlowApps[i].Start (Seconds (0.0));
-      sourceLargeFlowApps[i].Stop (Seconds (g_simTime));
-    }
-  cout << "\n" << endl;
-
-  if (g_trafficMatrix == INCAST_STRIDE)
-    {
-      for (uint32_t i = 0; i < readJobs; i++)
-        {
-          IssueDistributedRead ();
-        }
-    }
-//  vector<connection*>* shortCM = GetShortCM(CM); // Move it up
-  shortCM = GetShortCM(CM);
-  if (g_trafficMatrix == SHORT_FLOW)
-    {
-      Simulator::Schedule (Seconds (g_shortFlowStartTime), &ShortFlowConfig, shortCM, allHosts);
-    }
-  } // closing big else
-
-  SimTimeMonitor();
-
-  PrintCMStat();
-
-  NS_LOG_INFO ("Run Simulation.");
-
-  if (g_trafficMatrix < INCAST_DIST)
-    {
-      Simulator::Stop (Seconds (g_simTime + 40));
-    }
-
-  Simulator::Run();
-
-  if (g_trafficMatrix < INCAST_DIST)
-    {
-      cout << Simulator::Now().GetSeconds() << " -> Generate Out puts"<< endl;
-      OutPutCMStat();
-      OutPutCore();
-      OutPutAggr();
-      OutPutTor();
-      OutPutHost();
-    }
-  SimOverallResultWritter();
-  SimResultFooterGenerator(); // OveralResultWritter should be called first!
-
-  Simulator::Destroy();
-  cout << Simulator::Now().GetSeconds() << " END "<< endl;
-  NS_LOG_INFO ("Done.");
-  return 0;
-}
diff --git a/scratch/empirical-workload-asym.cc b/scratch/empirical-workload-asym.cc
new file mode 100644
index 0000000..5b6caa4
--- /dev/null
+++ b/scratch/empirical-workload-asym.cc
@@ -0,0 +1,789 @@
+/*
+ * Author: Enhuan Dong -A pathetic PhD student.- <deh13@mails.tsinghua.edu.cn>
+ */
+#include <ctime>
+#include <sys/time.h>
+#include <stdint.h>
+#include <fstream>
+#include <string>
+#include <cassert>
+#include <iostream>
+#include <iomanip>
+#include <cfloat>
+#include "ns3/log.h"
+#include "ns3/core-module.h"
+#include "ns3/network-module.h"
+#include "ns3/applications-module.h"
+#include "ns3/point-to-point-module.h"
+#include "ns3/internet-module.h"
+#include "ns3/netanim-module.h"
+#include "ns3/mobility-module.h"
+#include "ns3/callback.h"
+#include "ns3/string.h"
+
+using namespace ns3;
+NS_LOG_COMPONENT_DEFINE("Empirical-Workload");
+
+typedef enum
+{
+  Spine, Leaf, Host, Spine_Leaf, Spine_Leaf_Host
+} Layers_t;
+
+typedef enum
+{
+  NONE, NEW_INCAST, TYPICAL_INCAST, NEW_INCAST_BK, ONE_MAP_ONE
+} TrafficMatrix_t;
+
+typedef enum
+{
+  TCP, MPTCP
+} SocketType_t;
+
+
+std::map<string, TrafficMatrix_t> stringToTrafficMatrix;
+std::map<string, SocketType_t> stringToSocketType;
+
+#define PORT 5000
+
+// Setup general parameters
+string g_topology = "Leaf-Spine-8x8";
+string g_simName  = "MPTCP_Incast";
+string g_workload = "datamining.txt";
+double g_load = 0.5;
+
+
+// Setup topology parameters
+string g_downLinkCapacity = "10Gbps";
+double g_accessLinkCapacity = 10000000000;
+string g_upLinkCapacity = "40Gbps";  //Normal
+string g_linkDelay = "25us";       
+
+uint32_t g_numSpine = 8;
+uint32_t g_numLeaf = 8;
+uint32_t g_numHost = 64;
+
+double g_simTime = 1.0;             // 1 Seconds (default)
+uint32_t g_seed = 0;                // RNG seed
+SocketType_t g_socketType = MPTCP;
+
+string g_simInstance = "0";
+string g_simStartTime = "NULL";
+uint32_t g_minRTO = 200;
+
+uint32_t g_rGap = 50;
+// Setup MPTCP parameters
+string g_cc = "RTT_Compensator"; // Uncoupled_TCPs, Linked_Increases, Fully_Coupled, RTT_Compensator
+uint32_t g_subflows = 8;
+uint32_t g_initialCWND = 10;
+uint32_t g_slaveIW = 1;
+uint32_t g_oppo = 1;
+bool g_enableDCTCP = true;
+
+// For dctcp only
+double g_downLinkREDmaxTh = 65;
+double g_downLinkREDminTh = 65;
+ 
+uint32_t g_downLinkREDQueueLimit = 350;   
+
+ // Normal
+double g_upLinkREDmaxTh = 150;
+double g_upLinkREDminTh = 150;
+uint32_t g_upLinkREDQueueLimit = 1400;   
+
+uint32_t g_segmentSize = 1400;
+uint32_t g_REDMeanPktSize = g_segmentSize;
+
+
+// NodeContainer to use for link utilization and loss rate
+NodeContainer spine_c;
+NodeContainer leaf_c;
+NodeContainer host_c;
+
+class FlowInfo
+{
+public:
+  FlowInfo (double startTime, uint32_t sender, uint32_t receiver, uint32_t flowSize)
+  {
+    m_startTime = startTime;
+    m_sender = sender;
+    m_receiver = receiver;
+    m_flowSize = flowSize;
+  }
+  double m_startTime;
+  uint32_t m_sender;
+  uint32_t m_receiver;
+  uint32_t m_flowSize;
+};
+
+vector<FlowInfo> g_vecFlowInfo;
+
+
+void SimHeaderWritter(Ptr<OutputStreamWrapper> stream);
+void SimFooterWritter(Ptr<OutputStreamWrapper> stream);
+
+uint64_t
+GetLinkRate(string linkRate)
+{
+  DataRate tmp(linkRate);
+  return tmp.GetBitRate();
+}
+
+void
+SetupStringToST()
+{
+  stringToSocketType["TCP"] = TCP;
+  stringToSocketType["MPTCP"] = MPTCP;
+}
+
+
+string
+GetKeyFromValueST(SocketType_t st)
+{
+  map<string, SocketType_t>::const_iterator it = stringToSocketType.begin();
+  for (; it != stringToSocketType.end(); it++)
+    {
+      if (it->second == st)
+        return it->first;
+    }
+  return "";
+}
+
+string
+SetupSimFileName(string input)
+{
+  ostringstream oss;
+  oss.str("");
+  oss << g_simName << "_" << g_topology  <<  "_MPTCP_Empirical" << "_" << input << "_" << g_simInstance
+      << ".data";
+  string tmp = oss.str();
+  oss.str("");
+  return tmp;
+}
+
+
+void
+PrintSimParams()
+{
+  cout << endl;
+  cout << "Socket Type      : " << GetKeyFromValueST(g_socketType).c_str() << endl;
+  cout << "Seed             : " << g_seed << endl;
+  cout << "Instance         : " << g_simInstance << endl;
+  cout << "DCTCP            : " << g_enableDCTCP << endl;
+  cout << "CC               : " << g_cc << endl;
+}
+
+
+
+Ptr<Queue>
+FindQueue(Ptr<NetDevice> dev)
+{
+  PointerValue ptr;
+  dev->GetAttribute("TxQueue", ptr);
+  return ptr.Get<Queue>();
+}
+
+string
+GetDateTimeNow()
+{
+  time_t T = time(0);
+  struct tm* now = localtime(&T);
+  string simStartDate = asctime(now);
+  return simStartDate.substr(0, 24);
+}
+
+void
+SetSimStartTime()
+{
+  g_simStartTime = GetDateTimeNow();
+}
+
+string
+GetSimStartTime()
+{
+  return g_simStartTime;
+}
+
+void
+SimHeaderWritter(Ptr<OutputStreamWrapper> stream)
+{
+  ostream *os = stream->GetStream ();
+  *os << "SimStart [" << g_simStartTime << "] simName[" << g_simName
+      << "] Topology[" << g_topology 
+      << "] SocketType[" << GetKeyFromValueST (g_socketType) 
+      << "] Seed[" << g_seed << "] simInstance["
+      << g_simInstance << "] SimPeriod[" << g_simTime
+      << "s] HostPerLeaf[" << g_numHost << "] CC[" << g_cc << "] dctcp[" << g_enableDCTCP
+      <<"] SubflowNum[" <<g_subflows
+      << "] upLinkRate["<< g_upLinkCapacity << "] downLinkRate["<< g_downLinkCapacity << "] LinkDelay[" << g_linkDelay
+      << "] RTOmin[ " << g_minRTO << "]" << endl;
+}
+
+void
+SimFooterWritter(Ptr<OutputStreamWrapper> stream)
+{
+  ostream *os = stream->GetStream();
+  *os << "SimEnd [" << GetDateTimeNow() 
+      << endl;
+}
+
+void
+SimResultHeaderGenerator()
+{
+  Ptr<OutputStreamWrapper> streamSimParam = Create<OutputStreamWrapper>(SetupSimFileName("RESULT"),
+      std::ios::out | std::ios::app);
+  SimHeaderWritter(streamSimParam);
+}
+
+void
+SimResultFooterGenerator()
+{
+  Ptr<OutputStreamWrapper> streamSimParam = Create<OutputStreamWrapper>(SetupSimFileName("RESULT"),
+      std::ios::out | std::ios::app);
+  SimFooterWritter(streamSimParam);
+}
+
+bool
+SetNumSubflow(std::string input)
+{
+  cout << "Subflows         : " << g_subflows << " -> " << input << endl;
+  g_subflows = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetCongestionControl(std::string input)
+{
+  cout << "CongestionControl: " << g_cc << " -> " << input << endl;
+  g_cc = input;
+  return true;
+}
+
+
+bool
+SetSimTime(std::string input)
+{
+  cout << "SimDuration      : " << g_simTime << " -> " << input << endl;
+  g_simTime = atof(input.c_str());
+  return true;
+}
+
+
+bool
+SetSocketType(std::string input)
+{
+  cout << "SocketType       : " << GetKeyFromValueST(g_socketType) << " -> " << input << endl;
+  if (stringToSocketType.count(input) != 0)
+    {
+      g_socketType = stringToSocketType[input];
+    }
+  else
+    NS_FATAL_ERROR("Input for setting up socket type has spelling issue - try again!");
+  return true;
+}
+
+bool
+SetSimInstance(std::string input)
+{
+  cout << "SimInstance      : " << g_simInstance << " -> " << input << endl;
+  g_simInstance = input;
+  return true;
+}
+
+bool
+SetRTO(std::string input)
+{
+  cout << "RTO              : " << g_minRTO << " -> " << input << endl;
+  g_minRTO = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetSimName(std::string input)
+{
+  cout << "SimName          : " << g_simName << " -> " << input << endl;
+  g_simName = input;
+  return true;
+}
+
+bool
+SetWorkLoad(std::string input)
+{
+  cout << "Workload          : " << g_workload << " -> " << input << endl;
+  g_workload = input;
+  return true;
+}
+
+bool
+SetLoad(std::string input)
+{
+  cout << "Load          : " << g_load << " -> " << input << endl;
+  g_load = atof(input.c_str());
+  return true;
+}
+
+bool
+SetIW(std::string input)
+{
+  cout << "InitalCWND       : " << g_initialCWND << " -> " << input << endl;
+  g_initialCWND = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetSlaveIW(std::string input)
+{
+  cout << "InitalSlaveCWND       : " << g_slaveIW << " -> " << input << endl;
+  g_slaveIW = atoi(input.c_str());
+  return true;
+}
+
+
+bool
+SetOppo(std::string input)
+{
+  cout << "UseOppo       : " << g_oppo << " -> " << input << endl;
+  g_oppo = atoi(input.c_str());
+  return true;
+}
+
+
+bool
+SetHostNumber(std::string input){
+  cout << "Host Number    : " << g_numHost << " -> " << input << endl;
+  g_numHost = atoi(input.c_str());
+  return true;
+}
+
+
+void printNodeAddr(Ptr<Node> tmp)
+{
+  Ptr<Ipv4> ipv4Src = tmp->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+  Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+  ipv4AddressSrc.Print(cout);
+  cout << endl;
+}
+
+
+bool
+SetDCTCP (std::string input)
+{
+  cout << "Enable DCTCP     : " << g_enableDCTCP << " -> " << input << endl;
+  g_enableDCTCP = atoi (input.c_str ());
+  return true;
+}
+
+
+void
+ConfigSingleFlow (Ptr<Node> srcNode, Ptr<Node> dstNode, double startTime, uint32_t flowSize)
+{
+  Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+  Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+  cout << "DST:";
+  ipv4AddressDst.Print(cout);
+  cout << endl;
+
+  Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+  Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+  cout << "SRC:";
+  ipv4AddressSrc.Print(cout);
+  cout << endl;
+
+  // Assign flowId
+  int flowId = srcNode->GetNApplications();
+
+  // Source
+  MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+  source.SetAttribute("MaxBytes", UintegerValue(flowSize * 1024));
+  source.SetAttribute("FlowId", UintegerValue(flowId));
+  //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+  source.SetAttribute("FlowType", StringValue("Short"));
+  string tempString = SetupSimFileName("RESULT");
+  source.SetAttribute("OutputFileName", StringValue(tempString));
+
+  ApplicationContainer sourceApps = source.Install(srcNode);
+  sourceApps.Start (Seconds(startTime));
+  sourceApps.Stop (Seconds(g_simTime));
+}
+
+class WorkLoad
+{
+public:
+  
+  WorkLoad(string file)
+  {
+    string realFileName = "/home/nick/8T/dcmptcp/tpds-sim/dcmptcp-real/workloads/"+file;
+    ifstream infile(realFileName.c_str());
+    
+    double cdf = 0.0;
+    double flowSize = 0.0;
+    while (infile >> cdf >> flowSize)
+    {
+      vector<double> tmp;
+      tmp.push_back(cdf);
+      tmp.push_back(flowSize);
+      m_dist.push_back(tmp);
+    }
+    
+    //Mean flow size calculation refers to EmpiricalVariableImpl::GetValue ()
+    m_aveFlowSize = 0.0;
+    double prev_c = 0.0;
+    double prev_v = 0.0;
+    for (uint32_t i = 0; i < m_dist.size(); i++)
+    {
+      m_empFlowSize.CDF (m_dist[i][1], m_dist[i][0]);
+      
+      if (i == 0)
+        m_aveFlowSize += (m_dist[i][0] - prev_c) * m_dist[i][1];
+      else
+        m_aveFlowSize += (prev_v + m_dist[i][1]) * (m_dist[i][0] - prev_c) / 2.0;
+      prev_c = m_dist[i][0];
+      prev_v = m_dist[i][1];
+    }
+  }
+  
+  uint32_t GetFlowSize()
+  {
+    return m_empFlowSize.GetInteger();
+  }
+  
+  EmpiricalVariable m_empFlowSize;
+  double m_aveFlowSize;
+  vector<vector<double> > m_dist; 
+};
+
+
+void FlowGenerator(WorkLoad &wl, double load, NodeContainer &allHosts, const NodeContainer *host)
+{
+  double currentTime = 0.0;
+  double interArrival = (wl.m_aveFlowSize * 8 * 1024) / (load * g_accessLinkCapacity);
+  cout << "Interarrival:" << interArrival << " " << wl.m_aveFlowSize << " " << g_accessLinkCapacity << " " << load << endl;
+  while (currentTime < g_simTime)
+  {
+    ExponentialVariable x(interArrival);
+    currentTime += x.GetValue();
+    
+    if (currentTime > g_simTime)
+      break;
+    
+    uint32_t flowSize = wl.GetFlowSize();
+    
+    uint32_t sender = rand() % allHosts.GetN();
+    uint32_t receiver = rand() % allHosts.GetN();
+    
+    while (sender == receiver)
+      receiver = rand() % allHosts.GetN();
+    
+    NS_LOG_INFO ("Flowinfo:" << currentTime << " " << sender << " " << receiver << " " << flowSize);
+    g_vecFlowInfo.push_back (FlowInfo(currentTime, sender, receiver, flowSize));
+    ConfigSingleFlow (allHosts.Get(sender), allHosts.Get(receiver), currentTime, flowSize);
+  }
+}
+
+void NewFlowGenerator(WorkLoad &wl, double load, NodeContainer &allHosts, const NodeContainer *host)
+{
+  double interArrival = (wl.m_aveFlowSize * 8 * 1024) / (load * g_accessLinkCapacity);
+  cout << "Interarrival:" << interArrival << " " << wl.m_aveFlowSize << " " << g_accessLinkCapacity << " " << load << endl;
+  for (uint32_t sender = 0; sender < allHosts.GetN(); sender++)
+  {
+    double currentTime = 0.0;
+    while (currentTime < g_simTime)
+    {
+      ExponentialVariable x(interArrival);
+      currentTime += x.GetValue();
+      
+      if (currentTime > g_simTime)
+        break;
+      
+      uint32_t flowSize = wl.GetFlowSize();
+      
+      uint32_t receiver = rand() % allHosts.GetN();
+      while (sender == receiver)
+        receiver = rand() % allHosts.GetN();
+      
+      NS_LOG_INFO ("Flowinfo:" << currentTime << " " << sender << " " << receiver << " " << flowSize);
+      g_vecFlowInfo.push_back (FlowInfo(currentTime, sender, receiver, flowSize));
+      ConfigSingleFlow (allHosts.Get(sender), allHosts.Get(receiver), currentTime, flowSize);
+    }
+  }
+}
+
+// Main
+int
+main(int argc, char *argv[])
+{
+  SetupStringToST();
+  SetSimStartTime();
+
+  // Enable log components
+  LogComponentEnable("Empirical-Workload", LOG_ALL);
+  /*LogComponentEnable("MpTcpSocketBase", LOG_ALL);
+
+  LogComponentEnable("Ipv4L3Protocol", LOG_LEVEL_INFO);
+  LogComponentEnable("StoneACL", LOG_ALL);
+  LogComponentEnable("TraccACL", LOG_ALL);
+  LogComponentEnable("StoneACLHelper", LOG_ALL);
+  LogComponentEnable("TraccACLHelper", LOG_ALL);*/
+
+  // Set up command line parameters
+  CommandLine cmd;
+  cmd.AddValue("sf", "Number of MPTCP SubFlows", MakeCallback(SetNumSubflow));
+  cmd.AddValue("cc", "MPTCP Congestion Control algorithm", MakeCallback(SetCongestionControl));
+  cmd.AddValue("st", "Simulation Time", MakeCallback(SetSimTime));
+  cmd.AddValue("socket", "Set socket type ", MakeCallback(SetSocketType));
+  cmd.AddValue("i", "Set simulation instance number as a string", MakeCallback(SetSimInstance));
+  cmd.AddValue("rto", "Set minRTO", MakeCallback(SetRTO));
+  cmd.AddValue("sim", "Set sim name", MakeCallback(SetSimName));
+  cmd.AddValue("iw", "Set initial cwnd of initial subflow of MPTCP", MakeCallback(SetIW));
+  cmd.AddValue("siw","DCMPTCP slave initial window", MakeCallback(SetSlaveIW));
+  cmd.AddValue("oppo","DCMPTCP uses OPPO", MakeCallback(SetOppo));
+  cmd.AddValue ("dctcp", "Enable DCTCP Capability", MakeCallback (SetDCTCP));
+  cmd.AddValue("wl", "Set workload", MakeCallback(SetWorkLoad));
+  cmd.AddValue("load", "Set load", MakeCallback(SetLoad));
+  
+  cmd.Parse(argc, argv);
+
+  // Set up default simulation parameters
+  Config::SetDefault("ns3::Ipv4GlobalRouting::FlowEcmpRouting", BooleanValue(true));
+  Config::SetDefault("ns3::TcpSocket::SegmentSize", UintegerValue(g_segmentSize));
+  Config::SetDefault("ns3::DropTailQueue::Mode", StringValue("QUEUE_MODE_PACKETS"));
+  Config::SetDefault("ns3::MpTcpSocketBase::RandomGap", UintegerValue(g_rGap));
+
+
+  switch (g_socketType)
+    {
+    case MPTCP:
+      Config::SetDefault("ns3::TcpL4Protocol::SocketType", TypeIdValue(MpTcpSocketBase::GetTypeId()));
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue(g_cc));
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::CongestionControl", StringValue(g_cc));
+      Config::SetDefault("ns3::MpTcpSocketBase::MaxSubflows", UintegerValue(g_subflows)); // Sink
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::MaxSubflows", UintegerValue((uint8_t)g_subflows));//Source
+      Config::SetDefault("ns3::MpTcpSocketBase::PathManagement", StringValue("NdiffPorts"));
+      Config::SetDefault("ns3::TcpSocket::InitialCwnd", UintegerValue(g_initialCWND));
+      Config::SetDefault("ns3::MpTcpSocketBase::SlaveIW", UintegerValue(g_slaveIW));
+      
+      if ((g_cc == "DCMPTCP") && (g_oppo == 1))
+        Config::SetDefault("ns3::MpTcpSocketBase::SchedulingAlgorithm", StringValue("DC_SCHE"));
+
+      break;
+    case TCP:
+      Config::SetDefault("ns3::TcpL4Protocol::SocketType", TypeIdValue(MpTcpSocketBase::GetTypeId()));
+      Config::SetDefault("ns3::MpTcpSocketBase::MaxSubflows", UintegerValue(1)); // For the sink
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::MaxSubflows", UintegerValue(1)); // TCP need one subflow only
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault("ns3::MpTcpSocketBase::PathManagement", StringValue("NdiffPorts"));
+      Config::SetDefault("ns3::TcpSocket::InitialCwnd", UintegerValue(g_initialCWND));
+      break;
+    default:
+      break;
+    }
+
+  if (g_enableDCTCP)
+    {
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault ("ns3::MpTcpSocketBase::DCTCP", BooleanValue (g_enableDCTCP));
+      Config::SetDefault ("ns3::MpTcpBulkSendApplication::DCTCP", BooleanValue (g_enableDCTCP)); // Source Control
+      Config::SetDefault ("ns3::MpTcpSocketBase::DCTCPWeight", DoubleValue (1.0 / 16.0));
+    }
+  Config::SetDefault ("ns3::RedQueue::UseCurrent", BooleanValue (true));
+
+  Config::SetDefault ("ns3::RedQueue::Mode", StringValue ("QUEUE_MODE_PACKETS"));
+  Config::SetDefault ("ns3::RedQueue::MeanPktSize", UintegerValue (g_REDMeanPktSize));
+  Config::SetDefault ("ns3::RedQueue::Wait", BooleanValue (true));
+  Config::SetDefault ("ns3::RedQueue::Gentle", BooleanValue (false));
+  Config::SetDefault ("ns3::RedQueue::QW", DoubleValue (1.0));
+  
+
+  g_seed = static_cast<double>(time(NULL)) * 1000;
+  cout << "Seed             : " << g_seed << endl;
+  srand(g_seed);
+
+  SimResultHeaderGenerator();
+
+  cout << endl;
+  cout << "Node num:" 
+  << " g_numSpine:" << g_numSpine 
+  << " g_numHost:" << g_numHost 
+  << " g_numLeaf:" << g_numLeaf << endl;
+
+
+  PrintSimParams();
+
+  InternetStackHelper internet;
+
+// ------------------ Topology Construction ------------------
+  NodeContainer allHosts;
+
+// Host Layer Nodes
+  NodeContainer host[g_numLeaf]; // NodeContainer for hosts
+
+  for (uint32_t j = 0; j < g_numLeaf; j++)
+    { // host[g_numLeaf]
+      host[j].Create(g_numHost); 
+      internet.Install(host[j]);
+      allHosts.Add(host[j]);     // Add all server to GlobalHostContainer
+      host_c.Add(host[j]);       // Add all server to Host_c for link utilization
+    }
+
+// Access layer Nodes
+  NodeContainer leaf;          // NodeContainer for leaf switches
+  leaf.Create(g_numLeaf);
+  internet.Install(leaf);
+  leaf_c.Add(leaf);
+
+// Core Layer Nodes
+  NodeContainer spine;       // NodeContainer for core switches
+  spine.Create(g_numSpine);
+  internet.Install(spine);
+  spine_c.Add(spine);
+// -----------------------------------------------------------
+  PointToPointHelper p2p;
+  //if (g_enableDCTCP )//|| (g_cc == "XMP")
+  if ((g_cc == "DCMPTCP") || g_enableDCTCP || (g_cc == "XMP"))
+  {
+    p2p.SetQueue ("ns3::RedQueue", 
+                  "LinkBandwidth", StringValue (g_downLinkCapacity), 
+                  "LinkDelay", StringValue (g_linkDelay),
+                  "MinTh", DoubleValue (g_downLinkREDminTh),
+                  "MaxTh", DoubleValue (g_downLinkREDmaxTh),
+                  "QueueLimit", UintegerValue (g_downLinkREDQueueLimit));
+  }
+  else
+  {
+    p2p.SetQueue ("ns3::DropTailQueue",
+                "MaxPackets", UintegerValue (g_downLinkREDQueueLimit));
+  }
+  p2p.SetDeviceAttribute ("DataRate", StringValue (g_downLinkCapacity));
+  p2p.SetChannelAttribute ("Delay", StringValue (g_linkDelay));
+  
+
+  Ipv4AddressHelper ipv4Address;
+  StoneACLHelper stoneACL;
+  TraccACLHelper traccACL;
+
+//=========== Connect hosts to leafs ===========//
+  NetDeviceContainer hostToLeafNetDevice[g_numLeaf][g_numHost];
+  stringstream ss;
+
+  for (uint32_t t = 0; t < g_numLeaf; t++)
+    {
+      ss.str("");
+      ss << "10." << t << ".0." << "0";
+      string tmp = ss.str();
+      const char* address = tmp.c_str();
+      ipv4Address.SetBase(address, "255.255.255.0");
+      
+      if (g_cc == "DCMPTCP") 
+      {
+        stoneACL.Install (leaf.Get(t), Ipv4Address (address), g_numHost);
+        traccACL.Install (leaf.Get(t), g_numLeaf, g_numHost, g_numSpine, Ipv4Address (address));
+      }
+      for (uint32_t h = 0; h < g_numHost; h++)
+        {
+          hostToLeafNetDevice[t][h] = p2p.Install(NodeContainer(host[t].Get(h), leaf.Get(t)));
+          ipv4Address.Assign(hostToLeafNetDevice[t][h]);
+          Ipv4Address newNet = ipv4Address.NewNetwork();
+          NS_LOG_UNCOND("Leaf:" << t << " IP:" << newNet);
+        }
+    }
+  NS_LOG_INFO("Finished connecting leaf switches and hosts");
+
+  if ((g_cc == "DCMPTCP") || g_enableDCTCP || (g_cc == "XMP"))
+  {
+    p2p.SetQueue ("ns3::RedQueue", 
+                  "LinkBandwidth", StringValue (g_upLinkCapacity), 
+                  "LinkDelay", StringValue (g_linkDelay),
+                  "MinTh", DoubleValue (g_upLinkREDminTh),
+                  "MaxTh", DoubleValue (g_upLinkREDmaxTh),
+                  "QueueLimit", UintegerValue (g_upLinkREDQueueLimit));
+  }
+  else
+  {
+    p2p.SetQueue ("ns3::DropTailQueue",
+                  "MaxPackets", UintegerValue (g_upLinkREDQueueLimit));
+  } 
+  p2p.SetDeviceAttribute ("DataRate", StringValue (g_upLinkCapacity));
+  
+  //----------------------------------------------------
+  PointToPointHelper p2p_10;
+  if ((g_cc == "DCMPTCP") || g_enableDCTCP || (g_cc == "XMP"))
+  {
+    p2p_10.SetQueue ("ns3::RedQueue", 
+                  "LinkBandwidth", StringValue (g_downLinkCapacity), 
+                  "LinkDelay", StringValue (g_linkDelay),
+                  "MinTh", DoubleValue (g_downLinkREDminTh),
+                  "MaxTh", DoubleValue (g_downLinkREDmaxTh),
+                  "QueueLimit", UintegerValue (g_downLinkREDQueueLimit));
+  }
+  else
+  {
+    p2p_10.SetQueue ("ns3::DropTailQueue",
+                  "MaxPackets", UintegerValue (g_downLinkREDQueueLimit));
+  }
+  p2p_10.SetDeviceAttribute ("DataRate", StringValue (g_downLinkCapacity));
+  p2p_10.SetChannelAttribute ("Delay", StringValue (g_linkDelay));
+  
+  //---------------------------------------------------
+//=========== Connect core switches to aggregate switches ===========//
+  NetDeviceContainer ct[g_numSpine][g_numLeaf];
+  ipv4Address.SetBase("30.30.0.0", "255.255.255.0");
+
+  for (uint32_t c = 0; c < g_numSpine; c++)
+    {
+      for (uint32_t p = 0; p < g_numLeaf; p++)
+        {
+          if ((c == p) || (c == ((p + 1) % g_numLeaf)))
+          {
+            NS_LOG_UNCOND("10G c&p:" << c << " " << p);
+            ct[c][p] = p2p_10.Install(spine.Get(c), leaf.Get(p));
+          }
+          else
+            ct[c][p] = p2p.Install(spine.Get(c), leaf.Get(p));
+          ipv4Address.Assign(ct[c][p]);
+          Ipv4Address newNet = ipv4Address.NewNetwork();
+          NS_LOG_UNCOND(newNet);
+        }
+    }
+  NS_LOG_INFO("Finished connecting core and aggregation");
+  //p2p.EnablePcapAll(SetupSimFileName("PCAP"));
+
+  // Populate Global Routing
+  Ipv4GlobalRoutingHelper::PopulateRoutingTables();
+
+
+  //=========== Initialize settings for On/Off Application ===========//
+  // SINK application - It would be closed doubled the time of source closure!
+  //NS_LOG_INFO("\nSink App Install on following nodes: ");
+  for (uint32_t i = 0; i < allHosts.GetN(); i++)
+  {
+    MpTcpPacketSinkHelper sink("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address::GetAny(), PORT));
+    ApplicationContainer tmp = sink.Install(allHosts.Get(i));
+    tmp.Start(Seconds(0.0));
+    tmp.Stop(Seconds(g_simTime));
+  }
+  
+  WorkLoad wl(g_workload);
+
+  NewFlowGenerator(wl, g_load, allHosts, host);
+
+
+  NS_LOG_INFO ("Run Simulation.");
+  Simulator::Stop(Seconds(g_simTime));
+  Simulator::Run();
+
+  cout << Simulator::Now().GetSeconds() << " -> Generate Out puts"<< endl;
+
+  SimResultFooterGenerator(); // OveralResultWritter should be called first!
+  //-----------------------------------------------------------------------//
+  Simulator::Destroy();
+  NS_LOG_INFO ("Done.");
+  cout << Simulator::Now().GetSeconds() << " END "<< endl;
+  return 0;
+}
+
+
+
diff --git a/scratch/empirical-workload.cc b/scratch/empirical-workload.cc
new file mode 100644
index 0000000..324eb42
--- /dev/null
+++ b/scratch/empirical-workload.cc
@@ -0,0 +1,782 @@
+/*
+ * Author: Enhuan Dong -A pathetic PhD student.- <deh13@mails.tsinghua.edu.cn>
+ */
+#include <ctime>
+#include <sys/time.h>
+#include <stdint.h>
+#include <fstream>
+#include <string>
+#include <cassert>
+#include <iostream>
+#include <iomanip>
+#include <cfloat>
+#include "ns3/log.h"
+#include "ns3/core-module.h"
+#include "ns3/network-module.h"
+#include "ns3/applications-module.h"
+#include "ns3/point-to-point-module.h"
+#include "ns3/internet-module.h"
+#include "ns3/netanim-module.h"
+#include "ns3/mobility-module.h"
+#include "ns3/callback.h"
+#include "ns3/string.h"
+
+using namespace ns3;
+NS_LOG_COMPONENT_DEFINE("Empirical-Workload");
+
+typedef enum
+{
+  Spine, Leaf, Host, Spine_Leaf, Spine_Leaf_Host
+} Layers_t;
+
+typedef enum
+{
+  NONE, NEW_INCAST, TYPICAL_INCAST, NEW_INCAST_BK, ONE_MAP_ONE
+} TrafficMatrix_t;
+
+typedef enum
+{
+  TCP, MPTCP
+} SocketType_t;
+
+
+std::map<string, TrafficMatrix_t> stringToTrafficMatrix;
+std::map<string, SocketType_t> stringToSocketType;
+
+#define PORT 5000
+
+// Setup general parameters
+string g_topology = "Leaf-Spine-8x8";
+string g_simName  = "MPTCP_Incast";
+string g_workload = "datamining.txt";
+double g_load = 0.5;
+
+
+// Setup topology parameters
+string g_downLinkCapacity = "10Gbps";
+double g_accessLinkCapacity = 10000000000;
+string g_upLinkCapacity = "40Gbps";  //Normal
+string g_linkDelay = "25us";       
+
+uint32_t g_numSpine = 8;
+uint32_t g_numLeaf = 8;
+uint32_t g_numHost = 64;
+
+double g_simTime = 1.0;             // 1 Seconds (default)
+uint32_t g_seed = 0;                // RNG seed
+SocketType_t g_socketType = MPTCP;
+
+string g_simInstance = "0";
+string g_simStartTime = "NULL";
+uint32_t g_minRTO = 200;
+
+uint32_t g_rGap = 50;
+// Setup MPTCP parameters
+string g_cc = "RTT_Compensator"; // Uncoupled_TCPs, Linked_Increases, Fully_Coupled, RTT_Compensator
+uint32_t g_subflows = 8;
+uint32_t g_initialCWND = 10;
+uint32_t g_slaveIW = 1;
+uint32_t g_oppo = 1;
+bool g_enableDCTCP = true;
+uint32_t g_perSubflow = 0;
+
+// For dctcp only
+double g_downLinkREDmaxTh = 65;
+double g_downLinkREDminTh = 65;
+ 
+uint32_t g_downLinkREDQueueLimit = 350;   
+
+ // Normal
+double g_upLinkREDmaxTh = 150;
+double g_upLinkREDminTh = 150;
+uint32_t g_upLinkREDQueueLimit = 1400;   
+
+uint32_t g_segmentSize = 1400;
+uint32_t g_REDMeanPktSize = g_segmentSize;
+
+
+
+
+// NodeContainer to use for link utilization and loss rate
+NodeContainer spine_c;
+NodeContainer leaf_c;
+NodeContainer host_c;
+
+class FlowInfo
+{
+public:
+  FlowInfo (double startTime, uint32_t sender, uint32_t receiver, uint32_t flowSize)
+  {
+    m_startTime = startTime;
+    m_sender = sender;
+    m_receiver = receiver;
+    m_flowSize = flowSize;
+  }
+  double m_startTime;
+  uint32_t m_sender;
+  uint32_t m_receiver;
+  uint32_t m_flowSize;
+};
+
+vector<FlowInfo> g_vecFlowInfo;
+
+
+void SimHeaderWritter(Ptr<OutputStreamWrapper> stream);
+void SimFooterWritter(Ptr<OutputStreamWrapper> stream);
+
+uint64_t
+GetLinkRate(string linkRate)
+{
+  DataRate tmp(linkRate);
+  return tmp.GetBitRate();
+}
+
+void
+SetupStringToST()
+{
+  stringToSocketType["TCP"] = TCP;
+  stringToSocketType["MPTCP"] = MPTCP;
+}
+
+
+string
+GetKeyFromValueST(SocketType_t st)
+{
+  map<string, SocketType_t>::const_iterator it = stringToSocketType.begin();
+  for (; it != stringToSocketType.end(); it++)
+    {
+      if (it->second == st)
+        return it->first;
+    }
+  return "";
+}
+
+string
+SetupSimFileName(string input)
+{
+  ostringstream oss;
+  oss.str("");
+  oss << g_simName << "_" << g_topology  <<  "_MPTCP_Empirical" << "_" << input << "_" << g_simInstance
+      << ".data";
+  string tmp = oss.str();
+  oss.str("");
+  return tmp;
+}
+
+void
+PrintSimParams()
+{
+  cout << endl;
+  cout << "Socket Type      : " << GetKeyFromValueST(g_socketType).c_str() << endl;
+  cout << "Seed             : " << g_seed << endl;
+  cout << "Instance         : " << g_simInstance << endl;
+  cout << "DCTCP            : " << g_enableDCTCP << endl;
+  cout << "CC               : " << g_cc << endl;
+}
+
+
+
+Ptr<Queue>
+FindQueue(Ptr<NetDevice> dev)
+{
+  PointerValue ptr;
+  dev->GetAttribute("TxQueue", ptr);
+  return ptr.Get<Queue>();
+}
+
+
+
+string
+GetDateTimeNow()
+{
+  time_t T = time(0);
+  struct tm* now = localtime(&T);
+  string simStartDate = asctime(now);
+  return simStartDate.substr(0, 24);
+}
+
+void
+SetSimStartTime()
+{
+  g_simStartTime = GetDateTimeNow();
+}
+
+string
+GetSimStartTime()
+{
+  return g_simStartTime;
+}
+
+void
+SimHeaderWritter(Ptr<OutputStreamWrapper> stream)
+{
+  ostream *os = stream->GetStream ();
+  *os << "SimStart [" << g_simStartTime << "] simName[" << g_simName
+      << "] Topology[" << g_topology 
+      << "] SocketType[" << GetKeyFromValueST (g_socketType) 
+      << "] Seed[" << g_seed << "] simInstance["
+      << g_simInstance << "] SimPeriod[" << g_simTime
+      << "s] HostPerLeaf[" << g_numHost << "] CC[" << g_cc << "] dctcp[" << g_enableDCTCP
+      <<"] SubflowNum[" <<g_subflows
+      << "] upLinkRate["<< g_upLinkCapacity << "] downLinkRate["<< g_downLinkCapacity << "] LinkDelay[" << g_linkDelay
+      << "] RTOmin[ " << g_minRTO << "]" << endl;
+}
+
+void
+SimFooterWritter(Ptr<OutputStreamWrapper> stream)
+{
+  ostream *os = stream->GetStream();
+  *os << "SimEnd [" << GetDateTimeNow() << endl;
+}
+
+
+void
+SimResultHeaderGenerator()
+{
+  Ptr<OutputStreamWrapper> streamSimParam = Create<OutputStreamWrapper>(SetupSimFileName("RESULT"),
+      std::ios::out | std::ios::app);
+  SimHeaderWritter(streamSimParam);
+}
+
+void
+SimResultFooterGenerator()
+{
+  Ptr<OutputStreamWrapper> streamSimParam = Create<OutputStreamWrapper>(SetupSimFileName("RESULT"),
+      std::ios::out | std::ios::app);
+  SimFooterWritter(streamSimParam);
+}
+
+bool
+SetNumSubflow(std::string input)
+{
+  cout << "Subflows         : " << g_subflows << " -> " << input << endl;
+  g_subflows = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetCongestionControl(std::string input)
+{
+  cout << "CongestionControl: " << g_cc << " -> " << input << endl;
+  g_cc = input;
+  return true;
+}
+
+
+bool
+SetSimTime(std::string input)
+{
+  cout << "SimDuration      : " << g_simTime << " -> " << input << endl;
+  g_simTime = atof(input.c_str());
+  return true;
+}
+
+
+bool
+SetSocketType(std::string input)
+{
+  cout << "SocketType       : " << GetKeyFromValueST(g_socketType) << " -> " << input << endl;
+  if (stringToSocketType.count(input) != 0)
+    {
+      g_socketType = stringToSocketType[input];
+    }
+  else
+    NS_FATAL_ERROR("Input for setting up socket type has spelling issue - try again!");
+  return true;
+}
+
+bool
+SetSimInstance(std::string input)
+{
+  cout << "SimInstance      : " << g_simInstance << " -> " << input << endl;
+  g_simInstance = input;
+  return true;
+}
+
+bool
+SetRTO(std::string input)
+{
+  cout << "RTO              : " << g_minRTO << " -> " << input << endl;
+  g_minRTO = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetSimName(std::string input)
+{
+  cout << "SimName          : " << g_simName << " -> " << input << endl;
+  g_simName = input;
+  return true;
+}
+
+bool
+SetWorkLoad(std::string input)
+{
+  cout << "Workload          : " << g_workload << " -> " << input << endl;
+  g_workload = input;
+  return true;
+}
+
+bool
+SetLoad(std::string input)
+{
+  cout << "Load          : " << g_load << " -> " << input << endl;
+  g_load = atof(input.c_str());
+  return true;
+}
+
+bool
+SetIW(std::string input)
+{
+  cout << "InitalCWND       : " << g_initialCWND << " -> " << input << endl;
+  g_initialCWND = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetSlaveIW(std::string input)
+{
+  cout << "InitalSlaveCWND       : " << g_slaveIW << " -> " << input << endl;
+  g_slaveIW = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetOppo(std::string input)
+{
+  cout << "UseOppo       : " << g_oppo << " -> " << input << endl;
+  g_oppo = atoi(input.c_str());
+  return true;
+}
+
+
+bool
+SetPerSubflow(std::string input)
+{
+  cout << "PerSubflow       : " << g_perSubflow << " -> " << input << endl;
+  g_perSubflow = atoi(input.c_str());
+  return true;
+}
+
+
+bool
+SetHostNumber(std::string input){
+  cout << "Host Number    : " << g_numHost << " -> " << input << endl;
+  g_numHost = atoi(input.c_str());
+  return true;
+}
+
+
+void printNodeAddr(Ptr<Node> tmp)
+{
+  Ptr<Ipv4> ipv4Src = tmp->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+  Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+  ipv4AddressSrc.Print(cout);
+  cout << endl;
+}
+
+
+bool
+SetDCTCP (std::string input)
+{
+  cout << "Enable DCTCP     : " << g_enableDCTCP << " -> " << input << endl;
+  g_enableDCTCP = atoi (input.c_str ());
+  return true;
+}
+
+
+void
+ConfigSingleFlow (Ptr<Node> srcNode, Ptr<Node> dstNode, double startTime, uint32_t flowSize)
+{
+  Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+  Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+  cout << "DST:";
+  ipv4AddressDst.Print(cout);
+  cout << endl;
+
+  Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+  Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+  cout << "SRC:";
+  ipv4AddressSrc.Print(cout);
+  cout << endl;
+
+  // Assign flowId
+  int flowId = srcNode->GetNApplications();
+
+  // Source
+  MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+  source.SetAttribute("MaxBytes", UintegerValue(flowSize * 1024));
+  source.SetAttribute("FlowId", UintegerValue(flowId));
+  //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+  source.SetAttribute("FlowType", StringValue("Short"));
+  string tempString = SetupSimFileName("RESULT");
+  source.SetAttribute("OutputFileName", StringValue(tempString));
+
+  ApplicationContainer sourceApps = source.Install(srcNode);
+  sourceApps.Start (Seconds(startTime));
+  sourceApps.Stop (Seconds(g_simTime));
+}
+
+class WorkLoad
+{
+public:
+  
+  WorkLoad(string file)
+  {
+    string realFileName = "/home/nick/8T/dcmptcp/tpds-sim/dcmptcp-real/workloads/"+file;
+    ifstream infile(realFileName.c_str());
+    
+    double cdf = 0.0;
+    double flowSize = 0.0;
+    while (infile >> cdf >> flowSize)
+    {
+      vector<double> tmp;
+      tmp.push_back(cdf);
+      tmp.push_back(flowSize);
+      m_dist.push_back(tmp);
+    }
+    
+    //Mean flow size calculation refers to EmpiricalVariableImpl::GetValue ()
+    m_aveFlowSize = 0.0;
+    double prev_c = 0.0;
+    double prev_v = 0.0;
+    for (uint32_t i = 0; i < m_dist.size(); i++)
+    {
+      m_empFlowSize.CDF (m_dist[i][1], m_dist[i][0]);
+      
+      if (i == 0)
+        m_aveFlowSize += (m_dist[i][0] - prev_c) * m_dist[i][1];
+      else
+        m_aveFlowSize += (prev_v + m_dist[i][1]) * (m_dist[i][0] - prev_c) / 2.0;
+      prev_c = m_dist[i][0];
+      prev_v = m_dist[i][1];
+    }
+  }
+  
+  uint32_t GetFlowSize()
+  {
+    return m_empFlowSize.GetInteger();
+  }
+  
+  EmpiricalVariable m_empFlowSize;
+  double m_aveFlowSize;
+  vector<vector<double> > m_dist; 
+};
+
+
+void FlowGenerator(WorkLoad &wl, double load, NodeContainer &allHosts, const NodeContainer *host)
+{
+  double currentTime = 0.0;
+  double interArrival = (wl.m_aveFlowSize * 8 * 1024) / (load * g_accessLinkCapacity);
+  cout << "Interarrival:" << interArrival << " " << wl.m_aveFlowSize << " " << g_accessLinkCapacity << " " << load << endl;
+  while (currentTime < g_simTime)
+  {
+    ExponentialVariable x(interArrival);
+    currentTime += x.GetValue();
+    
+    if (currentTime > g_simTime)
+      break;
+    
+    uint32_t flowSize = wl.GetFlowSize();
+    
+    uint32_t sender = rand() % allHosts.GetN();
+    uint32_t receiver = rand() % allHosts.GetN();
+    
+    while (sender == receiver)
+      receiver = rand() % allHosts.GetN();
+    
+    NS_LOG_INFO ("Flowinfo:" << currentTime << " " << sender << " " << receiver << " " << flowSize);
+    g_vecFlowInfo.push_back (FlowInfo(currentTime, sender, receiver, flowSize));
+    ConfigSingleFlow (allHosts.Get(sender), allHosts.Get(receiver), currentTime, flowSize);
+  }
+}
+
+void NewFlowGenerator(WorkLoad &wl, double load, NodeContainer &allHosts, const NodeContainer *host)
+{
+  double interArrival = (wl.m_aveFlowSize * 8 * 1024) / (load * g_accessLinkCapacity);
+  cout << "Interarrival:" << interArrival << " " << wl.m_aveFlowSize << " " << g_accessLinkCapacity << " " << load << endl;
+  for (uint32_t sender = 0; sender < allHosts.GetN(); sender++)
+  {
+    double currentTime = 0.0;
+    while (currentTime < g_simTime)
+    {
+      ExponentialVariable x(interArrival);
+      currentTime += x.GetValue();
+      
+      if (currentTime > g_simTime)
+        break;
+      
+      uint32_t flowSize = wl.GetFlowSize();
+      
+      uint32_t receiver = rand() % allHosts.GetN();
+      while (sender == receiver)
+        receiver = rand() % allHosts.GetN();
+      
+      NS_LOG_INFO ("Flowinfo:" << currentTime << " " << sender << " " << receiver << " " << flowSize);
+      g_vecFlowInfo.push_back (FlowInfo(currentTime, sender, receiver, flowSize));
+      ConfigSingleFlow (allHosts.Get(sender), allHosts.Get(receiver), currentTime, flowSize);
+    }
+  }
+}
+
+// Main
+int
+main(int argc, char *argv[])
+{
+  SetupStringToST();
+  SetSimStartTime();
+
+  // Enable log components
+  LogComponentEnable("Empirical-Workload", LOG_ALL);
+  /*LogComponentEnable("MpTcpSocketBase", LOG_ALL);
+
+  LogComponentEnable("Ipv4L3Protocol", LOG_LEVEL_INFO);
+  LogComponentEnable("StoneACL", LOG_ALL);
+  LogComponentEnable("TraccACL", LOG_ALL);
+  LogComponentEnable("StoneACLHelper", LOG_ALL);
+  LogComponentEnable("TraccACLHelper", LOG_ALL);*/
+
+  // Set up command line parameters
+  CommandLine cmd;
+  cmd.AddValue("sf", "Number of MPTCP SubFlows", MakeCallback(SetNumSubflow));
+  cmd.AddValue("cc", "MPTCP Congestion Control algorithm", MakeCallback(SetCongestionControl));
+  cmd.AddValue("st", "Simulation Time", MakeCallback(SetSimTime));
+  cmd.AddValue("socket", "Set socket type ", MakeCallback(SetSocketType));
+  cmd.AddValue("i", "Set simulation instance number as a string", MakeCallback(SetSimInstance));
+  cmd.AddValue("rto", "Set minRTO", MakeCallback(SetRTO));
+  cmd.AddValue("sim", "Set sim name", MakeCallback(SetSimName));
+  cmd.AddValue("iw", "Set initial cwnd of initial subflow of MPTCP", MakeCallback(SetIW));
+  cmd.AddValue("siw","DCMPTCP slave initial window", MakeCallback(SetSlaveIW));
+  cmd.AddValue("oppo","DCMPTCP uses OPPO", MakeCallback(SetOppo));
+  cmd.AddValue("persub","DCMPTCP uses Per Subflow based CC", MakeCallback(SetPerSubflow));
+  cmd.AddValue ("dctcp", "Enable DCTCP Capability", MakeCallback (SetDCTCP));
+  cmd.AddValue("wl", "Set workload", MakeCallback(SetWorkLoad));
+  cmd.AddValue("load", "Set load", MakeCallback(SetLoad));
+  
+  cmd.Parse(argc, argv);
+
+  // Set up default simulation parameters
+  Config::SetDefault("ns3::Ipv4GlobalRouting::FlowEcmpRouting", BooleanValue(true));
+  Config::SetDefault("ns3::TcpSocket::SegmentSize", UintegerValue(g_segmentSize));
+  Config::SetDefault("ns3::DropTailQueue::Mode", StringValue("QUEUE_MODE_PACKETS"));
+  Config::SetDefault("ns3::MpTcpSocketBase::RandomGap", UintegerValue(g_rGap));
+
+
+  switch (g_socketType)
+    {
+    case MPTCP:
+      Config::SetDefault("ns3::TcpL4Protocol::SocketType", TypeIdValue(MpTcpSocketBase::GetTypeId()));
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue(g_cc));
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::CongestionControl", StringValue(g_cc));
+      Config::SetDefault("ns3::MpTcpSocketBase::MaxSubflows", UintegerValue(g_subflows)); // Sink
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::MaxSubflows", UintegerValue((uint8_t)g_subflows));//Source
+      Config::SetDefault("ns3::MpTcpSocketBase::PathManagement", StringValue("NdiffPorts"));
+      Config::SetDefault("ns3::TcpSocket::InitialCwnd", UintegerValue(g_initialCWND));
+      Config::SetDefault("ns3::MpTcpSocketBase::SlaveIW", UintegerValue(g_slaveIW));
+      
+      if ((g_cc == "DCMPTCP") && (g_oppo == 1))
+        Config::SetDefault("ns3::MpTcpSocketBase::SchedulingAlgorithm", StringValue("DC_SCHE"));
+      
+      if ((g_cc == "DCMPTCP") && (g_perSubflow == 1))
+        Config::SetDefault("ns3::MpTcpSocketBase::DCPerSubflow", BooleanValue(true));
+
+      break;
+    case TCP:
+      Config::SetDefault("ns3::TcpL4Protocol::SocketType", TypeIdValue(MpTcpSocketBase::GetTypeId()));
+      Config::SetDefault("ns3::MpTcpSocketBase::MaxSubflows", UintegerValue(1)); // For the sink
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::MaxSubflows", UintegerValue(1)); // TCP need one subflow only
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault("ns3::MpTcpSocketBase::PathManagement", StringValue("NdiffPorts"));
+      Config::SetDefault("ns3::TcpSocket::InitialCwnd", UintegerValue(g_initialCWND));
+      break;
+    default:
+      break;
+    }
+
+  if (g_enableDCTCP)
+    {
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault ("ns3::MpTcpSocketBase::DCTCP", BooleanValue (g_enableDCTCP));
+      Config::SetDefault ("ns3::MpTcpBulkSendApplication::DCTCP", BooleanValue (g_enableDCTCP)); // Source Control
+      Config::SetDefault ("ns3::MpTcpSocketBase::DCTCPWeight", DoubleValue (1.0 / 16.0));
+    }
+  Config::SetDefault ("ns3::RedQueue::UseCurrent", BooleanValue (true));
+
+  Config::SetDefault ("ns3::RedQueue::Mode", StringValue ("QUEUE_MODE_PACKETS"));
+  Config::SetDefault ("ns3::RedQueue::MeanPktSize", UintegerValue (g_REDMeanPktSize));
+  Config::SetDefault ("ns3::RedQueue::Wait", BooleanValue (true));
+  Config::SetDefault ("ns3::RedQueue::Gentle", BooleanValue (false));
+  Config::SetDefault ("ns3::RedQueue::QW", DoubleValue (1.0));
+  
+  g_seed = static_cast<double>(time(NULL)) * 1000;
+  cout << "Seed             : " << g_seed << endl;
+  srand(g_seed);
+
+  SimResultHeaderGenerator();
+
+  cout << endl;
+  cout << "Node num:" 
+  << " g_numSpine:" << g_numSpine 
+  << " g_numHost:" << g_numHost 
+  << " g_numLeaf:" << g_numLeaf << endl;
+
+
+  PrintSimParams();
+
+  InternetStackHelper internet;
+
+// ------------------ Topology Construction ------------------
+  NodeContainer allHosts;
+
+// Host Layer Nodes
+  NodeContainer host[g_numLeaf]; // NodeContainer for hosts
+
+  for (uint32_t j = 0; j < g_numLeaf; j++)
+    { // host[g_numLeaf]
+      host[j].Create(g_numHost); 
+      internet.Install(host[j]);
+      allHosts.Add(host[j]);     // Add all server to GlobalHostContainer
+      host_c.Add(host[j]);       // Add all server to Host_c for link utilization
+    }
+
+// Access layer Nodes
+  NodeContainer leaf;          // NodeContainer for leaf switches
+  leaf.Create(g_numLeaf);
+  internet.Install(leaf);
+  leaf_c.Add(leaf);
+
+// Core Layer Nodes
+  NodeContainer spine;       // NodeContainer for core switches
+  spine.Create(g_numSpine);
+  internet.Install(spine);
+  spine_c.Add(spine);
+// -----------------------------------------------------------
+  PointToPointHelper p2p;
+  //if (g_enableDCTCP )//|| (g_cc == "XMP")
+  if ((g_cc == "DCMPTCP") || g_enableDCTCP || (g_cc == "XMP"))
+  {
+    p2p.SetQueue ("ns3::RedQueue", 
+                  "LinkBandwidth", StringValue (g_downLinkCapacity), 
+                  "LinkDelay", StringValue (g_linkDelay),
+                  "MinTh", DoubleValue (g_downLinkREDminTh),
+                  "MaxTh", DoubleValue (g_downLinkREDmaxTh),
+                  "QueueLimit", UintegerValue (g_downLinkREDQueueLimit));
+  }
+  else
+  {
+    p2p.SetQueue ("ns3::DropTailQueue",
+                "MaxPackets", UintegerValue (g_downLinkREDQueueLimit));
+  }
+  p2p.SetDeviceAttribute ("DataRate", StringValue (g_downLinkCapacity));
+  p2p.SetChannelAttribute ("Delay", StringValue (g_linkDelay));
+  
+
+  Ipv4AddressHelper ipv4Address;
+  StoneACLHelper stoneACL;
+  TraccACLHelper traccACL;
+
+//=========== Connect hosts to leafs ===========//
+  NetDeviceContainer hostToLeafNetDevice[g_numLeaf][g_numHost];
+  stringstream ss;
+
+  for (uint32_t t = 0; t < g_numLeaf; t++)
+    {
+      ss.str("");
+      ss << "10." << t << ".0." << "0";
+      string tmp = ss.str();
+      const char* address = tmp.c_str();
+      ipv4Address.SetBase(address, "255.255.255.0");
+      
+      if (g_cc == "DCMPTCP") 
+      {
+        stoneACL.Install (leaf.Get(t), Ipv4Address (address), g_numHost);
+        traccACL.Install (leaf.Get(t), g_numLeaf, g_numHost, g_numSpine, Ipv4Address (address));
+      }
+      for (uint32_t h = 0; h < g_numHost; h++)
+        {
+          hostToLeafNetDevice[t][h] = p2p.Install(NodeContainer(host[t].Get(h), leaf.Get(t)));
+          ipv4Address.Assign(hostToLeafNetDevice[t][h]);
+          Ipv4Address newNet = ipv4Address.NewNetwork();
+          NS_LOG_UNCOND("Leaf:" << t << " IP:" << newNet);
+        }
+    }
+  NS_LOG_INFO("Finished connecting leaf switches and hosts");
+
+  if ((g_cc == "DCMPTCP") || g_enableDCTCP || (g_cc == "XMP"))
+  {
+    p2p.SetQueue ("ns3::RedQueue", 
+                  "LinkBandwidth", StringValue (g_upLinkCapacity), 
+                  "LinkDelay", StringValue (g_linkDelay),
+                  "MinTh", DoubleValue (g_upLinkREDminTh),
+                  "MaxTh", DoubleValue (g_upLinkREDmaxTh),
+                  "QueueLimit", UintegerValue (g_upLinkREDQueueLimit));
+  }
+  else
+  {
+    p2p.SetQueue ("ns3::DropTailQueue",
+                  "MaxPackets", UintegerValue (g_upLinkREDQueueLimit));
+  } 
+  p2p.SetDeviceAttribute ("DataRate", StringValue (g_upLinkCapacity));
+//=========== Connect core switches to aggregate switches ===========//
+  NetDeviceContainer ct[g_numSpine][g_numLeaf];
+  ipv4Address.SetBase("30.30.0.0", "255.255.255.0");
+
+  for (uint32_t c = 0; c < g_numSpine; c++)
+    {
+      for (uint32_t p = 0; p < g_numLeaf; p++)
+        {
+          ct[c][p] = p2p.Install(spine.Get(c), leaf.Get(p));
+          ipv4Address.Assign(ct[c][p]);
+          Ipv4Address newNet = ipv4Address.NewNetwork();
+          NS_LOG_UNCOND(newNet);
+        }
+    }
+  NS_LOG_INFO("Finished connecting core and aggregation");
+  //p2p.EnablePcapAll(SetupSimFileName("PCAP"));
+
+  // Populate Global Routing
+  Ipv4GlobalRoutingHelper::PopulateRoutingTables();
+
+  //SetupTraces(Spine_Leaf_Host);
+
+  //=========== Initialize settings for On/Off Application ===========//
+  // SINK application - It would be closed doubled the time of source closure!
+  //NS_LOG_INFO("\nSink App Install on following nodes: ");
+  for (uint32_t i = 0; i < allHosts.GetN(); i++)
+  {
+    MpTcpPacketSinkHelper sink("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address::GetAny(), PORT));
+    ApplicationContainer tmp = sink.Install(allHosts.Get(i));
+    tmp.Start(Seconds(0.0));
+    tmp.Stop(Seconds(g_simTime));
+  }
+  
+  WorkLoad wl(g_workload);
+
+  //FlowGenerator(wl, g_load, allHosts, host);
+  NewFlowGenerator(wl, g_load, allHosts, host);
+
+
+
+  //SimTimeMonitor();
+
+  NS_LOG_INFO ("Run Simulation.");
+  Simulator::Stop(Seconds(g_simTime));
+  Simulator::Run();
+
+  cout << Simulator::Now().GetSeconds() << " -> Generate Out puts"<< endl;
+
+  SimResultFooterGenerator(); // OveralResultWritter should be called first!
+  //-----------------------------------------------------------------------//
+  Simulator::Destroy();
+  NS_LOG_INFO ("Done.");
+  cout << Simulator::Now().GetSeconds() << " END "<< endl;
+  return 0;
+}
+
+
+
diff --git a/scratch/incast.cc b/scratch/incast.cc
deleted file mode 100644
index 995a444..0000000
--- a/scratch/incast.cc
+++ /dev/null
@@ -1,1150 +0,0 @@
-/*
- * Author: Morteza Kheirkhah <m.kheirkhah@ed.ac.uk>
- */
-
-#include <stdint.h>
-#include <iostream>
-#include <fstream>
-#include <string>
-#include <cassert>
-#include "ns3/log.h"
-#include "ns3/core-module.h"
-#include "ns3/network-module.h"
-#include "ns3/applications-module.h"
-#include "ns3/point-to-point-module.h"
-#include "ns3/internet-module.h"
-#include "ns3/gnuplot.h"
-#include "ns3/output-stream-wrapper.h"
-#include "ns3/drop-tail-queue.h"
-#include "ns3/red-queue.h"
-#include "ns3/netanim-module.h"
-
-using namespace ns3;
-using namespace std;
-
-NS_LOG_COMPONENT_DEFINE("incast");
-
-NodeContainer Sender_c;
-NodeContainer Receiver_c;
-NodeContainer Core_c;
-NodeContainer Total_c;
-
-GnuplotCollection gnu;
-
-vector<pair<double, double> > RedTxQueue;
-bool g_enableRatePlotting = true;
-bool g_enableLfPlotting = true;
-bool g_enableSfPlotting = false;
-bool g_enableRED = true;
-bool g_enableDCTCP = true;
-double g_REDmaxTh = 10;
-double g_REDminTh = 10;
-double g_REDWeight = 1.0;
-bool g_REDGentle = false;
-uint32_t g_segmentSize = 1400;
-uint32_t g_REDMeanPktSize = g_segmentSize;
-uint32_t g_REDQueueLimit = 100;         // Queue limit per packets
-double g_DCTCPWeight = 1.0 / 16.0;      // DCTCP weight factor
-string g_linkCapacity = "1000Mbps";     // 100Mbps
-string g_linkDelay = "56us";            // RTT of empty path; 60us * 4 = 240us
-uint32_t g_subflows = 1;                // 8 Subflows
-string g_note = "";
-bool g_enableAnim = false;
-double g_samplingInterval = 0.0001;
-uint32_t g_XmpGamma = 1;
-uint32_t g_XmpBeta = 4;
-uint32_t g_flowSize = 0;      // 0: unlimited, state otherwise!
-string g_cc = "XCA";
-string g_cc_tmp = "NONE";
-uint32_t g_seed = 0;          // RNG seed
-string g_simInstance = "0";   // Dynamically adjust at cmd
-double g_rateBeat = 0.1;
-bool g_ecn = false;
-string g_simName = "";
-string g_scenario = "INCAST";
-double g_rtt = 4*Time(g_linkDelay).GetMicroSeconds();
-bool g_slowDownXmpLike = false;
-bool g_queueModeBytes = false;// If true, the queues perform per bytes rather than packets.
-bool g_dctcpAlphaPerAck = false;
-bool g_dctcpFastAlpha = false;
-uint32_t g_DTQmarkTh = 1;
-bool g_SDEL = false;
-// Normal Scenario
-string   g_flowType = "XMP";
-uint32_t g_flowNumber = 4;
-double   g_flowgap = 0.000224;
-double   g_simTime = 1;
-double   g_flowEndTimeGap = 0.0;
-// Special Scenario
-bool     g_specialSource = false;
-string   g_specialFlowType = "ECN";
-uint32_t g_specialFlowNumber = 1;
-bool     g_specialSubflow = false;
-// Cwnd/Rwnd
-uint32_t g_cwndMin = 1;
-uint32_t g_rwndScale = 100;
-//DynamicSubflows
-bool g_dynamicSubflow = false;
-uint32_t g_incastThreshold = 10;
-uint32_t g_incastExitThreshold = 8;
-//sender
-uint32_t g_senders = g_flowNumber;
-uint32_t g_receivers = 1;
-uint32_t g_core_switches = 1;
-uint32_t servPort = 5000;
-// IncastInterval
-bool g_enabledIncastInterval = false;
-double g_incastIntervalTime = 1; // seconds
-uint64_t g_incastFlowCount = 0;
-bool g_singleFileIncast = false;
-
-/* Uncoupled_TCPs, Linked_Increases, RTT_Compensator, Fully_Coupled */
-std::string
-ConvertCC (string input)
-{
-  if (input.compare ("Fully_Coupled") == 0)
-    return "FC";
-  else if (input.compare ("Uncoupled_TCPs") == 0)
-    return "UC";
-  else if (input.compare ("RTT_Compensator") == 0)
-    return "RC";
-  else if (input.compare ("XMP") == 0)
-    return "XMP";
-  else if (input.compare ("Fast_Increases") == 0)
-    return "FI";
-  else if (input.compare ("Fast_Uncoupled") == 0)
-    return "FU";
-  else if (input.compare ("XCA") == 0)
-    return "XCA";
-  return "Unknown";
-}
-
-string SetupSimFileName(uint32_t i);
-
-Ipv4Address
-GetIpAddr(NodeContainer nc, uint32_t dst)
-{
-  Ptr<Node> randomServerNode = nc.Get (dst);
-  Ptr<Ipv4> ipv4Server = randomServerNode->GetObject<Ipv4> ();
-  Ipv4InterfaceAddress iaddrServer = ipv4Server->GetAddress (1, 0);
-  return iaddrServer.GetLocal ();
-}
-
-
-string
-SetupSource (MpTcpBulkSendHelper& source, uint32_t i)
-{
-  if (g_specialSubflow)
-    {
-      source.SetAttribute ("MaxSubflows", UintegerValue (1));
-      cout << "Setup Normal  Source SF[" << 1 << "] -> ";
-    }
-  else
-    {
-      source.SetAttribute ("MaxSubflows", UintegerValue (g_subflows));
-      cout << "Setup Normal  Source SF[" << g_subflows << "] -> ";
-    }
-
-  if (g_flowType == "XMP")
-    {
-      g_cc_tmp = "XMP";
-      source.SetAttribute ("DCTCP", BooleanValue (false));
-      source.SetAttribute ("CongestionControl", StringValue ("XMP"));
-      source.SetAttribute ("SocketModel", StringValue ("XMP"));
-    }
-  else if (g_flowType == "DCMPTCP")
-    {
-      g_cc_tmp = "RTT_Compensator";
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("DCMPTCP"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (false)); // DCMPTCP should be false!
-      source.SetAttribute ("CongestionControl", StringValue ("RTT_Compensator"));
-    }
-  else if (g_flowType == "XFC")
-    {
-      g_cc_tmp = g_cc;
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("XFC"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (true));
-      source.SetAttribute ("CongestionControl", StringValue (g_cc));
-    }
-  else if (g_flowType == "DCTCP")
-    {
-      g_cc_tmp = "Uncoupled_TCPs";
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("DCTCP"));
-      source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-    }
-  else if (g_flowType == "ECN")
-    {
-      g_cc_tmp = "Uncoupled_TCPs";
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("ECN"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (true));
-      source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-    }
-  else if (g_flowType == "TCP")
-    {
-      g_cc_tmp = "Uncoupled_TCPs";
-      source.SetAttribute ("DCTCP", BooleanValue (false));
-      source.SetAttribute ("SocketModel", StringValue ("TCP"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (false));
-      source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-    }
-  else if (g_flowType == "MPTCP")
-    {
-      g_cc_tmp = g_cc;
-      source.SetAttribute ("DCTCP", BooleanValue (false));
-      source.SetAttribute ("SocketModel", StringValue ("MPTCP"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (false));
-      source.SetAttribute ("CongestionControl", StringValue (g_cc));
-    }
-  return g_flowType;
-}
-
-string
-SetupSpecialSource (MpTcpBulkSendHelper& source, uint32_t i)
-{
-  if (g_specialSubflow)
-    {
-      source.SetAttribute ("MaxSubflows", UintegerValue (g_subflows));
-      cout << "Setup Special Source SF[" << g_subflows << "] -> ";
-    }
-  else
-    {
-      source.SetAttribute ("MaxSubflows", UintegerValue (1));
-      cout << "Setup Special Source SF[" << 1 << "] -> ";
-    }
-  if (g_specialFlowType == "XMP")
-    {
-      g_cc_tmp = "XMP";
-      source.SetAttribute ("DCTCP", BooleanValue (false));
-      source.SetAttribute ("CongestionControl", StringValue ("XMP"));
-      source.SetAttribute ("SocketModel", StringValue ("XMP"));
-    }
-  else if (g_specialFlowType == "XFC")
-    {
-      g_cc_tmp = g_cc;
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("XFC"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (true));
-      source.SetAttribute ("CongestionControl", StringValue (g_cc));
-    }
-  else if (g_specialFlowType == "DCMPTCP")
-    {
-      g_cc_tmp = "RTT_Compensator";
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("DCMPTCP"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (false)); // DCMPTCP should be false!
-      source.SetAttribute ("CongestionControl", StringValue ("RTT_Compensator"));
-    }
-  else if (g_specialFlowType == "DCTCP")
-    {
-      g_cc_tmp = "Uncoupled_TCPs";
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("DCTCP"));
-      source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-    }
-  else if (g_specialFlowType == "ECN")
-    {
-      g_cc_tmp = "Uncoupled_TCPs";
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("ECN"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (true));
-      source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-    }
-  else if (g_specialFlowType == "TCP")
-    {
-      g_cc_tmp = "Uncoupled_TCPs";
-      source.SetAttribute ("DCTCP", BooleanValue (false));
-      source.SetAttribute ("SocketModel", StringValue ("TCP"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (false));
-      source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-    }
-  return g_specialFlowType;
-}
-
-uint32_t
-GetYrange()
-{
-  if (g_queueModeBytes)
-      return (1400 * g_REDQueueLimit);
-  else
-    return g_REDQueueLimit;
-}
-
-uint32_t
-GetXrange()
-{
-  return g_simTime;
-}
-
-string
-GetQueueMode()
-{
-  if (g_queueModeBytes)
-    return "QMB";
-  else
-    return "QMP";
-}
-
-//"MPTCP_INCAST_240_SF8_1";
-string
-SetupSimFileName(uint32_t i)
-{
-  ostringstream oss;
-  oss.str ("");
-//oss << g_simName << "_" << g_scenario << "_"<< ConvertCC (g_cc) << "_" << "B" << g_XmpBeta << "_" << "K" << g_REDmaxTh << "_" << g_rtt << "_" << "SF" << g_subflows <<"_" << i << ".data";
-  if (g_specialSource)
-    oss << g_scenario << "_"  << "CM"<< g_cwndMin << "_" << g_specialFlowType << "_" << g_flowType << "_DS" << g_dynamicSubflow << "_IT" << g_incastThreshold << "_IET" << g_incastExitThreshold << "_FN" <<  g_flowNumber << "_SFN"<< g_specialFlowNumber << "_" << "FG" << g_flowgap*1000000 << g_simName  << "_" << "B" << g_XmpBeta << "_" << GetQueueMode() << "_" <<  "K" << g_REDmaxTh << "_" << g_rtt << "_ST" << g_simTime << "_" << "SF" << g_subflows <<"_" << i << ".data";
-  else
-    oss << g_scenario << "_"  << "CM"<< g_cwndMin << "_" << g_flowType << "_DS" << g_dynamicSubflow << "_IT" << g_incastThreshold << "_IET"<< g_incastExitThreshold << "_FN" <<  g_flowNumber <<"_SFN"<< g_specialFlowNumber << "_" << "FG" <<  g_flowgap*1000000 << g_simName  << "_" << "B" << g_XmpBeta << "_" << GetQueueMode() << "_" <<  "K" << g_REDmaxTh << "_" << g_rtt << "_ST" << g_simTime << "_" << "SF" << g_subflows <<"_" << i << ".data";
-  string tmp = oss.str();
-  oss.str("");
-  return tmp;
-}
-
-void
-SimTimeMonitor ()
-{
-  NS_LOG_UNCOND("ClockTime: " << Simulator::Now().GetSeconds());
-  double now = Simulator::Now ().GetSeconds ();
-  cout << "[" << SetupSimFileName(0) << "] -> SimClock: " << now << endl;
-  if (now < g_simTime)
-    Simulator::Schedule (Seconds (1), &SimTimeMonitor);
-}
-
-string
-SetupQueueFileName()
-{
-  ostringstream oss;
-  oss.str ("");
-//oss << g_simName << "_" << g_scenario << "_"<< ConvertCC (g_cc) << "_" << "B" << g_XmpBeta << "_" << "K" << g_REDmaxTh << "_" << g_rtt << "_" << "SF" << g_subflows;
-  if (g_specialSource)
-    oss << g_scenario << "_" << "CM" << g_cwndMin << "_" << g_specialFlowType << "_" << g_flowType << "_DS" << g_dynamicSubflow << "_IT" << g_incastThreshold << "_IET" << g_incastExitThreshold << "_FN" << g_flowNumber << "_SFN"<< g_specialFlowNumber << "_" << "FG" <<  g_flowgap*1000000 << g_simName << "_" << "B" << g_XmpBeta << "_" << GetQueueMode() << "_" << "K" << g_REDmaxTh << "_" << g_rtt << "_ST" << g_simTime << "_" << "SF" << g_subflows;
-  else
-    oss << g_scenario << "_" << "CM" << g_cwndMin << "_" << g_flowType << "_DS" << g_dynamicSubflow << "_IT" << g_incastThreshold << "_IET" << g_incastExitThreshold << "_FN" << g_flowNumber << "_SFN"<< g_specialFlowNumber << "_" << "FG" <<  g_flowgap*1000000 << g_simName << "_" << "B" << g_XmpBeta << "_" << GetQueueMode() << "_" << "K" << g_REDmaxTh << "_" << g_rtt << "_ST" << g_simTime << "_" << "SF" << g_subflows;
-  string tmp = oss.str();
-  oss.str("");
-  return tmp;
-}
-
-string
-IsActive (uint32_t boolean)
-{
-  if (boolean == 0)
-    return "Inactive";
-  else
-    return "Active";
-}
-
-Ptr<Queue>
-FindQueue (Ptr<NetDevice> dev)
-{
-  PointerValue ptr;
-  dev->GetAttribute ("TxQueue", ptr);
-  return ptr.Get<Queue> ();
-}
-
-std::string
-GeneratePlotDetail (void)
-{
-  stringstream oss;
-  oss << "LR [" << g_linkCapacity << "] LD [" << g_linkDelay << "] QL [" << g_REDQueueLimit << "pkts] AvgPktSize ["
-      << g_REDMeanPktSize << "bytes] MinTh [" << g_REDminTh << "] MaxTh [" << g_REDmaxTh << "]\\n RedW [" << g_REDWeight
-      << "] Gentle [" << IsActive (g_REDGentle) << "] DctcpW [" << g_DCTCPWeight << "] SimDur [" << g_simTime << "] simName["
-      << g_simName << "] SamInterval[" << g_samplingInterval << "]";
-  string tmp = oss.str ();
-  oss.str ("");
-  return tmp;
-}
-
-void
-QueueMonitor ()
-{
-  uint32_t T = (uint32_t) Simulator::Now ().GetSeconds ();
-  Ptr<Queue> txQueue = FindQueue (Core_c.Get (0)->GetDevice (Sender_c.GetN()+1));
-  if (g_queueModeBytes)
-    RedTxQueue.push_back (make_pair (Simulator::Now ().GetSeconds (), txQueue->GetNBytes ()));
-  else
-    RedTxQueue.push_back (make_pair (Simulator::Now ().GetSeconds (), txQueue->GetNPackets ()));
-
-  txQueue->ResetStatistics ();
-
-  if (T < g_simTime)
-    Simulator::Schedule (Seconds (g_samplingInterval), &QueueMonitor);
-}
-
-bool
-sortbysec (const pair<double, double> &a, const pair<double, double> &b)
-{
-  return (a.second < b.second);
-}
-void
-GenerateQueueCDFPlot ()
-{
-  string file = SetupQueueFileName() + "_QUEUE_CDF.data";
-  Ptr<OutputStreamWrapper> stream = Create<OutputStreamWrapper> (file, std::ios::out);
-  ostream* os = stream->GetStream ();
-
-  std::sort(RedTxQueue.begin (), RedTxQueue.end(), sortbysec);
-  for (uint32_t i = 0; i < RedTxQueue.size(); i++)
-    *os << (i + 1) / (double)RedTxQueue.size() << "\t" << RedTxQueue[i].second << endl;
-}
-
-//<< "set output \"fairnessOutput.eps\"\n"
-void
-GenerateQueuePlot ()
-{
-  Gnuplot queueTracerGraph;
-  ostringstream oss;
-  oss << "set terminal postscript eps noenhanced color solid font 'Times-Bold,30'\n"
-      << "set output\""
-      << SetupQueueFileName() << "_QUEUE.eps" << "\"\n"
-      << "set xlabel \"Time (s)\"           offset 0,0.8,0\n"
-      << "set ylabel \"Queue Size (pkts)\"  offset 3,0.0,0\n"
-      << "set lmargin 5.0\n"
-      << "set rmargin 1.5\n"
-      << "set tmargin 1.0\n"
-      << "set bmargin 2.5\n"
-      << "set yrange [:" << GetYrange() << "]\n"
-      << "set xrange [:" << GetXrange() << "]\n"
-      << "set xtics offset 0,0.3,0 nomirror\n"
-      << "set ytics offset 0.3,0,0 nomirror\n"
-      << "set mytics 2\n"
-      << "set mxtics 2\n"
-      << "set title font ',20' offset 0,-0.6,0 noenhanced\n"
-      << "unset grid\n"
-      << "unset key\n";
-  queueTracerGraph.AppendExtra (oss.str()
-  /*"set key bmargin center horizontal Left reverse noenhanced autotitles columnhead nobox\n"*/);
-  oss.str("");
-  oss << SetupQueueFileName();
-  queueTracerGraph.SetTitle (oss.str());
-//queueTracerGraph.SetTitle ("RedQueue \\n\\n" + GeneratePlotDetail ());
-
-  Gnuplot2dDataset dataSet;
-  dataSet.SetStyle (Gnuplot2dDataset::LINES_POINTS);
-//  std::stringstream title;
-//  title << "QueueSize ";
-//  dataSet.SetTitle (title.str ());
-  vector<pair<double, double> >::iterator it = RedTxQueue.begin ();
-  while (it != RedTxQueue.end ())
-    {
-      dataSet.Add (it->first, it->second);
-      it++;
-    }
-  if (RedTxQueue.size () > 0)
-    queueTracerGraph.AddDataset (dataSet);
-  gnu.AddPlot (queueTracerGraph);
-
-  string file = SetupQueueFileName() + "_QUEUE.data";
-  Ptr<OutputStreamWrapper> stream = Create<OutputStreamWrapper> (file, std::ios::out);
-  ostream* os = stream->GetStream ();
-  gnu.GenerateOutput (*os);
-}
-
-void
-PrintParams ()
-{
-  cout << "-------------------------" << endl;
-  cout << "FlowType[" << g_flowType << "] FlowNumber[" << g_flowNumber <<"] FlowGap[" <<g_flowgap << "] SF[" << g_subflows << "] QMB[" << IsActive (g_queueModeBytes) << "]" << endl;
-  cout << "Red[" << IsActive (g_enableRED) << "] " << "K[" << g_REDmaxTh << "] QueueSampling[" << g_samplingInterval<< "] SimEnd[" << g_simTime << "]" << endl;
-  cout << "SpecialSource[" << IsActive(g_specialSource) << "] SpecialFlowNum[" << g_specialFlowNumber << "] SpecialFlowType[" << g_specialFlowType <<"] SpecialSubflow[" << IsActive(g_specialSubflow) << "]"<< endl;
-  cout << "CwndMin[" << g_cwndMin << "] RwndScale[" << g_rwndScale << "] Default_CC[" << g_cc << "]"<< endl;
-  cout << "DynamicSubflow[" << IsActive(g_dynamicSubflow) << "] IncastThresh[" << g_incastThreshold << "] IncastExitThresh[" << g_incastExitThreshold << "]" << endl;
-  cout << "FlowEndTimeGap[" << g_flowEndTimeGap << "]" << endl;
-  cout << "IncastInterval[" << g_enabledIncastInterval <<"] Interval[" << g_incastIntervalTime << "]" << endl;
-  cout << "-------------------------" << endl;
-}
-
-void
-FlowSchedulerNormal()
-{
-  cout << "FlowSchedulerNormal" << endl;
-  for (uint32_t i = 0; i < g_flowNumber; i++)
-    {
-      string tmpFlowType = "";
-      MpTcpBulkSendHelper source ("ns3::TcpSocketFactory", InetSocketAddress (GetIpAddr(Receiver_c, 0), servPort));
-      source.SetAttribute ("FlowId", UintegerValue (i + 1));
-      source.SetAttribute ("MaxBytes", UintegerValue (g_flowSize));
-
-      if (g_specialSource && i < g_specialFlowNumber)
-        tmpFlowType = SetupSpecialSource (source , i);
-      else
-        tmpFlowType = SetupSource (source, i);
-
-      source.SetAttribute ("OutputFileName", StringValue (SetupSimFileName (i + 1)));
-      ApplicationContainer sourceApps = source.Install (Sender_c.Get (i));
-      sourceApps.Start (Seconds (i * g_flowgap));
-      sourceApps.Stop (Seconds (g_simTime));
-      if (g_specialSource && i >= g_specialFlowNumber)
-        { // Adjust the flow end time for the non-special flows (i.e. DCTCP)
-          sourceApps.Start (Seconds (i * g_flowgap));
-          sourceApps.Stop (Seconds (g_simTime - g_flowEndTimeGap));
-        }
-      cout << "Flow " << i << " [" << tmpFlowType << "] Size[" << g_flowSize << "] CC[" << g_cc_tmp << "] Installed on server " << i << " [" << GetIpAddr (Sender_c, i) << " -> "
-          << GetIpAddr (Receiver_c, 0) << "] start at " << i * g_flowgap << endl;
-    }
-}
-
-void
-FlowSchedulerIncastInterval()
-{
-  cout << "FlowSchedulerIncastInterval" << endl;
-  for (uint32_t i = 0; i < g_flowNumber; i++)
-    {
-      string tmpFlowType = "";
-      MpTcpBulkSendHelper source ("ns3::TcpSocketFactory", InetSocketAddress (GetIpAddr (Receiver_c, 0), servPort));
-
-      source.SetAttribute ("MaxBytes", UintegerValue (g_flowSize));
-      source.SetAttribute ("FlowType", StringValue ("Large"));
-      if (g_singleFileIncast)
-        { // Results are stored in a single file
-          source.SetAttribute ("FlowId", UintegerValue (1));
-          source.SetAttribute ("OutputFileName", StringValue (SetupSimFileName (1)));
-        }
-      else
-        {
-          g_incastFlowCount++; // Increase flow counter for each new flow
-          source.SetAttribute ("FlowId", UintegerValue (g_incastFlowCount));
-          source.SetAttribute ("OutputFileName", StringValue (SetupSimFileName (g_incastFlowCount)));
-        }
-
-      if (g_specialSource && i < g_specialFlowNumber)
-        tmpFlowType = SetupSpecialSource (source, i);
-      else
-        tmpFlowType = SetupSource (source, i);
-
-      ApplicationContainer sourceApps = source.Install (Sender_c.Get (i));
-      sourceApps.Start (Seconds (i * g_flowgap));
-      sourceApps.Stop (Seconds (g_simTime));
-      if (g_specialSource && i >= g_specialFlowNumber)
-        { // Adjust the flow end time for the non-special flows (i.e. DCTCP)
-          sourceApps.Start (Seconds (i * g_flowgap));
-          sourceApps.Stop (Seconds (g_simTime - g_flowEndTimeGap));
-        }
-      cout << "Flow " << i << " [" << tmpFlowType << "] Size[" << g_flowSize << "] CC[" << g_cc_tmp << "] Installed " << i << " ["
-          << GetIpAddr (Sender_c, i) << " -> " << GetIpAddr (Receiver_c, 0) << "] start at "
-          << Simulator::Now ().GetSeconds () + (i * g_flowgap) << endl;
-    }
-  if (g_enabledIncastInterval && (Simulator::Now ().GetSeconds () <= g_simTime - g_incastIntervalTime))
-    {
-      cout << "IncastIntervalTime: " << Simulator::Now ().GetSeconds () + g_incastIntervalTime << " seconds" << endl;
-      Simulator::Schedule (Seconds (g_incastIntervalTime), &FlowSchedulerIncastInterval);
-    }
-}
-
-bool
-SetSimName (std::string input)
-{
-  cout << "SimName          : " << g_simName << " -> " << input << endl;
-  g_simName = input;
-  return true;
-}
-
-bool
-SetSimInstance (std::string input)
-{
-  cout << "SimInstance      : " << g_simInstance << " -> " << input << endl;
-  g_simInstance = input;
-  return true;
-}
-
-bool
-SetRatePlot (std::string input)
-{
-  cout << "RatePlotting     : " << g_enableRatePlotting << " -> " << input << endl;
-  g_enableRatePlotting = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetRateBeat (std::string input)
-{
-  cout << "RateBeat         : " << g_rateBeat << " -> " << input << endl;
-  g_rateBeat = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetLfPlot (std::string input)
-{
-  cout << "LargeFlowPlotting: " << g_enableLfPlotting << " -> " << input << endl;
-  g_enableLfPlotting = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetSfPlot (std::string input)
-{
-  cout << "ShortFlowPlotting: " << g_enableSfPlotting << " -> " << input << endl;
-  g_enableSfPlotting = atoi (input.c_str ());
-  return true;
-}
-bool
-SetRED (std::string input)
-{
-  cout << "Enable RED Queue : " << g_enableRED << " -> " << input << endl;
-  g_enableRED = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetDCTCP (std::string input)
-{
-  cout << "Enable DCTCP     : " << g_enableDCTCP << " -> " << input << endl;
-  g_enableDCTCP = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetREDmin (std::string input)
-{
-  cout << "RED Min Threshold: " << g_REDminTh << " -> " << input << endl;
-  g_REDminTh = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetREDmax (std::string input)
-{
-  cout << "RED Max Threshold: " << g_REDmaxTh << " -> " << input << endl;
-  g_REDmaxTh = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetDCTCPweight (std::string input)
-{
-  cout << "DCTCP Weight     : " << g_DCTCPWeight << " -> " << input << endl;
-  g_DCTCPWeight = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetREDweight (std::string input)
-{
-  cout << "RED Max Weight   : " << g_REDWeight << " -> " << input << endl;
-  g_REDWeight = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetREDQueueLimit (std::string input)
-{
-  cout << "RED Queue Limit  : " << g_REDQueueLimit << " -> " << input << endl;
-  g_REDQueueLimit = atof (input.c_str ());
-  return true;
-}
-bool
-SetSimTime (std::string input)
-{
-  cout << "SimDuration      : " << g_simTime << " -> " << input << endl;
-  g_simTime = atof (input.c_str ());
-  return true;
-}
-bool
-SetNetAnim (std::string input)
-{
-  cout << "NetAnim          : " << g_enableAnim << " -> " << input << endl;
-  g_enableAnim = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetXmpGamma (std::string input)
-{
-  cout << "XMP's Gamma      : " << g_XmpGamma << " -> " << input << endl;
-  g_XmpGamma = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetXmpBeta (std::string input)
-{
-  cout << "XMP's Beta       : " << g_XmpBeta << " -> " << input << endl;
-  g_XmpBeta = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetCongestionControl (std::string input)
-{
-  cout << "CongestionControl: " << g_cc << " -> " << input << endl;
-  g_cc = input;
-  if (g_cc == "XMP")
-    {
-      g_enableDCTCP = false;
-      g_SDEL = false;
-    }
-  return true;
-}
-
-bool
-SetNumSubflow (std::string input)
-{
-  cout << "Subflows         : " << g_subflows << " -> " << input << endl;
-  g_subflows = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetLinkDelay (std::string input)
-{
-  cout << "LinkDelay        : " << g_linkDelay << " -> " << input+"us" << endl;
-  g_linkDelay = input+"us";
-  g_rtt = 4*Time(g_linkDelay).GetMicroSeconds();
-  return true;
-}
-bool
-SetECN (std::string input)
-{
-  cout << "ECN              : " << g_ecn << " -> " << input << endl;
-  g_ecn = atoi (input.c_str ());
-  return true;
-}
-bool
-SetSDXL (std::string input)
-{
-  cout << "SlowDownXMPLike  : " << g_slowDownXmpLike << " -> " << input << endl;
-  g_slowDownXmpLike = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetQueueMode (std::string input)
-{
-  cout << "QueueModeBytes   : " << g_queueModeBytes << " -> " << input << endl;
-  g_queueModeBytes = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetQueueSamplingInterval (std::string input)
-{
-  cout << "QueueSamplingInte: " << g_samplingInterval << " -> " << input << endl;
-  g_samplingInterval = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetDctcpAlphaPerAck (std::string input)
-{
-  cout << "DctcpAlphaPerAck : " << g_dctcpAlphaPerAck << " -> " << input << endl;
-  g_dctcpAlphaPerAck = atoi (input.c_str ());
-  return true;
-}
-bool
-SetDctcpFastAlpha (std::string input)
-{
-  cout << "DctcpFastAlpha   : " << g_dctcpFastAlpha << " -> " << input << endl;
-  g_dctcpFastAlpha = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetDTQMarkTh(std::string input)
-{
-  cout << "DTQmarkTh        : " << g_DTQmarkTh << " -> " << input << endl;
-  g_DTQmarkTh = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetFlowGap(std::string input)
-{
-  cout << "FlowGap          : " << g_flowgap << " -> " << input << endl;
-  g_flowgap = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetSDEL(std::string input)
-{
-  cout << "SDXL::ECN        : " << g_SDEL << " -> " << input << endl;
-  g_SDEL = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetFlowType (std::string input)
-{
-  cout << "FlowType         : " << g_flowType << " -> " << input << endl;
-  g_flowType = input.c_str ();
-  return true;
-}
-
-bool
-SetFlowNumber (std::string input)
-{
-  cout << "FlowNumber       : " << g_flowNumber << " -> " << input << endl;
-  g_flowNumber = atoi (input.c_str ());
-  g_senders = g_flowNumber;
-  cout << "Update # senders : " << g_senders   << endl;
-  return true;
-}
-
-bool
-SetSpecialFlowNumber (std::string input)
-{
-  cout << "SpecialFlowNumber: " << g_specialFlowNumber << " -> " << input << endl;
-  g_specialFlowNumber = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetSpecialFlowType (std::string input)
-{
-  cout << "SpecialFlowType  : " << g_specialFlowType << " -> " << input << endl;
-  g_specialFlowType = input.c_str ();
-  return true;
-}
-
-bool
-SetSpecialSource (std::string input)
-{
-  cout << "SpecialSource    : " << g_specialSource << " -> " << input << endl;
-  g_specialSource = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetRcwndScale (std::string input)
-{
-  cout << "RwndScale        : " << g_rwndScale << " -> " << input << endl;
-  g_rwndScale = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetCwndMin (std::string input)
-{
-  cout << "CwndMin          : " << g_cwndMin << " -> " << input << endl;
-  g_cwndMin = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetSpecialSubflow (std::string input)
-{
-  cout << "SpecialSubflow   : " << g_specialSubflow << " -> " << input << endl;
-  g_specialSubflow = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetDynamicSubflow (std::string input)
-{
-  cout << "DynamicSubflow   : " << g_dynamicSubflow << " -> " << input << endl;
-  g_dynamicSubflow = atoi (input.c_str ());
-  return true;
-}
-bool
-SetIncastExitThreshold (std::string input)
-{
-  cout << "IncastExitThresh : " << g_incastExitThreshold << " -> " << input << endl;
-  g_incastExitThreshold = atoi (input.c_str ());
-  return true;
-}
-bool
-SetIncastThreshold (std::string input)
-{
-  cout << "Incast Threshold : " << g_incastThreshold << " -> " << input << endl;
-  g_incastThreshold = atoi (input.c_str ());
-  return true;
-}
-bool
-SetSenders (std::string input)
-{
-  cout << "No. Senders      : " << g_senders << " -> " << input << endl;
-  g_senders = atoi (input.c_str ());
-  return true;
-}
-bool
-SetLinkRate(std::string input)
-{
-  cout << "Link rate        : " << g_linkCapacity << " -> " << input+"Mbps" << endl;
-  g_linkCapacity = input+"Mbps";
-  return true;
-}
-bool
-SetFlowEndTimeGap (std::string input)
-{
-  cout << "FlowEndTimeGap    : " << g_flowEndTimeGap << " -> " << input << endl;
-  g_flowEndTimeGap = atof (input.c_str ());
-  return true;
-}
-bool
-SetFlowSize(std::string input)
-{
-  cout << "FlowSize         : " << g_flowSize << " -> " << input << endl;
-  g_flowSize = atoi(input.c_str()) * 1024; // convert from b to Kb
-  return true;
-}
-bool
-SetIncastInterval(std::string input)
-{
-  cout << "EnableIncastInter: " << g_enabledIncastInterval << " -> " << input << endl;
-  g_enabledIncastInterval = atoi(input.c_str());
-  return true;
-}
-bool
-SetIncastIntervalTime(std::string input)
-{
-  cout << "IncastInterTime  : " << g_incastIntervalTime << " -> " << input << endl;
-  g_incastIntervalTime = atof(input.c_str());
-  return true;
-}
-bool
-SetSingleFileIncast(std::string input)
-{
-  cout << "SingleFileIncast : " << g_singleFileIncast << " -> " << input << endl;
-  g_singleFileIncast = atoi(input.c_str());
-  return true;
-}
-
-
-int
-main (int argc, char *argv[])
-{
-  // Add some logging
-  LogComponentEnable ("incast", LOG_ALL);
-
-  // First record of RedTxQueue container, should be 0 because Gnuplot is mad!!
-  RedTxQueue.push_back (make_pair (Simulator::Now ().GetSeconds (), 0));
-
-  CommandLine cmd;
-  cmd.AddValue("sfi", "SingleFileIncast", MakeCallback(SetSingleFileIncast));
-  cmd.AddValue("iit", "IncastIntervalTime", MakeCallback(SetIncastIntervalTime));
-  cmd.AddValue("ii", "IncastInterval", MakeCallback(SetIncastInterval));
-  cmd.AddValue("fs", "Flow Size", MakeCallback(SetFlowSize));
-  cmd.AddValue("fetg", "Flow end time gap", MakeCallback(SetFlowEndTimeGap));
-  cmd.AddValue("lr", "Set p2p link rate", MakeCallback(SetLinkRate));
-  cmd.AddValue ("senders", "No. of senders", MakeCallback (SetSenders));
-  cmd.AddValue ("iet", "Incast Threshold ",MakeCallback(SetIncastExitThreshold));
-  cmd.AddValue ("it", "Incast Threshold ", MakeCallback(SetIncastThreshold));
-  cmd.AddValue ("ds", "Dynamic Subflow ", MakeCallback(SetDynamicSubflow));
-  cmd.AddValue ("cwndmin", "Flows", MakeCallback (SetCwndMin));
-  cmd.AddValue ("rwndscale", "Flows", MakeCallback (SetRcwndScale));
-  cmd.AddValue ("ssf", "Special subflow", MakeCallback (SetSpecialSubflow));
-  cmd.AddValue ("ss",  "Special Source Active", MakeCallback (SetSpecialSource));
-  cmd.AddValue ("sft", "Special FlowType", MakeCallback (SetSpecialFlowType));
-  cmd.AddValue ("sfn", "Special FlowNumber", MakeCallback (SetSpecialFlowNumber));
-  cmd.AddValue ("fn", "Flows", MakeCallback(SetFlowNumber));
-  cmd.AddValue ("ft", "FlowType", MakeCallback(SetFlowType));
-  cmd.AddValue ("sdel", "Set SlowDownEcnLike -- ECN", MakeCallback(SetSDEL));
-  cmd.AddValue ("fg", "Flow Gap", MakeCallback(SetFlowGap));
-  cmd.AddValue ("dtqmt", "DropTailQueue Marking Threshold", MakeCallback(SetDTQMarkTh));
-  cmd.AddValue ("dfa", " DCTCP Non-Smoothed Alpha", MakeCallback (SetDctcpFastAlpha));
-  cmd.AddValue ("dapa", "DCTCP ALPHA PER ACK", MakeCallback (SetDctcpAlphaPerAck));
-  cmd.AddValue ("qsi", "queue sampling interval", MakeCallback (SetQueueSamplingInterval));
-  cmd.AddValue ("qmb", "QUEUE_MODE_BYTES", MakeCallback (SetQueueMode));
-  cmd.AddValue ("sdxl", " slow down xmp like", MakeCallback (SetSDXL));
-  cmd.AddValue ("ecn", " enable ECN", MakeCallback (SetECN));
-  cmd.AddValue ("ld", " Set Link Delay", MakeCallback (SetLinkDelay));
-  cmd.AddValue ("sim", "Set sim name", MakeCallback (SetSimName));
-  cmd.AddValue ("sf", "Number of MPTCP SubFlows", MakeCallback (SetNumSubflow));
-  cmd.AddValue ("i", "Set simulation instance number as a string", MakeCallback (SetSimInstance));
-  cmd.AddValue ("red", "Enable RED Queue Disiplone", MakeCallback (SetRED));
-  cmd.AddValue ("dctcp", "Enable DCTCP Capability", MakeCallback (SetDCTCP));
-  cmd.AddValue ("redmax", "RED Max Threshold", MakeCallback (SetREDmax));
-  cmd.AddValue ("redmin", "RED min Threshold", MakeCallback (SetREDmin));
-  cmd.AddValue ("redql", "RED Queue Limit", MakeCallback (SetREDQueueLimit));
-  cmd.AddValue ("redweight", "RED Weight", MakeCallback (SetREDweight));
-  cmd.AddValue ("DCTCPweight", "DCTCP Weight", MakeCallback (SetDCTCPweight));
-  cmd.AddValue ("lfplot", "Activate plotting at MpTcpSocketBase", MakeCallback (SetLfPlot));
-  cmd.AddValue ("sfplot", "Activate short flow plotting at MpTcpSocketBase", MakeCallback (SetSfPlot));
-  cmd.AddValue ("st", "Simulation Time", MakeCallback (SetSimTime));
-  cmd.AddValue ("na", "NetAnim: 1=enable, 0=disable", MakeCallback (SetNetAnim));
-  cmd.AddValue ("cc", "MPTCP Congestion Control algorithm", MakeCallback (SetCongestionControl));
-  cmd.AddValue ("gamma", " XMP's gamma", MakeCallback (SetXmpGamma));
-  cmd.AddValue ("beta", " XMP's beta", MakeCallback (SetXmpBeta));
-  cmd.AddValue ("rateplot", " Activate Rate Plotting", MakeCallback (SetRatePlot));
-  cmd.AddValue ("ratebeat", " Activate Rate Plotting", MakeCallback (SetRateBeat));
-
-  cmd.Parse (argc, argv);
-  Config::SetDefault ("ns3::MpTcpSocketBase::IncastExitThresh", UintegerValue(g_incastExitThreshold));
-  Config::SetDefault ("ns3::MpTcpSocketBase::IncastThresh", UintegerValue(g_incastThreshold));
-  Config::SetDefault ("ns3::MpTcpSocketBase::DynamicSubflow", BooleanValue(g_dynamicSubflow));
-  Config::SetDefault ("ns3::MpTcpSocketBase::CwndMin", UintegerValue (g_cwndMin));
-  Config::SetDefault ("ns3::MpTcpSocketBase::RwndScale", UintegerValue (g_rwndScale));
-  Config::SetDefault ("ns3::MpTcpSocketBase::DctcpAlphaPerAck", BooleanValue (g_dctcpAlphaPerAck)); //SHOULD BE FALSE!!!
-  Config::SetDefault ("ns3::MpTcpSocketBase::SlowDownXmpLike", BooleanValue (g_slowDownXmpLike));
-  Config::SetDefault ("ns3::MpTcpSocketBase::ECN", BooleanValue (g_ecn));
-  Config::SetDefault ("ns3::MpTcpSocketBase::LargePlotting", BooleanValue (g_enableLfPlotting));
-  Config::SetDefault ("ns3::MpTcpSocketBase::ShortPlotting", BooleanValue (g_enableSfPlotting));
-  Config::SetDefault ("ns3::MpTcpSocketBase::RatePlotSf", BooleanValue (g_enableRatePlotting));
-  Config::SetDefault ("ns3::MpTcpSocketBase::RatePlotCl", BooleanValue (g_enableRatePlotting));
-  Config::SetDefault ("ns3::MpTcpSocketBase::RateInterval", DoubleValue (g_rateBeat));
-  Config::SetDefault ("ns3::MpTcpSocketBase::RandomGap", UintegerValue (50));
-  Config::SetDefault ("ns3::DropTailQueue::Mode", StringValue ("QUEUE_MODE_PACKETS"));
-  Config::SetDefault ("ns3::DropTailQueue::MaxPackets", UintegerValue (100));
-//Config::SetDefault ("ns3::DropTailQueue::Marking", BooleanValue(g_enableDCTCP));
-//Config::SetDefault ("ns3::DropTailQueue::MarkingTh", UintegerValue(g_DTQmarkTh));
-  if (g_enabledIncastInterval)
-    {// Goodput of LFs should be calculated when all outstanding data has been acked!
-      Config::SetDefault ("ns3::MpTcpSocketBase::BackgroundFlow", BooleanValue (false));
-    }
-
-  if (g_queueModeBytes)
-    { // DropTailQueue
-    //Config::SetDefault("ns3::DropTailQueue::MarkingTh", UintegerValue(g_DTQmarkTh * 1400));
-      Config::SetDefault("ns3::DropTailQueue::Mode", StringValue("QUEUE_MODE_BYTES"));
-      Config::SetDefault("ns3::DropTailQueue::MaxBytes", UintegerValue(g_REDQueueLimit * 1400));
-    }
-  Config::SetDefault ("ns3::TcpSocket::SegmentSize", UintegerValue (g_segmentSize));
-  Config::SetDefault ("ns3::MpTcpSocketBase::gamma", UintegerValue (g_XmpGamma));
-  Config::SetDefault ("ns3::MpTcpSocketBase::beta", UintegerValue (g_XmpBeta));
-  Config::SetDefault ("ns3::TcpSocket::DelAckCount", UintegerValue (0));
-
-  if (g_enableDCTCP)
-    {
-      Config::SetDefault ("ns3::MpTcpSocketBase::DCTCP", BooleanValue (g_enableDCTCP));
-      Config::SetDefault ("ns3::MpTcpBulkSendApplication::DCTCP", BooleanValue (g_enableDCTCP)); // Source Control
-      Config::SetDefault ("ns3::MpTcpSocketBase::DCTCPWeight", DoubleValue (g_DCTCPWeight));
-      Config::SetDefault ("ns3::RedQueue::UseCurrent", BooleanValue (true));
-    }
-  if (g_enableRED)
-    {
-      assert (g_REDmaxTh == g_REDminTh);
-      Config::SetDefault ("ns3::RedQueue::Mode", StringValue ("QUEUE_MODE_PACKETS"));
-      Config::SetDefault ("ns3::RedQueue::MeanPktSize", UintegerValue (g_REDMeanPktSize));
-      Config::SetDefault ("ns3::RedQueue::Wait", BooleanValue (true));
-      Config::SetDefault ("ns3::RedQueue::Gentle", BooleanValue (g_REDGentle));
-      Config::SetDefault ("ns3::RedQueue::QW", DoubleValue (g_REDWeight));
-      Config::SetDefault ("ns3::RedQueue::MinTh", DoubleValue (g_REDminTh));
-      Config::SetDefault ("ns3::RedQueue::MaxTh", DoubleValue (g_REDmaxTh));
-      Config::SetDefault ("ns3::RedQueue::QueueLimit", UintegerValue (g_REDQueueLimit));
-      Config::SetDefault ("ns3::RedQueue::UseCurrent", BooleanValue (true));
-      if (g_queueModeBytes)
-        {
-          Config::SetDefault("ns3::RedQueue::Mode", StringValue("QUEUE_MODE_BYTES"));
-          Config::SetDefault("ns3::RedQueue::QueueLimit", UintegerValue(g_REDQueueLimit * 1400));
-          Config::SetDefault("ns3::RedQueue::MinTh", DoubleValue(g_REDminTh * 1400));
-          Config::SetDefault("ns3::RedQueue::MaxTh", DoubleValue(g_REDmaxTh * 1400));
-        }
-    }
-  /* Uncoupled_TCPs, Linked_Increases, RTT_Compensator, Fully_Coupled */
-  Config::SetDefault ("ns3::MpTcpSocketBase::CongestionControl", StringValue (g_cc));
-  Config::SetDefault ("ns3::MpTcpBulkSendApplication::CongestionControl", StringValue (g_cc));
-  Config::SetDefault ("ns3::Ipv4GlobalRouting::FlowEcmpRouting", BooleanValue (true));
-  Config::SetDefault ("ns3::TcpL4Protocol::SocketType", TypeIdValue (MpTcpSocketBase::GetTypeId ()));
-  Config::SetDefault ("ns3::MpTcpSocketBase::PathManagement", StringValue ("NdiffPorts"));
-  Config::SetDefault ("ns3::MpTcpSocketBase::MaxSubflows", UintegerValue (g_subflows)); // Sink
-  Config::SetDefault ("ns3::MpTcpBulkSendApplication::MaxSubflows", UintegerValue (g_subflows)); //Source
-
-  g_seed = static_cast<uint32_t> (atoi (g_simInstance.c_str ()));
-  cout << "Seed             : " << g_seed << endl;
-  srand (g_seed);
-
-  // Topology construction
-  NS_LOG_INFO("Create nodes");
-  // senders
-  Sender_c.Create(g_senders);
-  Total_c.Add(Sender_c);
-  // core switches
-  Core_c.Create(g_core_switches);
-  Total_c.Add(Core_c);
-  // receivers
-  Receiver_c.Create(g_receivers);
-  Total_c.Add(Receiver_c);
-
-  NS_LOG_INFO("Install network stack");
-  InternetStackHelper netStack;
-  netStack.Install (Total_c);
-
-  NS_LOG_INFO("Create channel");
-
-  PointToPointHelper p2p;
-  p2p.SetQueue ("ns3::DropTailQueue");
-  p2p.SetDeviceAttribute ("DataRate", StringValue (g_linkCapacity));
-  p2p.SetChannelAttribute ("Delay", StringValue (g_linkDelay));
-
-  if (g_enableRED)
-    {
-      p2p.SetQueue ("ns3::RedQueue", // only backbone link has RED queue
-          "LinkBandwidth", StringValue (g_linkCapacity), "LinkDelay", StringValue (g_linkDelay));
-      p2p.SetDeviceAttribute ("DataRate", StringValue (g_linkCapacity));
-      p2p.SetChannelAttribute ("Delay", StringValue (g_linkDelay));
-    }
-
-  // Initialized Address Helper
-  NS_LOG_INFO("Assign IP addresses");
-  Ipv4AddressHelper ipv4Address;
-
-  // Connecting Senders to Edge Switches
-  cout << "-------------------------------" << endl;
-  cout << "Sender to Core" << endl;
-  stringstream ss;
-  for (uint32_t s = 0; s < Sender_c.GetN (); s++)
-    {
-      for (uint32_t c = 0; c < Core_c.GetN (); c++)
-        {
-          ss.str ("");
-          ss << "10." << Sender_c.Get (s)->GetId () << "." << Core_c.Get (c)->GetId () << "." << "0";
-          string tmp = ss.str ();
-          cout << tmp << endl;
-          const char* address = tmp.c_str ();
-          ipv4Address.SetBase (address, "255.255.255.0");
-          ipv4Address.Assign (p2p.Install (NodeContainer (Sender_c.Get (s), Core_c.Get (c))));
-        }
-    }
-  // Connecting receiver edge switches to receivers
-  cout << "Core to Receivers" << endl;
-  for (uint32_t c = 0; c < Core_c.GetN (); c++)
-    {
-      for (uint32_t r = 0; r < Receiver_c.GetN (); r++)
-        {
-          ss.str ("");
-          ss << "10." << Core_c.Get (c)->GetId () << "." << Receiver_c.Get (r)->GetId () << "." << "0";
-          string tmp = ss.str ();
-          cout << tmp << endl;
-          const char* address = tmp.c_str ();
-          ipv4Address.SetBase (address, "255.255.255.0");
-          ipv4Address.Assign (p2p.Install (NodeContainer (Core_c.Get (c), Receiver_c.Get(r))));
-        }
-    }
-
-  NS_LOG_INFO("Install Routing tables");
-  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();
-
-  QueueMonitor ();
-
-  NS_LOG_INFO("Create Applications");
-  // MPTCP SINK
-  for (uint32_t i = 0; i < Receiver_c.GetN (); i++)
-    {
-      MpTcpPacketSinkHelper sink ("ns3::TcpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), servPort));
-      ApplicationContainer sinkApp = sink.Install (Receiver_c.Get (i));
-      sinkApp.Start (Seconds (0.0));
-    }
-
-  PrintParams();
-
-  // MPTCP SOURCE
-  if (g_enabledIncastInterval)
-    {
-      FlowSchedulerIncastInterval();
-    }
-  else
-    {
-      FlowSchedulerNormal();
-    }
-
-  // NetAnim
-  if (g_enableAnim)
-    { // Create Animation object and configure for specified output
-      AnimationInterface anim ("incast-animation", 1000000000);
-      anim.EnablePacketMetadata (true);
-    }
-
-  NS_LOG_INFO("Simulation run");
-  SimTimeMonitor();//Simulator::Schedule (Seconds (1), &SimTimeMonitor);
-  Simulator::Run ();
-  Simulator::Stop (Seconds (100));
-  GenerateQueuePlot ();
-  GenerateQueueCDFPlot ();
-  Simulator::Destroy ();
-  NS_LOG_INFO("Simulation End");
-}
diff --git a/scratch/inter-rack-large-lhu.cc b/scratch/inter-rack-large-lhu.cc
new file mode 100644
index 0000000..be307e6
--- /dev/null
+++ b/scratch/inter-rack-large-lhu.cc
@@ -0,0 +1,1082 @@
+/*
+ * Author: Enhuan Dong -A pathetic PhD student.- <deh13@mails.tsinghua.edu.cn>
+ */
+#include <ctime>
+#include <sys/time.h>
+#include <stdint.h>
+#include <fstream>
+#include <string>
+#include <cassert>
+#include <iostream>
+#include <iomanip>
+#include "ns3/log.h"
+#include "ns3/core-module.h"
+#include "ns3/network-module.h"
+#include "ns3/applications-module.h"
+#include "ns3/point-to-point-module.h"
+#include "ns3/internet-module.h"
+#include "ns3/netanim-module.h"
+#include "ns3/mobility-module.h"
+#include "ns3/callback.h"
+#include "ns3/string.h"
+
+using namespace ns3;
+NS_LOG_COMPONENT_DEFINE("Inter-Rack-Large");
+
+typedef enum
+{
+  Spine, Leaf, Host, Spine_Leaf, Spine_Leaf_Host
+} Layers_t;
+
+typedef enum
+{
+  NONE, NEW_INCAST, TYPICAL_INCAST, NEW_INCAST_BK, ONE_MAP_ONE, LHU, LHU4, LHU2
+} TrafficMatrix_t;
+
+typedef enum
+{
+  TCP, MPTCP
+} SocketType_t;
+
+
+std::map<string, TrafficMatrix_t> stringToTrafficMatrix;
+std::map<string, SocketType_t> stringToSocketType;
+vector<ApplicationContainer> sourceShortFlowApps;
+vector<ApplicationContainer> sourceLargeFlowApps;
+vector<ApplicationContainer> sinkApps;
+
+#define PORT 5000
+
+// Setup general parameters
+string g_topology = "Inter-Rack-Large";
+string g_simName  = "MPTCP_Incast";
+
+
+// Setup topology parameters
+string g_downLinkCapacity = "10Gbps";  
+string g_upLinkCapacity = "40Gbps";  //Normal
+string g_linkDelay = "25us";       
+
+uint32_t g_numSpine = 8;
+uint32_t g_numLeaf = 8;
+uint32_t g_numHost = 32;
+
+uint32_t g_flowSize = 128000;   // 128KB
+uint32_t g_shortFlowSize = 128000;
+double g_simTime = 1.0;             // 1 Seconds (default)
+uint32_t g_seed = 0;                // RNG seed
+SocketType_t g_socketType = MPTCP;
+TrafficMatrix_t g_trafficMatrix = NEW_INCAST;
+
+string g_simInstance = "0";
+string g_simStartTime = "NULL";
+uint32_t g_minRTO = 200;
+double g_flowStartTime = 0.0;
+
+uint32_t g_rGap = 50;
+// Setup MPTCP parameters
+string g_cc = "RTT_Compensator"; // Uncoupled_TCPs, Linked_Increases, Fully_Coupled, RTT_Compensator
+uint32_t g_subflows = 8;
+uint32_t g_initialCWND = 10;
+uint32_t g_slaveIW = 1;
+uint32_t g_oppo = 1;
+bool g_enableDCTCP = true;
+uint32_t g_perSubflow = 0;
+
+// For dctcp only
+double g_downLinkREDmaxTh = 65;
+double g_downLinkREDminTh = 65;
+ 
+uint32_t g_downLinkREDQueueLimit = 350;   
+
+ // Normal
+double g_upLinkREDmaxTh = 150;
+double g_upLinkREDminTh = 150;
+uint32_t g_upLinkREDQueueLimit = 1400;   
+
+uint32_t g_segmentSize = 1400;
+uint32_t g_REDMeanPktSize = g_segmentSize;
+
+
+// NodeContainer to use for link utilization and loss rate
+NodeContainer spine_c;
+NodeContainer leaf_c;
+NodeContainer host_c;
+
+//Incast
+uint32_t g_numFlow = 10;
+uint32_t g_numdctcpFlow = 10;
+
+void SimHeaderWritter(Ptr<OutputStreamWrapper> stream);
+void SimFooterWritter(Ptr<OutputStreamWrapper> stream);
+
+uint64_t
+GetLinkRate(string linkRate)
+{
+  DataRate tmp(linkRate);
+  return tmp.GetBitRate();
+}
+
+void
+SetupStringToTM()
+{
+  stringToTrafficMatrix["TYPICAL_INCAST"] = TYPICAL_INCAST;
+  stringToTrafficMatrix["NEW_INCAST"] = NEW_INCAST;
+  stringToTrafficMatrix["NEW_INCAST_BK"] = NEW_INCAST_BK;
+  stringToTrafficMatrix["ONE_MAP_ONE"] = ONE_MAP_ONE;
+  stringToTrafficMatrix["LHU"] = LHU;
+  stringToTrafficMatrix["LHU4"] = LHU4;
+  stringToTrafficMatrix["LHU2"] = LHU2;
+  stringToTrafficMatrix["NONE"] = NONE;
+}
+
+void
+SetupStringToST()
+{
+  stringToSocketType["TCP"] = TCP;
+  stringToSocketType["MPTCP"] = MPTCP;
+}
+
+
+string
+GetKeyFromValueTM(TrafficMatrix_t tm)
+{
+  map<string, TrafficMatrix_t>::const_iterator it = stringToTrafficMatrix.begin();
+  for (; it != stringToTrafficMatrix.end(); it++)
+    {
+      if (it->second == tm)
+        return it->first;
+    }
+  return "";
+}
+
+string
+GetKeyFromValueST(SocketType_t st)
+{
+  map<string, SocketType_t>::const_iterator it = stringToSocketType.begin();
+  for (; it != stringToSocketType.end(); it++)
+    {
+      if (it->second == st)
+        return it->first;
+    }
+  return "";
+}
+
+string
+SetupSimFileName(string input)
+{
+  ostringstream oss;
+  oss.str("");
+  oss << g_simName << "_" << g_topology  <<  "_MPTCP_" << GetKeyFromValueTM(g_trafficMatrix) << "_" << input << "_" << g_simInstance
+      << ".data";
+  string tmp = oss.str();
+  oss.str("");
+  return tmp;
+}
+
+
+void
+PrintSimParams()
+{
+  cout << endl;
+  cout << "Socket Type      : " << GetKeyFromValueST(g_socketType).c_str() << endl;
+  cout << "Traffic Matrix   : " << GetKeyFromValueTM(g_trafficMatrix).c_str() << endl;
+  cout << "Seed             : " << g_seed << endl;
+  cout << "Instance         : " << g_simInstance << endl;
+  cout << "DCTCP            : " << g_enableDCTCP << endl;
+  cout << "CC               : " << g_cc << endl;
+  //cout << "Incast Number    : " << g_incastNumber << endl;
+}
+
+
+
+Ptr<Queue>
+FindQueue(Ptr<NetDevice> dev)
+{
+  PointerValue ptr;
+  dev->GetAttribute("TxQueue", ptr);
+  return ptr.Get<Queue>();
+}
+
+
+string
+GetDateTimeNow()
+{
+  time_t T = time(0);
+  struct tm* now = localtime(&T);
+  string simStartDate = asctime(now);
+  return simStartDate.substr(0, 24);
+}
+
+void
+SetSimStartTime()
+{
+  g_simStartTime = GetDateTimeNow();
+}
+
+string
+GetSimStartTime()
+{
+  return g_simStartTime;
+}
+
+void
+SimHeaderWritter(Ptr<OutputStreamWrapper> stream)
+{
+  ostream *os = stream->GetStream ();
+  *os << "SimStart [" << g_simStartTime << "] simName[" << g_simName
+      << "] Topology[" << g_topology 
+      << "] SocketType[" << GetKeyFromValueST (g_socketType) 
+      << "] TrafficMatrix[" << GetKeyFromValueTM (g_trafficMatrix)
+      << "] Seed[" << g_seed << "] simInstance["
+      << g_simInstance << "] SimPeriod[" << g_simTime
+      << "s] HostPerLeaf[" << g_numHost << "] CC[" << g_cc << "] dctcp[" << g_enableDCTCP
+      << "] ShortFlowSize[" << g_shortFlowSize <<"] SubflowNum[" <<g_subflows
+      << "] upLinkRate["<< g_upLinkCapacity << "] downLinkRate["<< g_downLinkCapacity << "] LinkDelay[" << g_linkDelay
+      << "] RTOmin[ " << g_minRTO << "]" << endl;
+}
+
+void
+SimFooterWritter(Ptr<OutputStreamWrapper> stream)
+{
+  ostream *os = stream->GetStream();
+  *os << "SimEnd [" << GetDateTimeNow() << "] AllFlows[" << sourceLargeFlowApps.size() + sourceShortFlowApps.size()
+      << "] LargeFlow[" << sourceLargeFlowApps.size() << "] ShortFlows[" << sourceShortFlowApps.size()
+      << endl;
+}
+
+void
+SimResultHeaderGenerator()
+{
+  Ptr<OutputStreamWrapper> streamSimParam = Create<OutputStreamWrapper>(SetupSimFileName("RESULT"),
+      std::ios::out | std::ios::app);
+  SimHeaderWritter(streamSimParam);
+}
+
+void
+SimResultFooterGenerator()
+{
+  Ptr<OutputStreamWrapper> streamSimParam = Create<OutputStreamWrapper>(SetupSimFileName("RESULT"),
+      std::ios::out | std::ios::app);
+  SimFooterWritter(streamSimParam);
+}
+
+bool
+SetNumSubflow(std::string input)
+{
+  cout << "Subflows         : " << g_subflows << " -> " << input << endl;
+  g_subflows = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetCongestionControl(std::string input)
+{
+  cout << "CongestionControl: " << g_cc << " -> " << input << endl;
+  g_cc = input;
+  return true;
+}
+
+
+bool
+SetShortFlowSize(std::string input)
+{
+  g_shortFlowSize = atoi(input.c_str()) * 1024;
+  cout << "ShortFlowSize    : " << g_shortFlowSize << endl;
+  return true;
+}
+
+bool
+SetSimTime(std::string input)
+{
+  cout << "SimDuration      : " << g_simTime << " -> " << input << endl;
+  g_simTime = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetTrafficMatrix(std::string input)
+{
+  cout << "TrafficMatrix    : " << GetKeyFromValueTM(g_trafficMatrix) << " -> " << input << endl;
+  if (stringToTrafficMatrix.count(input) != 0)
+    {
+      g_trafficMatrix = stringToTrafficMatrix[input];
+    }
+  else
+    NS_FATAL_ERROR("Input for setting up traffic matrix has spelling issue - try again!");
+  return true;
+}
+
+bool
+SetSocketType(std::string input)
+{
+  cout << "SocketType       : " << GetKeyFromValueST(g_socketType) << " -> " << input << endl;
+  if (stringToSocketType.count(input) != 0)
+    {
+      g_socketType = stringToSocketType[input];
+    }
+  else
+    NS_FATAL_ERROR("Input for setting up socket type has spelling issue - try again!");
+  return true;
+}
+
+bool
+SetSimInstance(std::string input)
+{
+  cout << "SimInstance      : " << g_simInstance << " -> " << input << endl;
+  g_simInstance = input;
+  return true;
+}
+
+bool
+SetRTO(std::string input)
+{
+  cout << "RTO              : " << g_minRTO << " -> " << input << endl;
+  g_minRTO = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetSimName(std::string input)
+{
+  cout << "SimName          : " << g_simName << " -> " << input << endl;
+  g_simName = input;
+  return true;
+}
+
+bool
+SetIW(std::string input)
+{
+  cout << "InitalCWND       : " << g_initialCWND << " -> " << input << endl;
+  g_initialCWND = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetSlaveIW(std::string input)
+{
+  cout << "InitalSlaveCWND       : " << g_slaveIW << " -> " << input << endl;
+  g_slaveIW = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetOppo(std::string input)
+{
+  cout << "UseOppo       : " << g_oppo << " -> " << input << endl;
+  g_oppo = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetPerSubflow(std::string input)
+{
+  cout << "PerSubflow       : " << g_perSubflow << " -> " << input << endl;
+  g_perSubflow = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetFST(std::string input)
+{
+  cout << "SetFST          : " << g_flowStartTime << " -> " << input << endl;
+  g_flowStartTime = atof(input.c_str());
+  return true;
+}
+
+bool
+SetHostNumber(std::string input){
+  cout << "Host Number    : " << g_numHost << " -> " << input << endl;
+  g_numHost = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetFlowNumber(std::string input){
+  cout << "Flow Number    : " << g_numFlow << " -> " << input << endl;
+  g_numFlow = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetDCTCPFlowNumber(std::string input){
+  cout << "dctcp Flow Number    : " << g_numdctcpFlow << " -> " << input << endl;
+  g_numdctcpFlow = atoi(input.c_str());
+  return true;
+}
+
+void printNodeAddr(Ptr<Node> tmp)
+{
+  Ptr<Ipv4> ipv4Src = tmp->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+  Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+  ipv4AddressSrc.Print(cout);
+  cout << endl;
+}
+
+
+bool
+SetDCTCP (std::string input)
+{
+  cout << "Enable DCTCP     : " << g_enableDCTCP << " -> " << input << endl;
+  g_enableDCTCP = atoi (input.c_str ());
+  return true;
+}
+
+
+
+// All to one
+/*
+void
+FlowConfigForOneMapOne(const NodeContainer *host)
+{    
+  for (uint32_t j = 0; j < g_numFlow; j++)
+  {  // dst setup
+    Ptr<Node> dstNode = host[1].Get(j);
+    Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+    Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+    Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+    cout << "DST:";
+    ipv4AddressDst.Print(cout);
+    cout << endl;
+
+    Ptr<Node> srcNode = host[0].Get(j);
+    Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+    Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+    Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+    cout << "SRC:";
+    ipv4AddressSrc.Print(cout);
+    cout << endl;
+
+    // Assign flowId
+    int flowId = srcNode->GetNApplications();
+
+    // Source
+    MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+    source.SetAttribute("MaxBytes", UintegerValue(g_flowSize));
+    source.SetAttribute("FlowId", UintegerValue(flowId));
+    //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+    source.SetAttribute("FlowType", StringValue("Short"));
+    string tempString = SetupSimFileName("RESULT");
+    source.SetAttribute("OutputFileName", StringValue(tempString));
+
+    ApplicationContainer sourceApps = source.Install(srcNode);
+    sourceApps.Start (Seconds(0.0));
+    sourceApps.Stop (Seconds(g_simTime));
+
+    sourceShortFlowApps.push_back(sourceApps);
+    cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                  << Simulator::Now().GetSeconds() << " No." << j << endl;
+    }
+}
+*/
+
+
+// All to one
+/*
+void
+FlowConfigForNewIncastBK(const NodeContainer *host)
+{
+  // dst setup
+  Ptr<Node> dstNode = host[1].Get(0);
+  Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+  Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+  cout << "DST:";
+  ipv4AddressDst.Print(cout);
+  cout << endl;
+    
+  for (uint32_t j = 0; j < g_numFlow; j++)
+    {
+      Ptr<Node> srcNode = host[0].Get(j);
+      Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+      Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+      Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+      cout << "SRC:";
+      ipv4AddressSrc.Print(cout);
+      cout << endl;
+
+      // Assign flowId
+      int flowId = srcNode->GetNApplications();
+
+      // Source
+      MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+      source.SetAttribute("MaxBytes", UintegerValue(g_shortFlowSize));
+      source.SetAttribute("FlowId", UintegerValue(flowId));
+      //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+      source.SetAttribute("FlowType", StringValue("Short"));
+      string tempString = SetupSimFileName("RESULT");
+      source.SetAttribute("OutputFileName", StringValue(tempString));
+
+      ApplicationContainer sourceApps = source.Install(srcNode);
+      sourceApps.Start (Seconds(0.001));
+      sourceApps.Stop (Seconds(g_simTime));
+
+      sourceShortFlowApps.push_back(sourceApps);
+      cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                    << Simulator::Now().GetSeconds() << " No." << j << endl;
+    }
+    
+    
+  // Background flow
+  // dst setup
+  FlowConfigForOneMapOne(host);
+}
+*/
+
+// All to one without background traffic
+void FlowConfigForNewIncast(const NodeContainer *host)
+{
+  // dst setup
+  Ptr<Node> dstNode = host[1].Get(0);
+  Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+  Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+  cout << "DST:";
+  ipv4AddressDst.Print(cout);
+  cout << endl;
+    
+  for (uint32_t j = 0; j < g_numFlow; j++)
+    {
+      Ptr<Node> srcNode = host[0].Get(j);
+      Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+      Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+      Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+      cout << "SRC:";
+      ipv4AddressSrc.Print(cout);
+      cout << endl;
+
+      // Assign flowId
+      int flowId = srcNode->GetNApplications();
+
+      // Source
+      MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+      source.SetAttribute("MaxBytes", UintegerValue(g_shortFlowSize));
+      source.SetAttribute("FlowId", UintegerValue(flowId));
+      //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+      source.SetAttribute("FlowType", StringValue("Short"));
+      string tempString = SetupSimFileName("RESULT");
+      source.SetAttribute("OutputFileName", StringValue(tempString));
+
+      ApplicationContainer sourceApps = source.Install(srcNode);
+      sourceApps.Start (Seconds(0.001));
+      sourceApps.Stop (Seconds(g_simTime));
+
+      sourceShortFlowApps.push_back(sourceApps);
+      cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                    << Simulator::Now().GetSeconds() << " No." << j << endl;
+    }
+}
+
+void FlowConfigForLHU(const NodeContainer *host)
+{
+    // dst setup
+    Ptr<Node> dstNode = host[1].Get(0);
+    Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+    Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+    Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+    cout << "DST:";
+    ipv4AddressDst.Print(cout);
+    cout << endl;
+
+    Ptr<Node> srcNode = host[0].Get(0);
+    Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+    Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+    Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+    cout << "MPTCP SRC:";
+    ipv4AddressSrc.Print(cout);
+    cout << endl;
+
+    // Assign flowId
+    int flowId = srcNode->GetNApplications();
+    // Source
+    MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+    source.SetAttribute("MaxBytes", UintegerValue(g_shortFlowSize));
+    source.SetAttribute("FlowId", UintegerValue(flowId));
+    //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+    source.SetAttribute("FlowType", StringValue("Large"));
+    string tempString = SetupSimFileName("RESULT");
+    source.SetAttribute("OutputFileName", StringValue(tempString));
+
+    ApplicationContainer sourceApps = source.Install(srcNode);
+    sourceApps.Start (Seconds(0.0));
+    sourceApps.Stop (Seconds(0.5));
+
+    sourceShortFlowApps.push_back(sourceApps);
+    cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+            << Simulator::Now().GetSeconds() << endl;
+
+    
+    for (uint32_t j = 0; j < g_numdctcpFlow; j++)
+    {
+        Ptr<Node> srcNode = host[0].Get(j+1);
+        Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+        Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+        Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+        cout << "DCTCP SRC:";
+        ipv4AddressSrc.Print(cout);
+        cout << endl;
+
+        // Assign flowId
+        int flowId = srcNode->GetNApplications();
+        // Source
+        MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+        source.SetAttribute("MaxBytes", UintegerValue(g_shortFlowSize));
+        source.SetAttribute("FlowId", UintegerValue(flowId));
+        //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+        source.SetAttribute("FlowType", StringValue("Large"));
+        string tempString = SetupSimFileName("RESULT");
+        source.SetAttribute("OutputFileName", StringValue(tempString));
+
+        source.SetAttribute("DCTCP", BooleanValue (true));
+        source.SetAttribute("MaxSubflows", UintegerValue(1));
+        source.SetAttribute("CongestionControl", StringValue("Uncoupled_TCPs"));
+
+
+        ApplicationContainer sourceApps = source.Install(srcNode);
+        sourceApps.Start (Seconds(0.0));
+        sourceApps.Stop (Seconds(0.5));
+
+        sourceShortFlowApps.push_back(sourceApps);
+        cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                << Simulator::Now().GetSeconds() << endl;
+    }
+}
+
+void FlowConfigForLHU4(const NodeContainer *host)
+{
+    // dst setup
+    Ptr<Node> dstNode = host[1].Get(0);
+    Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+    Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+    Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+    cout << "DST:";
+    ipv4AddressDst.Print(cout);
+    cout << endl;
+
+
+    for (uint32_t j = 0; j < 4; j++)
+    {
+        Ptr<Node> srcNode = host[0].Get(j);
+        Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+        Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+        Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+        cout << "MPTCP SRC:";
+        ipv4AddressSrc.Print(cout);
+        cout << endl;
+
+        // Assign flowId
+        int flowId = srcNode->GetNApplications();
+        // Source
+        MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+        source.SetAttribute("MaxBytes", UintegerValue(g_shortFlowSize));
+        source.SetAttribute("FlowId", UintegerValue(flowId));
+        //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+        source.SetAttribute("FlowType", StringValue("Large"));
+        string tempString = SetupSimFileName("RESULT");
+        source.SetAttribute("OutputFileName", StringValue(tempString));
+
+        ApplicationContainer sourceApps = source.Install(srcNode);
+        sourceApps.Start (Seconds(0.0));
+        sourceApps.Stop (Seconds(0.5));
+
+        sourceShortFlowApps.push_back(sourceApps);
+        cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                << Simulator::Now().GetSeconds() << endl;
+    }
+    
+    for (uint32_t j = 0; j < g_numdctcpFlow; j++)
+    {
+        Ptr<Node> srcNode = host[0].Get(j+4);
+        Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+        Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+        Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+        cout << "DCTCP SRC:";
+        ipv4AddressSrc.Print(cout);
+        cout << endl;
+
+        // Assign flowId
+        int flowId = srcNode->GetNApplications();
+        // Source
+        MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+        source.SetAttribute("MaxBytes", UintegerValue(g_shortFlowSize));
+        source.SetAttribute("FlowId", UintegerValue(flowId));
+        //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+        source.SetAttribute("FlowType", StringValue("Large"));
+        string tempString = SetupSimFileName("RESULT");
+        source.SetAttribute("OutputFileName", StringValue(tempString));
+
+        source.SetAttribute("DCTCP", BooleanValue (true));
+        source.SetAttribute("MaxSubflows", UintegerValue(1));
+        source.SetAttribute("CongestionControl", StringValue("Uncoupled_TCPs"));
+
+
+        ApplicationContainer sourceApps = source.Install(srcNode);
+        sourceApps.Start (Seconds(0.0));
+        sourceApps.Stop (Seconds(0.5));
+
+        sourceShortFlowApps.push_back(sourceApps);
+        cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                << Simulator::Now().GetSeconds() << endl;
+    }
+}
+
+void FlowConfigForLHU2(const NodeContainer *host)
+{
+    // dst setup
+    Ptr<Node> dstNode = host[1].Get(0);
+    Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+    Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+    Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+    cout << "DST:";
+    ipv4AddressDst.Print(cout);
+    cout << endl;
+
+
+    for (uint32_t j = 0; j < 2; j++)
+    {
+        Ptr<Node> srcNode = host[0].Get(j);
+        Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+        Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+        Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+        cout << "MPTCP SRC:";
+        ipv4AddressSrc.Print(cout);
+        cout << endl;
+
+        // Assign flowId
+        int flowId = srcNode->GetNApplications();
+        // Source
+        MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+        source.SetAttribute("MaxBytes", UintegerValue(g_shortFlowSize));
+        source.SetAttribute("FlowId", UintegerValue(flowId));
+        //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+        source.SetAttribute("FlowType", StringValue("Large"));
+        string tempString = SetupSimFileName("RESULT");
+        source.SetAttribute("OutputFileName", StringValue(tempString));
+
+        ApplicationContainer sourceApps = source.Install(srcNode);
+        sourceApps.Start (Seconds(0.0));
+        sourceApps.Stop (Seconds(0.5));
+
+        sourceShortFlowApps.push_back(sourceApps);
+        cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                << Simulator::Now().GetSeconds() << endl;
+    }
+    
+    for (uint32_t j = 0; j < g_numdctcpFlow; j++)
+    {
+        Ptr<Node> srcNode = host[0].Get(j+2);
+        Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+        Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+        Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+        cout << "DCTCP SRC:";
+        ipv4AddressSrc.Print(cout);
+        cout << endl;
+
+        // Assign flowId
+        int flowId = srcNode->GetNApplications();
+        // Source
+        MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+        source.SetAttribute("MaxBytes", UintegerValue(g_shortFlowSize));
+        source.SetAttribute("FlowId", UintegerValue(flowId));
+        //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+        source.SetAttribute("FlowType", StringValue("Large"));
+        string tempString = SetupSimFileName("RESULT");
+        source.SetAttribute("OutputFileName", StringValue(tempString));
+
+        source.SetAttribute("DCTCP", BooleanValue (true));
+        source.SetAttribute("MaxSubflows", UintegerValue(1));
+        source.SetAttribute("CongestionControl", StringValue("Uncoupled_TCPs"));
+
+
+        ApplicationContainer sourceApps = source.Install(srcNode);
+        sourceApps.Start (Seconds(0.0));
+        sourceApps.Stop (Seconds(0.5));
+
+        sourceShortFlowApps.push_back(sourceApps);
+        cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                << Simulator::Now().GetSeconds() << endl;
+    }
+}
+
+
+
+// Main
+int
+main(int argc, char *argv[])
+{
+  SetupStringToTM(); // Should be done before cmd parsing
+  SetupStringToST();
+  SetSimStartTime();
+
+  // Enable log components
+  LogComponentEnable("Inter-Rack-Large", LOG_ALL);
+  //LogComponentEnable("MpTcpSocketBase", LOG_LEVEL_INFO);
+
+  //LogComponentEnable("Ipv4L3Protocol", LOG_LEVEL_INFO);
+  //LogComponentEnable("StoneACL", LOG_ALL);
+  //LogComponentEnable("TraccACL", LOG_ALL);
+  //LogComponentEnable("StoneACLHelper", LOG_ALL);
+  //LogComponentEnable("TraccACLHelper", LOG_ALL);
+
+  // Set up command line parameters
+  CommandLine cmd;
+  cmd.AddValue("sf", "Number of MPTCP SubFlows", MakeCallback(SetNumSubflow));
+  cmd.AddValue("cc", "MPTCP Congestion Control algorithm", MakeCallback(SetCongestionControl));
+  cmd.AddValue("sfs", "Short Flow Size", MakeCallback(SetShortFlowSize));
+  cmd.AddValue("st", "Simulation Time", MakeCallback(SetSimTime));
+  cmd.AddValue("tm", "Set traffic matrix", MakeCallback(SetTrafficMatrix));
+  cmd.AddValue("socket", "Set socket type ", MakeCallback(SetSocketType));
+  cmd.AddValue("i", "Set simulation instance number as a string", MakeCallback(SetSimInstance));
+  cmd.AddValue("rto", "Set minRTO", MakeCallback(SetRTO));
+  cmd.AddValue("sim", "Set sim name", MakeCallback(SetSimName));
+  cmd.AddValue("iw", "Set initial cwnd of initial subflow of MPTCP", MakeCallback(SetIW));
+  cmd.AddValue("siw","DCMPTCP slave initial window", MakeCallback(SetSlaveIW));
+  cmd.AddValue("oppo","DCMPTCP uses OPPO", MakeCallback(SetOppo));
+  cmd.AddValue("persub","DCMPTCP uses Per Subflow based CC", MakeCallback(SetPerSubflow));
+  cmd.AddValue("hn", "Number of hosts in Incast scenrio", MakeCallback(SetHostNumber));
+  
+  
+  cmd.AddValue ("dctcp", "Enable DCTCP Capability", MakeCallback (SetDCTCP));
+  
+  cmd.AddValue("fn", "Number of flows in Incast scenrio", MakeCallback(SetFlowNumber));
+  cmd.AddValue("dctcpn", "Number of dctcp flows", MakeCallback(SetDCTCPFlowNumber));
+  
+
+  cmd.Parse(argc, argv);
+
+  // Set up default simulation parameters
+  Config::SetDefault("ns3::Ipv4GlobalRouting::FlowEcmpRouting", BooleanValue(true));
+  Config::SetDefault("ns3::TcpSocket::SegmentSize", UintegerValue(g_segmentSize));
+  Config::SetDefault("ns3::DropTailQueue::Mode", StringValue("QUEUE_MODE_PACKETS"));
+  Config::SetDefault("ns3::MpTcpSocketBase::RandomGap", UintegerValue(g_rGap));
+
+
+  switch (g_socketType)
+    {
+    case MPTCP:
+      Config::SetDefault("ns3::TcpL4Protocol::SocketType", TypeIdValue(MpTcpSocketBase::GetTypeId()));
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue(g_cc));
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::CongestionControl", StringValue(g_cc));
+      Config::SetDefault("ns3::MpTcpSocketBase::MaxSubflows", UintegerValue(g_subflows)); // Sink
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::MaxSubflows", UintegerValue((uint8_t)g_subflows));//Source
+      Config::SetDefault("ns3::MpTcpSocketBase::PathManagement", StringValue("NdiffPorts"));
+      Config::SetDefault("ns3::TcpSocket::InitialCwnd", UintegerValue(g_initialCWND));
+      Config::SetDefault("ns3::MpTcpSocketBase::SlaveIW", UintegerValue(g_slaveIW));
+      //Config::SetDefault("ns3::MpTcpSocketBase::LargePlotting", BooleanValue(true));
+      //Config::SetDefault("ns3::MpTcpSocketBase::ShortPlotting", BooleanValue(true));
+      
+      if ((g_cc == "DCMPTCP") && (g_oppo == 1))
+        Config::SetDefault("ns3::MpTcpSocketBase::SchedulingAlgorithm", StringValue("DC_SCHE"));
+
+      if ((g_cc == "DCMPTCP") && (g_perSubflow == 1))
+        Config::SetDefault("ns3::MpTcpSocketBase::DCPerSubflow", BooleanValue(true));
+
+      break;
+    case TCP:
+      Config::SetDefault("ns3::TcpL4Protocol::SocketType", TypeIdValue(MpTcpSocketBase::GetTypeId()));
+      Config::SetDefault("ns3::MpTcpSocketBase::MaxSubflows", UintegerValue(1)); // For the sink
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::MaxSubflows", UintegerValue(1)); // TCP need one subflow only
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault("ns3::MpTcpSocketBase::PathManagement", StringValue("NdiffPorts"));
+      Config::SetDefault("ns3::TcpSocket::InitialCwnd", UintegerValue(g_initialCWND));
+      break;
+    default:
+      break;
+    }
+
+  if (g_enableDCTCP)
+    {
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault ("ns3::MpTcpSocketBase::DCTCP", BooleanValue (g_enableDCTCP));
+      Config::SetDefault ("ns3::MpTcpBulkSendApplication::DCTCP", BooleanValue (g_enableDCTCP)); // Source Control
+      Config::SetDefault ("ns3::MpTcpSocketBase::DCTCPWeight", DoubleValue (1.0 / 16.0));
+    }
+  Config::SetDefault ("ns3::RedQueue::UseCurrent", BooleanValue (true));
+
+  Config::SetDefault ("ns3::RedQueue::Mode", StringValue ("QUEUE_MODE_PACKETS"));
+  Config::SetDefault ("ns3::RedQueue::MeanPktSize", UintegerValue (g_REDMeanPktSize));
+  Config::SetDefault ("ns3::RedQueue::Wait", BooleanValue (true));
+  Config::SetDefault ("ns3::RedQueue::Gentle", BooleanValue (false));
+  Config::SetDefault ("ns3::RedQueue::QW", DoubleValue (1.0));
+  
+    
+  //Config::SetDefault ("ns3::TraccACL::TimeInterval", TimeValue (MicroSeconds (100)));
+    
+  g_seed = static_cast<uint32_t>(atoi(g_simInstance.c_str()));
+  cout << "Seed             : " << g_seed << endl;
+  srand(g_seed);
+
+  SimResultHeaderGenerator();
+
+  cout << endl;
+  cout << "Node num:" 
+  << " g_numSpine:" << g_numSpine 
+  << " g_numHost:" << g_numHost 
+  << " g_numLeaf:" << g_numLeaf << endl;
+
+
+  PrintSimParams();
+
+  InternetStackHelper internet;
+
+// ------------------ Topology Construction ------------------
+  NodeContainer allHosts;
+
+// Host Layer Nodes
+  NodeContainer host[g_numLeaf]; // NodeContainer for hosts
+
+  for (uint32_t j = 0; j < g_numLeaf; j++)
+    { // host[g_numLeaf]
+      host[j].Create(g_numHost); 
+      internet.Install(host[j]);
+      allHosts.Add(host[j]);     // Add all server to GlobalHostContainer
+      host_c.Add(host[j]);       // Add all server to Host_c for link utilization
+    }
+
+// Access layer Nodes
+  NodeContainer leaf;          // NodeContainer for leaf switches
+  leaf.Create(g_numLeaf);
+  internet.Install(leaf);
+  leaf_c.Add(leaf);
+
+// Core Layer Nodes
+  NodeContainer spine;       // NodeContainer for core switches
+  spine.Create(g_numSpine);
+  internet.Install(spine);
+  spine_c.Add(spine);
+// -----------------------------------------------------------
+  PointToPointHelper p2p;
+  // if (g_enableDCTCP )//|| (g_cc == "XMP")
+  if ((g_cc == "DCMPTCP") || g_enableDCTCP || (g_cc == "XMP"))
+  {
+    p2p.SetQueue ("ns3::RedQueue", 
+                  "LinkBandwidth", StringValue (g_downLinkCapacity), 
+                  "LinkDelay", StringValue (g_linkDelay),
+                  "MinTh", DoubleValue (g_downLinkREDminTh),
+                  "MaxTh", DoubleValue (g_downLinkREDmaxTh),
+                  "QueueLimit", UintegerValue (g_downLinkREDQueueLimit));
+  }
+  else
+  {
+    p2p.SetQueue ("ns3::DropTailQueue",
+                "MaxPackets", UintegerValue (g_downLinkREDQueueLimit));
+  }
+  p2p.SetDeviceAttribute ("DataRate", StringValue (g_downLinkCapacity));
+  p2p.SetChannelAttribute ("Delay", StringValue (g_linkDelay));
+  
+
+  Ipv4AddressHelper ipv4Address;
+  StoneACLHelper stoneACL;
+  TraccACLHelper traccACL;
+
+//=========== Connect hosts to leafs ===========//
+  NetDeviceContainer hostToLeafNetDevice[g_numLeaf][g_numHost];
+  stringstream ss;
+
+  for (uint32_t t = 0; t < g_numLeaf; t++)
+    {
+      ss.str("");
+      ss << "10." << t << ".0." << "0";
+      string tmp = ss.str();
+      const char* address = tmp.c_str();
+      ipv4Address.SetBase(address, "255.255.255.0");
+      
+      if (g_cc == "DCMPTCP") 
+      {
+        stoneACL.Install (leaf.Get(t), Ipv4Address (address), g_numHost);
+        traccACL.Install (leaf.Get(t), g_numLeaf, g_numHost, g_numSpine, Ipv4Address (address));
+      }
+      for (uint32_t h = 0; h < g_numHost; h++)
+        {
+          hostToLeafNetDevice[t][h] = p2p.Install(NodeContainer(host[t].Get(h), leaf.Get(t)));
+          ipv4Address.Assign(hostToLeafNetDevice[t][h]);
+          Ipv4Address newNet = ipv4Address.NewNetwork();
+          NS_LOG_UNCOND("Leaf:" << t << " IP:" << newNet);
+        }
+    }
+  NS_LOG_INFO("Finished connecting leaf switches and hosts");
+
+  if ((g_cc == "DCMPTCP") || g_enableDCTCP || (g_cc == "XMP"))
+  {
+    p2p.SetQueue ("ns3::RedQueue", 
+                  "LinkBandwidth", StringValue (g_upLinkCapacity), 
+                  "LinkDelay", StringValue (g_linkDelay),
+                  "MinTh", DoubleValue (g_upLinkREDminTh),
+                  "MaxTh", DoubleValue (g_upLinkREDmaxTh),
+                  "QueueLimit", UintegerValue (g_upLinkREDQueueLimit));
+  }
+  else
+  {
+    p2p.SetQueue ("ns3::DropTailQueue",
+                  "MaxPackets", UintegerValue (g_upLinkREDQueueLimit));
+  } 
+  p2p.SetDeviceAttribute ("DataRate", StringValue (g_upLinkCapacity));
+//=========== Connect core switches to aggregate switches ===========//
+  NetDeviceContainer ct[g_numSpine][g_numLeaf];
+  ipv4Address.SetBase("30.30.0.0", "255.255.255.0");
+
+  for (uint32_t c = 0; c < g_numSpine; c++)
+    {
+      for (uint32_t p = 0; p < g_numLeaf; p++)
+        {
+          ct[c][p] = p2p.Install(spine.Get(c), leaf.Get(p));
+          ipv4Address.Assign(ct[c][p]);
+          Ipv4Address newNet = ipv4Address.NewNetwork();
+          NS_LOG_UNCOND(newNet);
+        }
+    }
+  NS_LOG_INFO("Finished connecting core and aggregation");
+  //p2p.EnablePcapAll(SetupSimFileName("PCAP"));
+
+  // Populate Global Routing
+  Ipv4GlobalRoutingHelper::PopulateRoutingTables();
+
+
+  //=========== Initialize settings for On/Off Application ===========//
+  // SINK application - It would be closed doubled the time of source closure!
+  //NS_LOG_INFO("\nSink App Install on following nodes: ");
+  for (uint32_t i = 0; i < allHosts.GetN(); i++)
+    {
+      MpTcpPacketSinkHelper sink("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address::GetAny(), PORT));
+      ApplicationContainer tmp = sink.Install(allHosts.Get(i));
+      tmp.Start(Seconds(0.0));
+      tmp.Stop(Seconds(g_simTime));
+      sinkApps.push_back(tmp);
+    }
+
+
+  if (g_trafficMatrix == LHU)
+    Simulator::Schedule(Seconds(g_flowStartTime), &FlowConfigForLHU, host);
+  else if (g_trafficMatrix == LHU4)
+    Simulator::Schedule(Seconds(g_flowStartTime), &FlowConfigForLHU4, host);
+  else if (g_trafficMatrix == LHU2)
+    Simulator::Schedule(Seconds(g_flowStartTime), &FlowConfigForLHU2, host);
+
+
+
+
+  NS_LOG_INFO ("Run Simulation.");
+  Simulator::Stop(Seconds(g_simTime));
+  Simulator::Run();
+
+  SimResultFooterGenerator(); // OveralResultWritter should be called first!
+  //-----------------------------------------------------------------------//
+  Simulator::Destroy();
+  NS_LOG_INFO ("Done.");
+  cout << Simulator::Now().GetSeconds() << " END "<< endl;
+  return 0;
+}
+
+
+
diff --git a/scratch/inter-rack-large.cc b/scratch/inter-rack-large.cc
new file mode 100644
index 0000000..8f99254
--- /dev/null
+++ b/scratch/inter-rack-large.cc
@@ -0,0 +1,836 @@
+/*
+ * Author: Enhuan Dong -A pathetic PhD student.- <deh13@mails.tsinghua.edu.cn>
+ */
+#include <ctime>
+#include <sys/time.h>
+#include <stdint.h>
+#include <fstream>
+#include <string>
+#include <cassert>
+#include <iostream>
+#include <iomanip>
+#include "ns3/log.h"
+#include "ns3/core-module.h"
+#include "ns3/network-module.h"
+#include "ns3/applications-module.h"
+#include "ns3/point-to-point-module.h"
+#include "ns3/internet-module.h"
+#include "ns3/netanim-module.h"
+#include "ns3/mobility-module.h"
+#include "ns3/callback.h"
+#include "ns3/string.h"
+
+using namespace ns3;
+NS_LOG_COMPONENT_DEFINE("Inter-Rack-Large");
+
+typedef enum
+{
+  Spine, Leaf, Host, Spine_Leaf, Spine_Leaf_Host
+} Layers_t;
+
+typedef enum
+{
+  NONE, NEW_INCAST, TYPICAL_INCAST, NEW_INCAST_BK, ONE_MAP_ONE
+} TrafficMatrix_t;
+
+typedef enum
+{
+  TCP, MPTCP
+} SocketType_t;
+
+
+std::map<string, TrafficMatrix_t> stringToTrafficMatrix;
+std::map<string, SocketType_t> stringToSocketType;
+vector<ApplicationContainer> sourceShortFlowApps;
+vector<ApplicationContainer> sourceLargeFlowApps;
+vector<ApplicationContainer> sinkApps;
+
+#define PORT 5000
+
+// Setup general parameters
+string g_topology = "Inter-Rack-Large";
+string g_simName  = "MPTCP_Incast";
+
+
+// Setup topology parameters
+string g_downLinkCapacity = "10Gbps";  
+string g_upLinkCapacity = "40Gbps";  //Normal
+string g_linkDelay = "25us";       
+
+uint32_t g_numSpine = 8;
+uint32_t g_numLeaf = 8;
+uint32_t g_numHost = 32;
+
+uint32_t g_flowSize = 128000;   // 128KB
+uint32_t g_shortFlowSize = 128000;
+uint32_t g_simTime = 60;             // 20 Seconds (default)
+uint32_t g_seed = 0;                // RNG seed
+SocketType_t g_socketType = MPTCP;
+TrafficMatrix_t g_trafficMatrix = NEW_INCAST;
+
+string g_simInstance = "0";
+string g_simStartTime = "NULL";
+uint32_t g_minRTO = 200;
+double g_flowStartTime = 0.0;
+
+uint32_t g_rGap = 50;
+// Setup MPTCP parameters
+string g_cc = "RTT_Compensator"; // Uncoupled_TCPs, Linked_Increases, Fully_Coupled, RTT_Compensator
+uint32_t g_subflows = 8;
+uint32_t g_initialCWND = 10;
+uint32_t g_slaveIW = 1;
+uint32_t g_oppo = 1;
+bool g_enableDCTCP = true;
+uint32_t g_perSubflow = 0;
+
+// For dctcp only
+double g_downLinkREDmaxTh = 65;
+double g_downLinkREDminTh = 65;
+ 
+uint32_t g_downLinkREDQueueLimit = 350;   
+
+ // Normal
+double g_upLinkREDmaxTh = 150;
+double g_upLinkREDminTh = 150;
+uint32_t g_upLinkREDQueueLimit = 1400;   
+
+uint32_t g_segmentSize = 1400;
+uint32_t g_REDMeanPktSize = g_segmentSize;
+
+
+// NodeContainer to use for link utilization and loss rate
+NodeContainer spine_c;
+NodeContainer leaf_c;
+NodeContainer host_c;
+
+//Incast
+uint32_t g_numFlow = 10;
+
+void SimHeaderWritter(Ptr<OutputStreamWrapper> stream);
+void SimFooterWritter(Ptr<OutputStreamWrapper> stream);
+
+uint64_t
+GetLinkRate(string linkRate)
+{
+  DataRate tmp(linkRate);
+  return tmp.GetBitRate();
+}
+
+void
+SetupStringToTM()
+{
+  stringToTrafficMatrix["TYPICAL_INCAST"] = TYPICAL_INCAST;
+  stringToTrafficMatrix["NEW_INCAST"] = NEW_INCAST;
+  stringToTrafficMatrix["NEW_INCAST_BK"] = NEW_INCAST_BK;
+  stringToTrafficMatrix["ONE_MAP_ONE"] = ONE_MAP_ONE;
+  stringToTrafficMatrix["NONE"] = NONE;
+}
+
+void
+SetupStringToST()
+{
+  stringToSocketType["TCP"] = TCP;
+  stringToSocketType["MPTCP"] = MPTCP;
+}
+
+
+string
+GetKeyFromValueTM(TrafficMatrix_t tm)
+{
+  map<string, TrafficMatrix_t>::const_iterator it = stringToTrafficMatrix.begin();
+  for (; it != stringToTrafficMatrix.end(); it++)
+    {
+      if (it->second == tm)
+        return it->first;
+    }
+  return "";
+}
+
+string
+GetKeyFromValueST(SocketType_t st)
+{
+  map<string, SocketType_t>::const_iterator it = stringToSocketType.begin();
+  for (; it != stringToSocketType.end(); it++)
+    {
+      if (it->second == st)
+        return it->first;
+    }
+  return "";
+}
+
+string
+SetupSimFileName(string input)
+{
+  ostringstream oss;
+  oss.str("");
+  oss << g_simName << "_" << g_topology  <<  "_MPTCP_" << GetKeyFromValueTM(g_trafficMatrix) << "_" << input << "_" << g_simInstance
+      << ".data";
+  string tmp = oss.str();
+  oss.str("");
+  return tmp;
+}
+
+
+void
+PrintSimParams()
+{
+  cout << endl;
+  cout << "Socket Type      : " << GetKeyFromValueST(g_socketType).c_str() << endl;
+  cout << "Traffic Matrix   : " << GetKeyFromValueTM(g_trafficMatrix).c_str() << endl;
+  cout << "Seed             : " << g_seed << endl;
+  cout << "Instance         : " << g_simInstance << endl;
+  cout << "DCTCP            : " << g_enableDCTCP << endl;
+  cout << "CC               : " << g_cc << endl;
+  //cout << "Incast Number    : " << g_incastNumber << endl;
+}
+
+
+Ptr<Queue>
+FindQueue(Ptr<NetDevice> dev)
+{
+  PointerValue ptr;
+  dev->GetAttribute("TxQueue", ptr);
+  return ptr.Get<Queue>();
+}
+
+
+
+string
+GetDateTimeNow()
+{
+  time_t T = time(0);
+  struct tm* now = localtime(&T);
+  string simStartDate = asctime(now);
+  return simStartDate.substr(0, 24);
+}
+
+void
+SetSimStartTime()
+{
+  g_simStartTime = GetDateTimeNow();
+}
+
+string
+GetSimStartTime()
+{
+  return g_simStartTime;
+}
+
+void
+SimHeaderWritter(Ptr<OutputStreamWrapper> stream)
+{
+  ostream *os = stream->GetStream ();
+  *os << "SimStart [" << g_simStartTime << "] simName[" << g_simName
+      << "] Topology[" << g_topology 
+      << "] SocketType[" << GetKeyFromValueST (g_socketType) 
+      << "] TrafficMatrix[" << GetKeyFromValueTM (g_trafficMatrix)
+      << "] Seed[" << g_seed << "] simInstance["
+      << g_simInstance << "] SimPeriod[" << g_simTime
+      << "s] HostPerLeaf[" << g_numHost << "] CC[" << g_cc << "] dctcp[" << g_enableDCTCP
+      << "] FlowSize[" << g_flowSize << "] ShortFlowSize[" << g_shortFlowSize <<"] SubflowNum[" <<g_subflows
+      << "] upLinkRate["<< g_upLinkCapacity << "] downLinkRate["<< g_downLinkCapacity << "] LinkDelay[" << g_linkDelay
+      << "] RTOmin[ " << g_minRTO << "]" << endl;
+}
+
+void
+SimFooterWritter(Ptr<OutputStreamWrapper> stream)
+{
+  ostream *os = stream->GetStream();
+  *os << "SimEnd [" << GetDateTimeNow() << "] AllFlows[" << sourceLargeFlowApps.size() + sourceShortFlowApps.size()
+      << "] LargeFlow[" << sourceLargeFlowApps.size() << "] ShortFlows[" << sourceShortFlowApps.size() << "]"
+      << endl;
+}
+
+void
+SimResultHeaderGenerator()
+{
+  Ptr<OutputStreamWrapper> streamSimParam = Create<OutputStreamWrapper>(SetupSimFileName("RESULT"),
+      std::ios::out | std::ios::app);
+  SimHeaderWritter(streamSimParam);
+}
+
+void
+SimResultFooterGenerator()
+{
+  Ptr<OutputStreamWrapper> streamSimParam = Create<OutputStreamWrapper>(SetupSimFileName("RESULT"),
+      std::ios::out | std::ios::app);
+  SimFooterWritter(streamSimParam);
+}
+
+bool
+SetNumSubflow(std::string input)
+{
+  cout << "Subflows         : " << g_subflows << " -> " << input << endl;
+  g_subflows = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetCongestionControl(std::string input)
+{
+  cout << "CongestionControl: " << g_cc << " -> " << input << endl;
+  g_cc = input;
+  return true;
+}
+
+bool
+SetFlowSize(std::string input)
+{
+  g_flowSize = atoi(input.c_str()) * 1024;
+  cout << "FlowSize    : " << g_flowSize << endl;
+  return true;
+}
+
+bool
+SetShortFlowSize(std::string input)
+{
+  g_shortFlowSize = atoi(input.c_str()) * 1024;
+  cout << "ShortFlowSize    : " << g_shortFlowSize << endl;
+  return true;
+}
+
+bool
+SetSimTime(std::string input)
+{
+  cout << "SimDuration      : " << g_simTime << " -> " << input << endl;
+  g_simTime = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetTrafficMatrix(std::string input)
+{
+  cout << "TrafficMatrix    : " << GetKeyFromValueTM(g_trafficMatrix) << " -> " << input << endl;
+  if (stringToTrafficMatrix.count(input) != 0)
+    {
+      g_trafficMatrix = stringToTrafficMatrix[input];
+    }
+  else
+    NS_FATAL_ERROR("Input for setting up traffic matrix has spelling issue - try again!");
+  return true;
+}
+
+bool
+SetSocketType(std::string input)
+{
+  cout << "SocketType       : " << GetKeyFromValueST(g_socketType) << " -> " << input << endl;
+  if (stringToSocketType.count(input) != 0)
+    {
+      g_socketType = stringToSocketType[input];
+    }
+  else
+    NS_FATAL_ERROR("Input for setting up socket type has spelling issue - try again!");
+  return true;
+}
+
+bool
+SetSimInstance(std::string input)
+{
+  cout << "SimInstance      : " << g_simInstance << " -> " << input << endl;
+  g_simInstance = input;
+  return true;
+}
+
+bool
+SetRTO(std::string input)
+{
+  cout << "RTO              : " << g_minRTO << " -> " << input << endl;
+  g_minRTO = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetSimName(std::string input)
+{
+  cout << "SimName          : " << g_simName << " -> " << input << endl;
+  g_simName = input;
+  return true;
+}
+
+bool
+SetIW(std::string input)
+{
+  cout << "InitalCWND       : " << g_initialCWND << " -> " << input << endl;
+  g_initialCWND = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetSlaveIW(std::string input)
+{
+  cout << "InitalSlaveCWND       : " << g_slaveIW << " -> " << input << endl;
+  g_slaveIW = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetOppo(std::string input)
+{
+  cout << "UseOppo       : " << g_oppo << " -> " << input << endl;
+  g_oppo = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetPerSubflow(std::string input)
+{
+  cout << "PerSubflow       : " << g_perSubflow << " -> " << input << endl;
+  g_perSubflow = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetFST(std::string input)
+{
+  cout << "SetFST          : " << g_flowStartTime << " -> " << input << endl;
+  g_flowStartTime = atof(input.c_str());
+  return true;
+}
+
+bool
+SetHostNumber(std::string input){
+  cout << "Host Number    : " << g_numHost << " -> " << input << endl;
+  g_numHost = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetFlowNumber(std::string input){
+  cout << "Flow Number    : " << g_numFlow << " -> " << input << endl;
+  g_numFlow = atoi(input.c_str());
+  return true;
+}
+
+void printNodeAddr(Ptr<Node> tmp)
+{
+  Ptr<Ipv4> ipv4Src = tmp->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+  Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+  ipv4AddressSrc.Print(cout);
+  cout << endl;
+}
+
+
+bool
+SetDCTCP (std::string input)
+{
+  cout << "Enable DCTCP     : " << g_enableDCTCP << " -> " << input << endl;
+  g_enableDCTCP = atoi (input.c_str ());
+  return true;
+}
+
+
+
+// All to one
+void
+FlowConfigForOneMapOne(const NodeContainer *host)
+{    
+  for (uint32_t j = 0; j < g_numFlow; j++)
+  {  // dst setup
+    Ptr<Node> dstNode = host[1].Get(j);
+    Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+    Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+    Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+    cout << "DST:";
+    ipv4AddressDst.Print(cout);
+    cout << endl;
+
+    Ptr<Node> srcNode = host[0].Get(j);
+    Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+    Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+    Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+    cout << "SRC:";
+    ipv4AddressSrc.Print(cout);
+    cout << endl;
+
+    // Assign flowId
+    int flowId = srcNode->GetNApplications();
+
+    // Source
+    MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+    source.SetAttribute("MaxBytes", UintegerValue(g_flowSize));
+    source.SetAttribute("FlowId", UintegerValue(flowId));
+    //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+    source.SetAttribute("FlowType", StringValue("Short"));
+    string tempString = SetupSimFileName("RESULT");
+    source.SetAttribute("OutputFileName", StringValue(tempString));
+
+    ApplicationContainer sourceApps = source.Install(srcNode);
+    sourceApps.Start (Seconds(0.0));
+    sourceApps.Stop (Seconds(g_simTime));
+
+    sourceShortFlowApps.push_back(sourceApps);
+    cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                  << Simulator::Now().GetSeconds() << " No." << j << endl;
+    }
+}
+
+
+
+// All to one
+void
+FlowConfigForNewIncastBK(const NodeContainer *host)
+{
+  // dst setup
+  Ptr<Node> dstNode = host[1].Get(0);
+  Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+  Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+  cout << "DST:";
+  ipv4AddressDst.Print(cout);
+  cout << endl;
+    
+  for (uint32_t j = 0; j < g_numFlow; j++)
+    {
+      Ptr<Node> srcNode = host[0].Get(j);
+      Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+      Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+      Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+      cout << "SRC:";
+      ipv4AddressSrc.Print(cout);
+      cout << endl;
+
+      // Assign flowId
+      int flowId = srcNode->GetNApplications();
+
+      // Source
+      MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+      source.SetAttribute("MaxBytes", UintegerValue(g_shortFlowSize));
+      source.SetAttribute("FlowId", UintegerValue(flowId));
+      //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+      source.SetAttribute("FlowType", StringValue("Short"));
+      string tempString = SetupSimFileName("RESULT");
+      source.SetAttribute("OutputFileName", StringValue(tempString));
+
+      ApplicationContainer sourceApps = source.Install(srcNode);
+      sourceApps.Start (Seconds(0.001));
+      sourceApps.Stop (Seconds(g_simTime));
+
+      sourceShortFlowApps.push_back(sourceApps);
+      cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                    << Simulator::Now().GetSeconds() << " No." << j << endl;
+    }
+    
+    
+  // Background flow
+  // dst setup
+  FlowConfigForOneMapOne(host);
+}
+
+// All to one without background traffic
+void FlowConfigForNewIncast(const NodeContainer *host)
+{
+  // dst setup
+  Ptr<Node> dstNode = host[1].Get(0);
+  Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+  Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+  cout << "DST:";
+  ipv4AddressDst.Print(cout);
+  cout << endl;
+    
+  for (uint32_t j = 0; j < g_numFlow; j++)
+    {
+      Ptr<Node> srcNode = host[0].Get(j);
+      Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+      Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+      Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+      cout << "SRC:";
+      ipv4AddressSrc.Print(cout);
+      cout << endl;
+
+      // Assign flowId
+      int flowId = srcNode->GetNApplications();
+
+      // Source
+      MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+      source.SetAttribute("MaxBytes", UintegerValue(g_shortFlowSize));
+      source.SetAttribute("FlowId", UintegerValue(flowId));
+      //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+      source.SetAttribute("FlowType", StringValue("Short"));
+      string tempString = SetupSimFileName("RESULT");
+      source.SetAttribute("OutputFileName", StringValue(tempString));
+
+      ApplicationContainer sourceApps = source.Install(srcNode);
+      sourceApps.Start (Seconds(0.001));
+      sourceApps.Stop (Seconds(g_simTime));
+
+      sourceShortFlowApps.push_back(sourceApps);
+      cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                    << Simulator::Now().GetSeconds() << " No." << j << endl;
+    }
+}
+
+
+
+// Main
+int
+main(int argc, char *argv[])
+{
+  SetupStringToTM(); // Should be done before cmd parsing
+  SetupStringToST();
+  SetSimStartTime();
+
+  // Enable log components
+  LogComponentEnable("Inter-Rack-Large", LOG_ALL);
+  //LogComponentEnable("MpTcpSocketBase", LOG_LEVEL_INFO);
+
+  //LogComponentEnable("Ipv4L3Protocol", LOG_LEVEL_INFO);
+  //LogComponentEnable("StoneACL", LOG_ALL);
+  //LogComponentEnable("TraccACL", LOG_ALL);
+  //LogComponentEnable("StoneACLHelper", LOG_ALL);
+  //LogComponentEnable("TraccACLHelper", LOG_ALL);
+
+  // Set up command line parameters
+  CommandLine cmd;
+  cmd.AddValue("sf", "Number of MPTCP SubFlows", MakeCallback(SetNumSubflow));
+  cmd.AddValue("cc", "MPTCP Congestion Control algorithm", MakeCallback(SetCongestionControl));
+  cmd.AddValue("sfs", "Short Flow Size", MakeCallback(SetShortFlowSize));
+  cmd.AddValue("fs", "Flow Size", MakeCallback(SetFlowSize));
+  cmd.AddValue("st", "Simulation Time", MakeCallback(SetSimTime));
+  cmd.AddValue("tm", "Set traffic matrix", MakeCallback(SetTrafficMatrix));
+  cmd.AddValue("socket", "Set socket type ", MakeCallback(SetSocketType));
+  cmd.AddValue("i", "Set simulation instance number as a string", MakeCallback(SetSimInstance));
+  cmd.AddValue("rto", "Set minRTO", MakeCallback(SetRTO));
+  cmd.AddValue("sim", "Set sim name", MakeCallback(SetSimName));
+  cmd.AddValue("iw", "Set initial cwnd of initial subflow of MPTCP", MakeCallback(SetIW));
+  cmd.AddValue("siw","DCMPTCP slave initial window", MakeCallback(SetSlaveIW));
+  cmd.AddValue("oppo","DCMPTCP uses OPPO", MakeCallback(SetOppo));
+  cmd.AddValue("persub","DCMPTCP uses Per Subflow based CC", MakeCallback(SetPerSubflow));
+  cmd.AddValue("hn", "Number of hosts in Incast scenrio", MakeCallback(SetHostNumber));
+  
+  
+  cmd.AddValue ("dctcp", "Enable DCTCP Capability", MakeCallback (SetDCTCP));
+  
+  cmd.AddValue("fn", "Number of flows in Incast scenrio", MakeCallback(SetFlowNumber));
+  
+
+  cmd.Parse(argc, argv);
+
+  // Set up default simulation parameters
+  Config::SetDefault("ns3::Ipv4GlobalRouting::FlowEcmpRouting", BooleanValue(true));
+  Config::SetDefault("ns3::TcpSocket::SegmentSize", UintegerValue(g_segmentSize));
+  Config::SetDefault("ns3::DropTailQueue::Mode", StringValue("QUEUE_MODE_PACKETS"));
+  Config::SetDefault("ns3::MpTcpSocketBase::RandomGap", UintegerValue(g_rGap));
+
+
+  switch (g_socketType)
+    {
+    case MPTCP:
+      Config::SetDefault("ns3::TcpL4Protocol::SocketType", TypeIdValue(MpTcpSocketBase::GetTypeId()));
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue(g_cc));
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::CongestionControl", StringValue(g_cc));
+      Config::SetDefault("ns3::MpTcpSocketBase::MaxSubflows", UintegerValue(g_subflows)); // Sink
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::MaxSubflows", UintegerValue((uint8_t)g_subflows));//Source
+      Config::SetDefault("ns3::MpTcpSocketBase::PathManagement", StringValue("NdiffPorts"));
+      Config::SetDefault("ns3::TcpSocket::InitialCwnd", UintegerValue(g_initialCWND));
+      Config::SetDefault("ns3::MpTcpSocketBase::SlaveIW", UintegerValue(g_slaveIW));
+      //Config::SetDefault("ns3::MpTcpSocketBase::LargePlotting", BooleanValue(true));
+      //Config::SetDefault("ns3::MpTcpSocketBase::ShortPlotting", BooleanValue(true));
+      
+      if ((g_cc == "DCMPTCP") && (g_oppo == 1))
+        Config::SetDefault("ns3::MpTcpSocketBase::SchedulingAlgorithm", StringValue("DC_SCHE"));
+
+      if ((g_cc == "DCMPTCP") && (g_perSubflow == 1))
+        Config::SetDefault("ns3::MpTcpSocketBase::DCPerSubflow", BooleanValue(true));
+
+      break;
+    case TCP:
+      Config::SetDefault("ns3::TcpL4Protocol::SocketType", TypeIdValue(MpTcpSocketBase::GetTypeId()));
+      Config::SetDefault("ns3::MpTcpSocketBase::MaxSubflows", UintegerValue(1)); // For the sink
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::MaxSubflows", UintegerValue(1)); // TCP need one subflow only
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault("ns3::MpTcpSocketBase::PathManagement", StringValue("NdiffPorts"));
+      Config::SetDefault("ns3::TcpSocket::InitialCwnd", UintegerValue(g_initialCWND));
+      break;
+    default:
+      break;
+    }
+
+  if (g_enableDCTCP)
+    {
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault ("ns3::MpTcpSocketBase::DCTCP", BooleanValue (g_enableDCTCP));
+      Config::SetDefault ("ns3::MpTcpBulkSendApplication::DCTCP", BooleanValue (g_enableDCTCP)); // Source Control
+      Config::SetDefault ("ns3::MpTcpSocketBase::DCTCPWeight", DoubleValue (1.0 / 16.0));
+    }
+  Config::SetDefault ("ns3::RedQueue::UseCurrent", BooleanValue (true));
+
+  Config::SetDefault ("ns3::RedQueue::Mode", StringValue ("QUEUE_MODE_PACKETS"));
+  Config::SetDefault ("ns3::RedQueue::MeanPktSize", UintegerValue (g_REDMeanPktSize));
+  Config::SetDefault ("ns3::RedQueue::Wait", BooleanValue (true));
+  Config::SetDefault ("ns3::RedQueue::Gentle", BooleanValue (false));
+  Config::SetDefault ("ns3::RedQueue::QW", DoubleValue (1.0));
+  
+    
+  //Config::SetDefault ("ns3::TraccACL::TimeInterval", TimeValue (MicroSeconds (100)));
+    
+  g_seed = static_cast<uint32_t>(atoi(g_simInstance.c_str()));
+  cout << "Seed             : " << g_seed << endl;
+  srand(g_seed);
+
+  SimResultHeaderGenerator();
+
+  cout << endl;
+  cout << "Node num:" 
+  << " g_numSpine:" << g_numSpine 
+  << " g_numHost:" << g_numHost 
+  << " g_numLeaf:" << g_numLeaf << endl;
+
+
+  PrintSimParams();
+
+  InternetStackHelper internet;
+
+// ------------------ Topology Construction ------------------
+  NodeContainer allHosts;
+
+// Host Layer Nodes
+  NodeContainer host[g_numLeaf]; // NodeContainer for hosts
+
+  for (uint32_t j = 0; j < g_numLeaf; j++)
+    { // host[g_numLeaf]
+      host[j].Create(g_numHost); 
+      internet.Install(host[j]);
+      allHosts.Add(host[j]);     // Add all server to GlobalHostContainer
+      host_c.Add(host[j]);       // Add all server to Host_c for link utilization
+    }
+
+// Access layer Nodes
+  NodeContainer leaf;          // NodeContainer for leaf switches
+  leaf.Create(g_numLeaf);
+  internet.Install(leaf);
+  leaf_c.Add(leaf);
+
+// Core Layer Nodes
+  NodeContainer spine;       // NodeContainer for core switches
+  spine.Create(g_numSpine);
+  internet.Install(spine);
+  spine_c.Add(spine);
+// -----------------------------------------------------------
+  PointToPointHelper p2p;
+  // if (g_enableDCTCP )//|| (g_cc == "XMP")
+  if ((g_cc == "DCMPTCP") || g_enableDCTCP || (g_cc == "XMP"))
+  {
+    p2p.SetQueue ("ns3::RedQueue", 
+                  "LinkBandwidth", StringValue (g_downLinkCapacity), 
+                  "LinkDelay", StringValue (g_linkDelay),
+                  "MinTh", DoubleValue (g_downLinkREDminTh),
+                  "MaxTh", DoubleValue (g_downLinkREDmaxTh),
+                  "QueueLimit", UintegerValue (g_downLinkREDQueueLimit));
+  }
+  else
+  {
+    p2p.SetQueue ("ns3::DropTailQueue",
+                "MaxPackets", UintegerValue (g_downLinkREDQueueLimit));
+  }
+  p2p.SetDeviceAttribute ("DataRate", StringValue (g_downLinkCapacity));
+  p2p.SetChannelAttribute ("Delay", StringValue (g_linkDelay));
+  
+
+  Ipv4AddressHelper ipv4Address;
+  StoneACLHelper stoneACL;
+  TraccACLHelper traccACL;
+
+//=========== Connect hosts to leafs ===========//
+  NetDeviceContainer hostToLeafNetDevice[g_numLeaf][g_numHost];
+  stringstream ss;
+
+  for (uint32_t t = 0; t < g_numLeaf; t++)
+    {
+      ss.str("");
+      ss << "10." << t << ".0." << "0";
+      string tmp = ss.str();
+      const char* address = tmp.c_str();
+      ipv4Address.SetBase(address, "255.255.255.0");
+      
+      if (g_cc == "DCMPTCP") 
+      {
+        stoneACL.Install (leaf.Get(t), Ipv4Address (address), g_numHost);
+        traccACL.Install (leaf.Get(t), g_numLeaf, g_numHost, g_numSpine, Ipv4Address (address));
+      }
+      for (uint32_t h = 0; h < g_numHost; h++)
+        {
+          hostToLeafNetDevice[t][h] = p2p.Install(NodeContainer(host[t].Get(h), leaf.Get(t)));
+          ipv4Address.Assign(hostToLeafNetDevice[t][h]);
+          Ipv4Address newNet = ipv4Address.NewNetwork();
+          NS_LOG_UNCOND("Leaf:" << t << " IP:" << newNet);
+        }
+    }
+  NS_LOG_INFO("Finished connecting leaf switches and hosts");
+
+  if ((g_cc == "DCMPTCP") || g_enableDCTCP || (g_cc == "XMP"))
+  {
+    p2p.SetQueue ("ns3::RedQueue", 
+                  "LinkBandwidth", StringValue (g_upLinkCapacity), 
+                  "LinkDelay", StringValue (g_linkDelay),
+                  "MinTh", DoubleValue (g_upLinkREDminTh),
+                  "MaxTh", DoubleValue (g_upLinkREDmaxTh),
+                  "QueueLimit", UintegerValue (g_upLinkREDQueueLimit));
+  }
+  else
+  {
+    p2p.SetQueue ("ns3::DropTailQueue",
+                  "MaxPackets", UintegerValue (g_upLinkREDQueueLimit));
+  } 
+  p2p.SetDeviceAttribute ("DataRate", StringValue (g_upLinkCapacity));
+//=========== Connect core switches to aggregate switches ===========//
+  NetDeviceContainer ct[g_numSpine][g_numLeaf];
+  ipv4Address.SetBase("30.30.0.0", "255.255.255.0");
+
+  for (uint32_t c = 0; c < g_numSpine; c++)
+    {
+      for (uint32_t p = 0; p < g_numLeaf; p++)
+        {
+          ct[c][p] = p2p.Install(spine.Get(c), leaf.Get(p));
+          ipv4Address.Assign(ct[c][p]);
+          Ipv4Address newNet = ipv4Address.NewNetwork();
+          NS_LOG_UNCOND(newNet);
+        }
+    }
+  NS_LOG_INFO("Finished connecting core and aggregation");
+  //p2p.EnablePcapAll(SetupSimFileName("PCAP"));
+
+  // Populate Global Routing
+  Ipv4GlobalRoutingHelper::PopulateRoutingTables();
+
+  //=========== Initialize settings for On/Off Application ===========//
+  // SINK application - It would be closed doubled the time of source closure!
+  //NS_LOG_INFO("\nSink App Install on following nodes: ");
+  for (uint32_t i = 0; i < allHosts.GetN(); i++)
+    {
+      MpTcpPacketSinkHelper sink("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address::GetAny(), PORT));
+      ApplicationContainer tmp = sink.Install(allHosts.Get(i));
+      tmp.Start(Seconds(0.0));
+      tmp.Stop(Seconds(g_simTime));
+      sinkApps.push_back(tmp);
+    }
+
+
+  if (g_trafficMatrix == NEW_INCAST_BK)
+    Simulator::Schedule(Seconds(g_flowStartTime), &FlowConfigForNewIncastBK, host);
+  else if (g_trafficMatrix == NEW_INCAST)
+    Simulator::Schedule(Seconds(g_flowStartTime), &FlowConfigForNewIncast, host);
+
+
+
+  NS_LOG_INFO ("Run Simulation.");
+  Simulator::Stop(Seconds(g_simTime));
+  Simulator::Run();
+
+  cout << Simulator::Now().GetSeconds() << " -> Generate Out puts"<< endl;
+
+  SimResultFooterGenerator(); // OveralResultWritter should be called first!
+  //-----------------------------------------------------------------------//
+  Simulator::Destroy();
+  NS_LOG_INFO ("Done.");
+  cout << Simulator::Now().GetSeconds() << " END "<< endl;
+  return 0;
+}
+
+
+
diff --git a/scratch/inter-rack.cc b/scratch/inter-rack.cc
new file mode 100644
index 0000000..9aafbc2
--- /dev/null
+++ b/scratch/inter-rack.cc
@@ -0,0 +1,862 @@
+/*
+ * Author: Enhuan Dong -A pathetic PhD student.- <deh13@mails.tsinghua.edu.cn>
+ */
+#include <ctime>
+#include <sys/time.h>
+#include <stdint.h>
+#include <fstream>
+#include <string>
+#include <cassert>
+#include <iostream>
+#include <iomanip>
+#include "ns3/log.h"
+#include "ns3/core-module.h"
+#include "ns3/network-module.h"
+#include "ns3/applications-module.h"
+#include "ns3/point-to-point-module.h"
+#include "ns3/internet-module.h"
+#include "ns3/netanim-module.h"
+#include "ns3/mobility-module.h"
+#include "ns3/callback.h"
+#include "ns3/string.h"
+
+using namespace ns3;
+NS_LOG_COMPONENT_DEFINE("Inter-Rack");
+
+typedef enum
+{
+  Spine, Leaf, Host, Spine_Leaf, Spine_Leaf_Host
+} Layers_t;
+
+typedef enum
+{
+  NONE, NEW_INCAST, TYPICAL_INCAST, NEW_INCAST_BK, ONE_MAP_ONE
+} TrafficMatrix_t;
+
+typedef enum
+{
+  TCP, MPTCP
+} SocketType_t;
+
+
+std::map<string, TrafficMatrix_t> stringToTrafficMatrix;
+std::map<string, SocketType_t> stringToSocketType;
+vector<ApplicationContainer> sourceShortFlowApps;
+vector<ApplicationContainer> sourceLargeFlowApps;
+vector<ApplicationContainer> sinkApps;
+
+#define PORT 5000
+
+// Setup general parameters
+string g_topology = "Inter-Rack";
+string g_simName  = "MPTCP_Incast";
+
+
+// Setup topology parameters
+string g_downLinkCapacity = "10Gbps";  
+string g_upLinkCapacity = "40Gbps";  //Normal
+string g_linkDelay = "25us";       
+
+uint32_t g_numSpine = 4;
+uint32_t g_numLeaf = 8;
+uint32_t g_numHost = 32;
+
+uint32_t g_flowSize = 128000;   // 128KB
+uint32_t g_simTime = 30;             // 20 Seconds (default)
+uint32_t g_seed = 0;                // RNG seed
+SocketType_t g_socketType = MPTCP;
+TrafficMatrix_t g_trafficMatrix = NEW_INCAST;
+
+string g_simInstance = "0";
+string g_simStartTime = "NULL";
+uint32_t g_minRTO = 200;
+double g_flowStartTime = 0.0;
+
+uint32_t g_rGap = 50;
+// Setup MPTCP parameters
+string g_cc = "RTT_Compensator"; // Uncoupled_TCPs, Linked_Increases, Fully_Coupled, RTT_Compensator
+uint32_t g_subflows = 8;
+uint32_t g_initialCWND = 10;
+uint32_t g_slaveIW = 1;
+bool g_enableDCTCP = true;
+
+// For dctcp only
+double g_downLinkREDmaxTh = 65;
+double g_downLinkREDminTh = 65;
+ 
+uint32_t g_downLinkREDQueueLimit = 350;   
+
+ // Normal
+double g_upLinkREDmaxTh = 150;
+double g_upLinkREDminTh = 150;
+uint32_t g_upLinkREDQueueLimit = 1400;   
+
+uint32_t g_segmentSize = 1400;
+uint32_t g_REDMeanPktSize = g_segmentSize;
+
+
+
+// NodeContainer to use for link utilization and loss rate
+NodeContainer spine_c;
+NodeContainer leaf_c;
+NodeContainer host_c;
+
+//Incast
+uint32_t g_numFlow = 10;
+
+void SimHeaderWritter(Ptr<OutputStreamWrapper> stream);
+void SimFooterWritter(Ptr<OutputStreamWrapper> stream);
+
+uint64_t
+GetLinkRate(string linkRate)
+{
+  DataRate tmp(linkRate);
+  return tmp.GetBitRate();
+}
+
+void
+SetupStringToTM()
+{
+  stringToTrafficMatrix["TYPICAL_INCAST"] = TYPICAL_INCAST;
+  stringToTrafficMatrix["NEW_INCAST"] = NEW_INCAST;
+  stringToTrafficMatrix["NEW_INCAST_BK"] = NEW_INCAST_BK;
+  stringToTrafficMatrix["ONE_MAP_ONE"] = ONE_MAP_ONE;
+  stringToTrafficMatrix["NONE"] = NONE;
+}
+
+void
+SetupStringToST()
+{
+  stringToSocketType["TCP"] = TCP;
+  stringToSocketType["MPTCP"] = MPTCP;
+}
+
+
+string
+GetKeyFromValueTM(TrafficMatrix_t tm)
+{
+  map<string, TrafficMatrix_t>::const_iterator it = stringToTrafficMatrix.begin();
+  for (; it != stringToTrafficMatrix.end(); it++)
+    {
+      if (it->second == tm)
+        return it->first;
+    }
+  return "";
+}
+
+string
+GetKeyFromValueST(SocketType_t st)
+{
+  map<string, SocketType_t>::const_iterator it = stringToSocketType.begin();
+  for (; it != stringToSocketType.end(); it++)
+    {
+      if (it->second == st)
+        return it->first;
+    }
+  return "";
+}
+
+string
+SetupSimFileName(string input)
+{
+  ostringstream oss;
+  oss.str("");
+  oss << g_simName << "_" << g_topology  <<  "_MPTCP_" << GetKeyFromValueTM(g_trafficMatrix) << "_" << input << "_" << g_simInstance
+      << ".data";
+  string tmp = oss.str();
+  oss.str("");
+  return tmp;
+}
+
+
+
+void
+PrintSimParams()
+{
+  cout << endl;
+  cout << "Socket Type      : " << GetKeyFromValueST(g_socketType).c_str() << endl;
+  cout << "Traffic Matrix   : " << GetKeyFromValueTM(g_trafficMatrix).c_str() << endl;
+  cout << "Seed             : " << g_seed << endl;
+  cout << "Instance         : " << g_simInstance << endl;
+  cout << "DCTCP            : " << g_enableDCTCP << endl;
+  cout << "CC               : " << g_cc << endl;
+  //cout << "Incast Number    : " << g_incastNumber << endl;
+}
+
+
+Ptr<Queue>
+FindQueue(Ptr<NetDevice> dev)
+{
+  PointerValue ptr;
+  dev->GetAttribute("TxQueue", ptr);
+  return ptr.Get<Queue>();
+}
+
+
+string
+GetDateTimeNow()
+{
+  time_t T = time(0);
+  struct tm* now = localtime(&T);
+  string simStartDate = asctime(now);
+  return simStartDate.substr(0, 24);
+}
+
+void
+SetSimStartTime()
+{
+  g_simStartTime = GetDateTimeNow();
+}
+
+string
+GetSimStartTime()
+{
+  return g_simStartTime;
+}
+
+void
+SimHeaderWritter(Ptr<OutputStreamWrapper> stream)
+{
+  ostream *os = stream->GetStream ();
+  *os << "SimStart [" << g_simStartTime << "] simName[" << g_simName
+      << "] Topology[" << g_topology 
+      << "] SocketType[" << GetKeyFromValueST (g_socketType) 
+      << "] TrafficMatrix[" << GetKeyFromValueTM (g_trafficMatrix)
+      << "] Seed[" << g_seed << "] simInstance["
+      << g_simInstance << "] SimPeriod[" << g_simTime
+      << "s] HostPerLeaf[" << g_numHost << "] CC[" << g_cc << "] dctcp[" << g_enableDCTCP
+      << "] ShortFlowSize[" << g_flowSize <<"] SubflowNum[" <<g_subflows
+      << "] upLinkRate["<< g_upLinkCapacity << "] downLinkRate["<< g_downLinkCapacity << "] LinkDelay[" << g_linkDelay
+      << "] RTOmin[ " << g_minRTO << "]" << endl;
+}
+
+void
+SimFooterWritter(Ptr<OutputStreamWrapper> stream)
+{
+  ostream *os = stream->GetStream();
+  *os << "SimEnd [" << GetDateTimeNow() << "] AllFlows[" << sourceLargeFlowApps.size() + sourceShortFlowApps.size()
+      << "] LargeFlow[" << sourceLargeFlowApps.size() << "] ShortFlows[" << sourceShortFlowApps.size() << "]"
+      << endl;
+}
+
+void
+SimResultHeaderGenerator()
+{
+  Ptr<OutputStreamWrapper> streamSimParam = Create<OutputStreamWrapper>(SetupSimFileName("RESULT"),
+      std::ios::out | std::ios::app);
+  SimHeaderWritter(streamSimParam);
+}
+
+void
+SimResultFooterGenerator()
+{
+  Ptr<OutputStreamWrapper> streamSimParam = Create<OutputStreamWrapper>(SetupSimFileName("RESULT"),
+      std::ios::out | std::ios::app);
+  SimFooterWritter(streamSimParam);
+}
+
+bool
+SetNumSubflow(std::string input)
+{
+  cout << "Subflows         : " << g_subflows << " -> " << input << endl;
+  g_subflows = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetCongestionControl(std::string input)
+{
+  cout << "CongestionControl: " << g_cc << " -> " << input << endl;
+  g_cc = input;
+  return true;
+}
+
+bool
+SetShortFlowSize(std::string input)
+{
+  g_flowSize = atoi(input.c_str()) * 1000;
+  cout << "FlowSize    : " << g_flowSize << endl;
+  return true;
+}
+
+bool
+SetSimTime(std::string input)
+{
+  cout << "SimDuration      : " << g_simTime << " -> " << input << endl;
+  g_simTime = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetTrafficMatrix(std::string input)
+{
+  cout << "TrafficMatrix    : " << GetKeyFromValueTM(g_trafficMatrix) << " -> " << input << endl;
+  if (stringToTrafficMatrix.count(input) != 0)
+    {
+      g_trafficMatrix = stringToTrafficMatrix[input];
+    }
+  else
+    NS_FATAL_ERROR("Input for setting up traffic matrix has spelling issue - try again!");
+  return true;
+}
+
+bool
+SetSocketType(std::string input)
+{
+  cout << "SocketType       : " << GetKeyFromValueST(g_socketType) << " -> " << input << endl;
+  if (stringToSocketType.count(input) != 0)
+    {
+      g_socketType = stringToSocketType[input];
+    }
+  else
+    NS_FATAL_ERROR("Input for setting up socket type has spelling issue - try again!");
+  return true;
+}
+
+bool
+SetSimInstance(std::string input)
+{
+  cout << "SimInstance      : " << g_simInstance << " -> " << input << endl;
+  g_simInstance = input;
+  return true;
+}
+
+bool
+SetRTO(std::string input)
+{
+  cout << "RTO              : " << g_minRTO << " -> " << input << endl;
+  g_minRTO = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetSimName(std::string input)
+{
+  cout << "SimName          : " << g_simName << " -> " << input << endl;
+  g_simName = input;
+  return true;
+}
+
+bool
+SetIW(std::string input)
+{
+  cout << "InitalCWND       : " << g_initialCWND << " -> " << input << endl;
+  g_initialCWND = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetSlaveIW(std::string input)
+{
+  cout << "InitalSlaveCWND       : " << g_slaveIW << " -> " << input << endl;
+  g_slaveIW = atoi(input.c_str());
+  return true;
+}
+
+
+
+bool
+SetFST(std::string input)
+{
+  cout << "SetFST          : " << g_flowStartTime << " -> " << input << endl;
+  g_flowStartTime = atof(input.c_str());
+  return true;
+}
+
+bool
+SetHostNumber(std::string input){
+  cout << "Host Number    : " << g_numHost << " -> " << input << endl;
+  g_numHost = atoi(input.c_str());
+  return true;
+}
+
+bool
+SetFlowNumber(std::string input){
+  cout << "Flow Number    : " << g_numFlow << " -> " << input << endl;
+  g_numFlow = atoi(input.c_str());
+  return true;
+}
+
+void printNodeAddr(Ptr<Node> tmp)
+{
+  Ptr<Ipv4> ipv4Src = tmp->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+  Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+  ipv4AddressSrc.Print(cout);
+  cout << endl;
+}
+
+
+bool
+SetDCTCP (std::string input)
+{
+  cout << "Enable DCTCP     : " << g_enableDCTCP << " -> " << input << endl;
+  g_enableDCTCP = atoi (input.c_str ());
+  return true;
+}
+
+
+
+// All to one
+void
+FlowConfigForNewIncast(const NodeContainer *host)
+{
+  // dst setup
+  Ptr<Node> dstNode = host[1].Get(0);
+  Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+  Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+  cout << "DST:";
+  ipv4AddressDst.Print(cout);
+  cout << endl;
+    
+  for (uint32_t j = 0; j < g_numFlow; j++)
+    {
+      Ptr<Node> srcNode = host[0].Get(j);
+      Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+      Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+      Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+      cout << "SRC:";
+      ipv4AddressSrc.Print(cout);
+      cout << endl;
+
+      // Assign flowId
+      int flowId = srcNode->GetNApplications();
+
+      // Source
+      MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+      source.SetAttribute("MaxBytes", UintegerValue(g_flowSize));
+      source.SetAttribute("FlowId", UintegerValue(flowId));
+      //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+      source.SetAttribute("FlowType", StringValue("Short"));
+      string tempString = SetupSimFileName("RESULT");
+      source.SetAttribute("OutputFileName", StringValue(tempString));
+
+      ApplicationContainer sourceApps = source.Install(srcNode);
+      sourceApps.Start (Seconds(0.0));
+      sourceApps.Stop (Seconds(g_simTime));
+
+      sourceShortFlowApps.push_back(sourceApps);
+      cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                    << Simulator::Now().GetSeconds() << " No." << j << endl;
+    }
+}
+
+// All to one
+void
+FlowConfigForOneMapOne(const NodeContainer *host)
+{    
+  for (uint32_t j = 0; j < g_numFlow; j++)
+  {  // dst setup
+    Ptr<Node> dstNode = host[1].Get(j);
+    Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+    Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+    Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+    cout << "DST:";
+    ipv4AddressDst.Print(cout);
+    cout << endl;
+
+    Ptr<Node> srcNode = host[0].Get(j);
+    Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+    Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+    Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+    cout << "SRC:";
+    ipv4AddressSrc.Print(cout);
+    cout << endl;
+
+    // Assign flowId
+    int flowId = srcNode->GetNApplications();
+
+    // Source
+    MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+    source.SetAttribute("MaxBytes", UintegerValue(g_flowSize));
+    source.SetAttribute("FlowId", UintegerValue(flowId));
+    //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+    source.SetAttribute("FlowType", StringValue("Short"));
+    string tempString = SetupSimFileName("RESULT");
+    source.SetAttribute("OutputFileName", StringValue(tempString));
+
+    ApplicationContainer sourceApps = source.Install(srcNode);
+    sourceApps.Start (Seconds(0.0));
+    sourceApps.Stop (Seconds(g_simTime));
+
+    sourceShortFlowApps.push_back(sourceApps);
+    cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                  << Simulator::Now().GetSeconds() << " No." << j << endl;
+    }
+}
+
+
+
+// All to one
+void
+FlowConfigForNewIncastBK(const NodeContainer *host)
+{
+  // dst setup
+  Ptr<Node> dstNode = host[1].Get(0);
+  Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+  Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+  cout << "DST:";
+  ipv4AddressDst.Print(cout);
+  cout << endl;
+    
+  for (uint32_t j = 0; j < g_numFlow; j++)
+    {
+      Ptr<Node> srcNode = host[0].Get(j);
+      Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+      Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+      Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+      cout << "SRC:";
+      ipv4AddressSrc.Print(cout);
+      cout << endl;
+
+      // Assign flowId
+      int flowId = srcNode->GetNApplications();
+
+      // Source
+      MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+      source.SetAttribute("MaxBytes", UintegerValue(128000));
+      source.SetAttribute("FlowId", UintegerValue(flowId));
+      //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+      source.SetAttribute("FlowType", StringValue("Short"));
+      string tempString = SetupSimFileName("RESULT");
+      source.SetAttribute("OutputFileName", StringValue(tempString));
+
+      ApplicationContainer sourceApps = source.Install(srcNode);
+      sourceApps.Start (Seconds(0.001));
+      sourceApps.Stop (Seconds(g_simTime));
+
+      sourceShortFlowApps.push_back(sourceApps);
+      cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                    << Simulator::Now().GetSeconds() << " No." << j << endl;
+    }
+    
+    
+  // Background flow
+  // dst setup
+  FlowConfigForOneMapOne(host);
+}
+
+
+
+void
+FlowConfigForTypicalIncast(const NodeContainer *host)
+{
+  // dst setup
+  Ptr<Node> dstNode = host[0].Get(g_numFlow);
+  Ptr<Ipv4> ipv4Dst = dstNode->GetObject<Ipv4>();
+  Ipv4InterfaceAddress ipv4InterfaceAddressDst = ipv4Dst->GetAddress(1, 0);
+  Ipv4Address ipv4AddressDst = ipv4InterfaceAddressDst.GetLocal();
+  cout << "DST:";
+  ipv4AddressDst.Print(cout);
+  cout << endl;
+    
+  for (uint32_t j = 0; j < g_numFlow; j++)
+    {
+      Ptr<Node> srcNode = host[0].Get(j);
+      Ptr<Ipv4> ipv4Src = srcNode->GetObject<Ipv4>();
+      Ipv4InterfaceAddress ipv4InterfaceAddressSrc = ipv4Src->GetAddress(1, 0);
+      Ipv4Address ipv4AddressSrc = ipv4InterfaceAddressSrc.GetLocal();
+
+      cout << "SRC:";
+      ipv4AddressSrc.Print(cout);
+      cout << endl;
+
+      // Assign flowId
+      int flowId = srcNode->GetNApplications();
+
+      // Source
+      MpTcpBulkSendHelper source("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address(ipv4AddressDst), PORT));
+      source.SetAttribute("MaxBytes", UintegerValue(g_flowSize));
+      source.SetAttribute("FlowId", UintegerValue(flowId));
+      //source.SetAttribute("MaxSubflows", UintegerValue(g_subflows));
+      source.SetAttribute("FlowType", StringValue("Short"));
+      string tempString = SetupSimFileName("RESULT");
+      source.SetAttribute("OutputFileName", StringValue(tempString));
+
+      ApplicationContainer sourceApps = source.Install(srcNode);
+      //sourceApps.Start (Seconds (i * g_flowgap));
+      sourceApps.Start (Seconds(0.0));
+      sourceApps.Stop (Seconds(g_simTime));
+
+      sourceShortFlowApps.push_back(sourceApps);
+      cout << "[" << GetKeyFromValueST(g_socketType) << "]{" << GetKeyFromValueTM(g_trafficMatrix) << "} StartNow: "
+                    << Simulator::Now().GetSeconds() << " No." << j << endl;
+    }
+}
+
+
+
+
+
+// Main
+int
+main(int argc, char *argv[])
+{
+  SetupStringToTM(); // Should be done before cmd parsing
+  SetupStringToST();
+  SetSimStartTime();
+
+  // Enable log components
+  LogComponentEnable("Inter-Rack", LOG_ALL);
+  /*LogComponentEnable("MpTcpSocketBase", LOG_LEVEL_INFO);
+
+  LogComponentEnable("Ipv4L3Protocol", LOG_LEVEL_INFO);
+  LogComponentEnable("StoneACL", LOG_ALL);
+  LogComponentEnable("TraccACL", LOG_ALL);
+  LogComponentEnable("StoneACLHelper", LOG_ALL);
+  LogComponentEnable("TraccACLHelper", LOG_ALL);*/
+
+  // Set up command line parameters
+  CommandLine cmd;
+  cmd.AddValue("sf", "Number of MPTCP SubFlows", MakeCallback(SetNumSubflow));
+  cmd.AddValue("cc", "MPTCP Congestion Control algorithm", MakeCallback(SetCongestionControl));
+  cmd.AddValue("sfs", "Short Flow Size", MakeCallback(SetShortFlowSize));
+  cmd.AddValue("st", "Simulation Time", MakeCallback(SetSimTime));
+  cmd.AddValue("tm", "Set traffic matrix", MakeCallback(SetTrafficMatrix));
+  cmd.AddValue("socket", "Set socket type ", MakeCallback(SetSocketType));
+  cmd.AddValue("i", "Set simulation instance number as a string", MakeCallback(SetSimInstance));
+  cmd.AddValue("rto", "Set minRTO", MakeCallback(SetRTO));
+  cmd.AddValue("sim", "Set sim name", MakeCallback(SetSimName));
+  cmd.AddValue("iw", "Set initial cwnd of initial subflow of MPTCP", MakeCallback(SetIW));
+  cmd.AddValue("siw","DCMPTCP slave initial window", MakeCallback(SetSlaveIW));
+  cmd.AddValue("hn", "Number of hosts in Incast scenrio", MakeCallback(SetHostNumber));
+  
+  
+  cmd.AddValue ("dctcp", "Enable DCTCP Capability", MakeCallback (SetDCTCP));
+  
+  cmd.AddValue("fn", "Number of flows in Incast scenrio", MakeCallback(SetFlowNumber));
+  
+
+  cmd.Parse(argc, argv);
+
+  // Set up default simulation parameters
+  Config::SetDefault("ns3::Ipv4GlobalRouting::FlowEcmpRouting", BooleanValue(true));
+  Config::SetDefault("ns3::TcpSocket::SegmentSize", UintegerValue(g_segmentSize));
+  Config::SetDefault("ns3::DropTailQueue::Mode", StringValue("QUEUE_MODE_PACKETS"));
+  Config::SetDefault("ns3::MpTcpSocketBase::RandomGap", UintegerValue(g_rGap));
+
+
+  switch (g_socketType)
+    {
+    case MPTCP:
+      Config::SetDefault("ns3::TcpL4Protocol::SocketType", TypeIdValue(MpTcpSocketBase::GetTypeId()));
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue(g_cc));
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::CongestionControl", StringValue(g_cc));
+      Config::SetDefault("ns3::MpTcpSocketBase::MaxSubflows", UintegerValue(g_subflows)); // Sink
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::MaxSubflows", UintegerValue((uint8_t)g_subflows));//Source
+      Config::SetDefault("ns3::MpTcpSocketBase::PathManagement", StringValue("NdiffPorts"));
+      Config::SetDefault("ns3::TcpSocket::InitialCwnd", UintegerValue(g_initialCWND));
+      Config::SetDefault("ns3::MpTcpSocketBase::SlaveIW", UintegerValue(g_slaveIW));
+      //Config::SetDefault("ns3::MpTcpSocketBase::LargePlotting", BooleanValue(true));
+      //Config::SetDefault("ns3::MpTcpSocketBase::ShortPlotting", BooleanValue(true));
+      
+      if (g_cc == "DCMPTCP") 
+        Config::SetDefault("ns3::MpTcpSocketBase::SchedulingAlgorithm", StringValue("DC_SCHE"));
+
+      break;
+    case TCP:
+      Config::SetDefault("ns3::TcpL4Protocol::SocketType", TypeIdValue(MpTcpSocketBase::GetTypeId()));
+      Config::SetDefault("ns3::MpTcpSocketBase::MaxSubflows", UintegerValue(1)); // For the sink
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::MaxSubflows", UintegerValue(1)); // TCP need one subflow only
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault("ns3::MpTcpBulkSendApplication::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault("ns3::MpTcpSocketBase::PathManagement", StringValue("NdiffPorts"));
+      Config::SetDefault("ns3::TcpSocket::InitialCwnd", UintegerValue(g_initialCWND));
+      break;
+    default:
+      break;
+    }
+
+  if (g_enableDCTCP)
+    {
+      Config::SetDefault("ns3::MpTcpSocketBase::CongestionControl", StringValue("Uncoupled_TCPs"));
+      Config::SetDefault ("ns3::MpTcpSocketBase::DCTCP", BooleanValue (g_enableDCTCP));
+      Config::SetDefault ("ns3::MpTcpBulkSendApplication::DCTCP", BooleanValue (g_enableDCTCP)); // Source Control
+      Config::SetDefault ("ns3::MpTcpSocketBase::DCTCPWeight", DoubleValue (1.0 / 16.0));
+    }
+  Config::SetDefault ("ns3::RedQueue::UseCurrent", BooleanValue (true));
+
+  Config::SetDefault ("ns3::RedQueue::Mode", StringValue ("QUEUE_MODE_PACKETS"));
+  Config::SetDefault ("ns3::RedQueue::MeanPktSize", UintegerValue (g_REDMeanPktSize));
+  Config::SetDefault ("ns3::RedQueue::Wait", BooleanValue (true));
+  Config::SetDefault ("ns3::RedQueue::Gentle", BooleanValue (false));
+  Config::SetDefault ("ns3::RedQueue::QW", DoubleValue (1.0));
+  
+    
+  //Config::SetDefault ("ns3::TraccACL::TimeInterval", TimeValue (MicroSeconds (100)));
+    
+  g_seed = static_cast<uint32_t>(atoi(g_simInstance.c_str()));
+  cout << "Seed             : " << g_seed << endl;
+  srand(g_seed);
+
+  SimResultHeaderGenerator();
+
+  cout << endl;
+  cout << "Node num:" 
+  << " g_numSpine:" << g_numSpine 
+  << " g_numHost:" << g_numHost 
+  << " g_numLeaf:" << g_numLeaf << endl;
+
+
+  PrintSimParams();
+
+  InternetStackHelper internet;
+
+// ------------------ Topology Construction ------------------
+  NodeContainer allHosts;
+
+// Host Layer Nodes
+  NodeContainer host[g_numLeaf]; // NodeContainer for hosts
+
+  for (uint32_t j = 0; j < g_numLeaf; j++)
+    { // host[g_numLeaf]
+      host[j].Create(g_numHost); 
+      internet.Install(host[j]);
+      allHosts.Add(host[j]);     // Add all server to GlobalHostContainer
+      host_c.Add(host[j]);       // Add all server to Host_c for link utilization
+    }
+
+// Access layer Nodes
+  NodeContainer leaf;          // NodeContainer for leaf switches
+  leaf.Create(g_numLeaf);
+  internet.Install(leaf);
+  leaf_c.Add(leaf);
+
+// Core Layer Nodes
+  NodeContainer spine;       // NodeContainer for core switches
+  spine.Create(g_numSpine);
+  internet.Install(spine);
+  spine_c.Add(spine);
+// -----------------------------------------------------------
+  PointToPointHelper p2p;
+  if (g_enableDCTCP )//|| (g_cc == "XMP")
+  {
+    p2p.SetQueue ("ns3::RedQueue", 
+                  "LinkBandwidth", StringValue (g_downLinkCapacity), 
+                  "LinkDelay", StringValue (g_linkDelay),
+                  "MinTh", DoubleValue (g_downLinkREDminTh),
+                  "MaxTh", DoubleValue (g_downLinkREDmaxTh),
+                  "QueueLimit", UintegerValue (g_downLinkREDQueueLimit));
+  }
+  else
+  {//DCMPTCP and MPTCP
+    p2p.SetQueue ("ns3::DropTailQueue",
+                "MaxPackets", UintegerValue (g_downLinkREDQueueLimit));
+  }
+  p2p.SetDeviceAttribute ("DataRate", StringValue (g_downLinkCapacity));
+  p2p.SetChannelAttribute ("Delay", StringValue (g_linkDelay));
+  
+
+  Ipv4AddressHelper ipv4Address;
+  StoneACLHelper stoneACL;
+  TraccACLHelper traccACL;
+
+//=========== Connect hosts to leafs ===========//
+  NetDeviceContainer hostToLeafNetDevice[g_numLeaf][g_numHost];
+  stringstream ss;
+
+  for (uint32_t t = 0; t < g_numLeaf; t++)
+    {
+      ss.str("");
+      ss << "10." << t << ".0." << "0";
+      string tmp = ss.str();
+      const char* address = tmp.c_str();
+      ipv4Address.SetBase(address, "255.255.255.0");
+      
+      if (g_cc == "DCMPTCP") 
+      {
+        stoneACL.Install (leaf.Get(t), Ipv4Address (address), g_numHost);
+        traccACL.Install (leaf.Get(t), g_numLeaf, g_numHost, g_numSpine, Ipv4Address (address));
+      }
+      for (uint32_t h = 0; h < g_numHost; h++)
+        {
+          hostToLeafNetDevice[t][h] = p2p.Install(NodeContainer(host[t].Get(h), leaf.Get(t)));
+          ipv4Address.Assign(hostToLeafNetDevice[t][h]);
+          Ipv4Address newNet = ipv4Address.NewNetwork();
+          NS_LOG_UNCOND("Leaf:" << t << " IP:" << newNet);
+        }
+    }
+  NS_LOG_INFO("Finished connecting leaf switches and hosts");
+
+  if ((g_cc == "DCMPTCP") || g_enableDCTCP || (g_cc == "XMP"))
+  {
+    p2p.SetQueue ("ns3::RedQueue", 
+                  "LinkBandwidth", StringValue (g_upLinkCapacity), 
+                  "LinkDelay", StringValue (g_linkDelay),
+                  "MinTh", DoubleValue (g_upLinkREDminTh),
+                  "MaxTh", DoubleValue (g_upLinkREDmaxTh),
+                  "QueueLimit", UintegerValue (g_upLinkREDQueueLimit));
+  }
+  else
+  {
+    p2p.SetQueue ("ns3::DropTailQueue",
+                  "MaxPackets", UintegerValue (g_upLinkREDQueueLimit));
+  } 
+  p2p.SetDeviceAttribute ("DataRate", StringValue (g_upLinkCapacity));
+//=========== Connect core switches to aggregate switches ===========//
+  NetDeviceContainer ct[g_numSpine][g_numLeaf];
+  ipv4Address.SetBase("30.30.0.0", "255.255.255.0");
+
+  for (uint32_t c = 0; c < g_numSpine; c++)
+    {
+      for (uint32_t p = 0; p < g_numLeaf; p++)
+        {
+          ct[c][p] = p2p.Install(spine.Get(c), leaf.Get(p));
+          ipv4Address.Assign(ct[c][p]);
+          Ipv4Address newNet = ipv4Address.NewNetwork();
+          NS_LOG_UNCOND(newNet);
+        }
+    }
+  NS_LOG_INFO("Finished connecting core and aggregation");
+  //p2p.EnablePcapAll(SetupSimFileName("PCAP"));
+
+  // Populate Global Routing
+  Ipv4GlobalRoutingHelper::PopulateRoutingTables();
+
+
+  //=========== Initialize settings for On/Off Application ===========//
+  // SINK application - It would be closed doubled the time of source closure!
+  //NS_LOG_INFO("\nSink App Install on following nodes: ");
+  for (uint32_t i = 0; i < allHosts.GetN(); i++)
+    {
+      MpTcpPacketSinkHelper sink("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address::GetAny(), PORT));
+      ApplicationContainer tmp = sink.Install(allHosts.Get(i));
+      tmp.Start(Seconds(0.0));
+      tmp.Stop(Seconds(g_simTime));
+      sinkApps.push_back(tmp);
+    }
+
+  if (g_trafficMatrix == NEW_INCAST)    
+    Simulator::Schedule(Seconds(g_flowStartTime), &FlowConfigForNewIncast, host);
+  else if (g_trafficMatrix == TYPICAL_INCAST)
+    Simulator::Schedule(Seconds(g_flowStartTime), &FlowConfigForTypicalIncast, host);
+  else if (g_trafficMatrix == NEW_INCAST_BK)
+    Simulator::Schedule(Seconds(g_flowStartTime), &FlowConfigForNewIncastBK, host);
+  else if (g_trafficMatrix == ONE_MAP_ONE)
+    Simulator::Schedule(Seconds(g_flowStartTime), &FlowConfigForOneMapOne, host);
+
+
+
+
+  NS_LOG_INFO ("Run Simulation.");
+  Simulator::Stop(Seconds(g_simTime));
+  Simulator::Run();
+
+  cout << Simulator::Now().GetSeconds() << " -> Generate Out puts"<< endl;
+
+ 
+  SimResultFooterGenerator(); // OveralResultWritter should be called first!
+  //-----------------------------------------------------------------------//
+  Simulator::Destroy();
+  NS_LOG_INFO ("Done.");
+  cout << Simulator::Now().GetSeconds() << " END "<< endl;
+  return 0;
+}
+
+
+
diff --git a/scratch/trash.cc b/scratch/trash.cc
deleted file mode 100644
index f91b980..0000000
--- a/scratch/trash.cc
+++ /dev/null
@@ -1,1126 +0,0 @@
-/*
- * Author: Morteza Kheirkhah <m.kheirkhah@ed.ac.uk>
- */
-
-#include <stdint.h>
-#include <iostream>
-#include <fstream>
-#include <string>
-#include <cassert>
-#include "ns3/log.h"
-#include "ns3/core-module.h"
-#include "ns3/network-module.h"
-#include "ns3/applications-module.h"
-#include "ns3/point-to-point-module.h"
-#include "ns3/internet-module.h"
-#include "ns3/gnuplot.h"
-#include "ns3/output-stream-wrapper.h"
-#include "ns3/drop-tail-queue.h"
-#include "ns3/red-queue.h"
-#include "ns3/netanim-module.h"
-
-using namespace ns3;
-using namespace std;
-
-NS_LOG_COMPONENT_DEFINE("trash");
-
-NodeContainer total_c;
-NodeContainer Receiver_c;
-NodeContainer Sender_c;
-NodeContainer Edge_src_c;
-NodeContainer Core_c;
-NodeContainer Edge_dst_c;
-
-GnuplotCollection gnu;
-
-vector<pair<double, double> > RedTxQueue;
-bool g_enableRatePlotting = true;
-bool g_enableLfPlotting = true;
-bool g_enableSfPlotting = false;
-bool g_enableRED = true;
-bool g_enableDCTCP = true;
-double g_REDmaxTh = 10;
-double g_REDminTh = 10;
-double g_REDWeight = 1.0;
-bool g_REDGentle = false;
-uint32_t g_segmentSize = 1400;
-uint32_t g_REDMeanPktSize = g_segmentSize;
-uint32_t g_REDQueueLimit = 100;         // Queue limit per packets
-double g_DCTCPWeight = 1.0 / 16.0;      // DCTCP weight factor
-string g_linkCapacity = "1000Mbps";     // 100Mbps
-string g_linkDelay = "28us";            // RTT of empty path; 24us * 8 = 224us
-uint32_t g_subflows = 1;                // 8 Subflows
-string g_note = "";
-bool g_enableAnim = false;
-double g_samplingInterval = 0.0001;
-uint32_t g_XmpGamma = 1;
-uint32_t g_XmpBeta = 4;
-uint32_t g_flowSize = 0;      // 0: unlimited, state otherwise!
-string g_cc = "Fully_Coupled";// No need to replace this with XCA; no loss in this setup
-uint32_t g_seed = 0;          // RNG seed
-string g_simInstance = "0";   // Dynamically adjust at cmd
-double g_rateBeat = 0.1;
-bool g_ecn = false;
-string g_simName = "";
-string g_scenario = "TRASH";
-double g_rtt = 8*Time(g_linkDelay).GetMicroSeconds();
-bool g_slowDownXmpLike = false;
-bool g_queueModeBytes = false;// If true, the queues perform per bytes rather than packets.
-bool g_dctcpAlphaPerAck = false;
-bool g_dctcpFastAlpha = false;
-uint32_t g_DTQmarkTh = 1;
-bool g_SDEL = false;
-// Normal Scenario
-string   g_flowType = "XMP";
-uint32_t g_flowNumber = 2;
-double   g_flowgap = 0.000224;
-double   g_simTime = 1;
-// Special Scenario
-bool     g_specialSource = false;
-string   g_specialFlowType = "ECN";
-uint32_t g_specialFlowNumber = 1;
-bool     g_specialSubflow = false; // True if special flow is multi-path
-// Cwnd/Rwnd
-uint32_t g_cwndMin = 1;
-uint32_t g_rwndScale = 100;
-//DynamicSubflows
-bool g_dynamicSubflow = false;
-uint32_t g_incastThreshold = 10;
-// Topology Setup
-uint32_t g_senders = g_flowNumber;
-uint32_t g_receivers = g_flowNumber;
-uint32_t g_edge_switches = 1;
-uint32_t g_core_switches = 2;
-// Disjointed Paths
-bool g_disjoinedPath = true;
-
-/* Uncoupled_TCPs, Linked_Increases, RTT_Compensator, Fully_Coupled */
-std::string
-ConvertCC (string input)
-{
-  if (input.compare ("Fully_Coupled") == 0)
-    return "FC";
-  else if (input.compare ("Uncoupled_TCPs") == 0)
-    return "UC";
-  else if (input.compare ("RTT_Compensator") == 0)
-    return "RC";
-  else if (input.compare ("XMP") == 0)
-    return "XMP";
-  else if (input.compare ("Fast_Increases") == 0)
-    return "FI";
-  else if (input.compare ("Fast_Uncoupled") == 0)
-    return "FU";
-  else if (input.compare ("XCA") == 0)
-    return "XCA";
-  return "Unknown";
-}
-
-string SetupSimFileName(uint32_t i);
-
-Ipv4Address
-GetIpAddr(NodeContainer nc, uint32_t dst)
-{
-  Ptr<Node> randomServerNode = nc.Get (dst);
-  Ptr<Ipv4> ipv4Server = randomServerNode->GetObject<Ipv4> ();
-  Ipv4InterfaceAddress iaddrServer = ipv4Server->GetAddress (1, 0);
-  return iaddrServer.GetLocal ();
-}
-
-void
-AddNameToEdges()
-{
-  stringstream name;
-  for (uint32_t t = 0; t < Edge_src_c.GetN(); t++)
-    {
-      name.str("");
-      name << "tor-src-" << t;
-      Names::Add (name.str (), Edge_src_c.Get (t));
-    }
-  for (uint32_t t = 0; t < Edge_dst_c.GetN(); t++)
-    {
-      name.str("");
-      name << "tor-dst-" << t;
-      Names::Add (name.str (), Edge_dst_c.Get (t));
-    }
-}
-
-string
-SetupSource (MpTcpBulkSendHelper& source, uint32_t i)
-{
-  if (g_specialSubflow)
-    {
-      source.SetAttribute ("MaxSubflows", UintegerValue (1));
-      cout << "Setup Normal  Source SF[" << 1 << "] -> ";
-    }
-  else
-    {
-      source.SetAttribute ("MaxSubflows", UintegerValue (g_subflows));
-      cout << "Setup Normal  Source SF[" << g_subflows << "] -> ";
-    }
-
-  if (g_flowType == "XMP")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (false));
-      source.SetAttribute ("CongestionControl", StringValue ("XMP"));
-      source.SetAttribute ("SocketModel", StringValue ("XMP"));
-    }
-  else if (g_flowType == "DCMPTCP")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("DCMPTCP"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (false)); // DCMPTCP should be false!
-      source.SetAttribute ("CongestionControl", StringValue (g_cc));
-    }
-  else if (g_flowType == "XLIA")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("XLIA"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (true)); // ECN + LIA
-      source.SetAttribute ("CongestionControl", StringValue (g_cc));
-    }
-  else if (g_flowType == "XFC")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("XFC"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (true));
-      source.SetAttribute ("CongestionControl", StringValue (g_cc));
-    }
-  else if (g_flowType == "DCTCP")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("DCTCP"));
-      source.SetAttribute ("CongestionControl", StringValue (g_cc));
-    }
-  else if (g_flowType == "ECN")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("ECN"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (true));
-      source.SetAttribute ("CongestionControl", StringValue (g_cc));
-    }
-  else if (g_flowType == "TCP")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (false));
-      source.SetAttribute ("SocketModel", StringValue ("TCP"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (false));
-      source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-    }
-  else if (g_flowType == "MPTCP")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (false));
-      source.SetAttribute ("SocketModel", StringValue ("MPTCP"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (false));
-      source.SetAttribute ("CongestionControl", StringValue (g_cc));
-    }
-  source.SetAttribute ("OutputFileName", StringValue (SetupSimFileName (i + 1)));
-  ApplicationContainer sourceApps = source.Install (Sender_c.Get (i));
-  sourceApps.Start (Seconds (i * g_flowgap));
-  sourceApps.Stop (Seconds ((i * g_flowgap)+g_flowgap));
-  return g_flowType;
-}
-
-string
-SetupSpecialSource (MpTcpBulkSendHelper& source, uint32_t i)
-{
-  if (g_specialSubflow)
-    {
-      source.SetAttribute ("MaxSubflows", UintegerValue (g_subflows));
-      cout << "Setup Special Source SF[" << g_subflows << "] -> ";
-    }
-  else
-    {
-      source.SetAttribute ("MaxSubflows", UintegerValue (1));
-      cout << "Setup Special Source SF[" << 1 << "] -> ";
-    }
-  if (g_specialFlowType == "XMP")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (false));
-      source.SetAttribute ("CongestionControl", StringValue ("XMP"));
-      source.SetAttribute ("SocketModel", StringValue ("XMP"));
-    }
-  else if (g_specialFlowType == "XFC")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("XFC"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (true));
-      source.SetAttribute ("CongestionControl", StringValue (g_cc));
-    }
-  else if (g_specialFlowType == "DCMPTCP")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("DCMPTCP"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (false)); // DCMPTCP should be false!
-      source.SetAttribute ("CongestionControl", StringValue (g_cc));
-    }
-  else if (g_specialFlowType == "XLIA")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("XLIA"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (true)); // ECN + LIA
-      source.SetAttribute ("CongestionControl", StringValue (g_cc));
-    }
-  else if (g_specialFlowType == "DCTCP")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("DCTCP"));
-      source.SetAttribute ("CongestionControl", StringValue (g_cc));
-    }
-  else if (g_specialFlowType == "ECN")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (true));
-      source.SetAttribute ("SocketModel", StringValue ("ECN"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (true));
-      source.SetAttribute ("CongestionControl", StringValue (g_cc));
-    }
-  else if (g_specialFlowType == "TCP")
-    {
-      source.SetAttribute ("DCTCP", BooleanValue (false));
-      source.SetAttribute ("SocketModel", StringValue ("TCP"));
-      source.SetAttribute ("SlowDownEcnLike", BooleanValue (false));
-      source.SetAttribute ("CongestionControl", StringValue ("Uncoupled_TCPs"));
-    }
-  source.SetAttribute ("OutputFileName", StringValue (SetupSimFileName (i + 1)));
-  ApplicationContainer sourceApps = source.Install (Sender_c.Get (i));
-  sourceApps.Start (Seconds (i * g_flowgap));
-  sourceApps.Stop (Seconds (g_simTime));
-  return g_specialFlowType;
-}
-
-uint32_t
-GetYrange()
-{
-  if (g_queueModeBytes)
-      return (1400 * g_REDQueueLimit);
-  else
-    return g_REDQueueLimit;
-}
-
-uint32_t
-GetXrange()
-{
-  return g_simTime;
-}
-
-string
-GetQueueMode()
-{
-  if (g_queueModeBytes)
-    return "QMB";
-  else
-    return "QMP";
-}
-
-//"MPTCP_TRASH_240_SF8_1";
-string
-SetupSimFileName(uint32_t i)
-{
-  ostringstream oss;
-  oss.str ("");
-  if (g_specialSource)
-    oss << g_scenario << "_"  << "CM"<< g_cwndMin << "_" << g_specialFlowType << "_" << g_flowType << "_" << ConvertCC (g_cc) << "_FN" <<  g_flowNumber << "_" << "FG" << g_flowgap << g_simName  << "_" << "B" << g_XmpBeta << "_" << GetQueueMode() << "_" <<  "K" << g_REDmaxTh << "_" << g_rtt << "_ST" << g_simTime << "_" << "SF" << g_subflows <<"_" << i << ".data";
-  else
-    oss << g_scenario << "_"  << "CM"<< g_cwndMin << "_" << g_flowType << "_" << ConvertCC (g_cc) << "_FN" <<  g_flowNumber << "_" << "FG" <<  g_flowgap << g_simName  << "_" << "B" << g_XmpBeta << "_" << GetQueueMode() << "_" <<  "K" << g_REDmaxTh << "_" << g_rtt << "_ST" << g_simTime << "_" << "SF" << g_subflows <<"_" << i << ".data";
-  string tmp = oss.str();
-  oss.str("");
-  return tmp;
-}
-
-void
-SimTimeMonitor ()
-{
-  NS_LOG_UNCOND("ClockTime: " << Simulator::Now().GetSeconds());
-  double now = Simulator::Now ().GetSeconds ();
-  cout << "[" << SetupSimFileName(0) << "] -> SimClock: " << now << endl;
-  if (now < g_simTime)
-    Simulator::Schedule (Seconds (1), &SimTimeMonitor);
-}
-
-string
-SetupQueueFileName()
-{
-  ostringstream oss;
-  oss.str ("");
-  if (g_specialSource)
-    oss << g_scenario << "_" << "CM" << g_cwndMin << "_" << g_specialFlowType << "_" << g_flowType << "_" << ConvertCC (g_cc) << "_FN" << g_flowNumber << "_" << "FG" <<  g_flowgap << g_simName << "_" << "B" << g_XmpBeta << "_" << GetQueueMode() << "_" << "K" << g_REDmaxTh << "_" << g_rtt << "_ST" << g_simTime << "_" << "SF" << g_subflows;
-  else
-    oss << g_scenario << "_" << "CM" << g_cwndMin << "_" << g_flowType << "_" << ConvertCC (g_cc) << "_FN" << g_flowNumber << "_" << "FG" <<  g_flowgap << g_simName << "_" << "B" << g_XmpBeta << "_" << GetQueueMode() << "_" << "K" << g_REDmaxTh << "_" << g_rtt << "_ST" << g_simTime << "_" << "SF" << g_subflows;
-  string tmp = oss.str();
-  oss.str("");
-  return tmp;
-}
-
-string
-IsActive (uint32_t boolean)
-{
-  if (boolean == 0)
-    return "Inactive";
-  else
-    return "Active";
-}
-
-Ptr<Queue>
-FindQueue (Ptr<NetDevice> dev)
-{
-  PointerValue ptr;
-  dev->GetAttribute ("TxQueue", ptr);
-  return ptr.Get<Queue> ();
-}
-
-std::string
-GeneratePlotDetail (void)
-{
-  stringstream oss;
-  oss << "LR [" << g_linkCapacity << "] LD [" << g_linkDelay << "] QL [" << g_REDQueueLimit << "pkts] AvgPktSize ["
-      << g_REDMeanPktSize << "bytes] MinTh [" << g_REDminTh << "] MaxTh [" << g_REDmaxTh << "]\\n RedW [" << g_REDWeight
-      << "] Gentle [" << IsActive (g_REDGentle) << "] DctcpW [" << g_DCTCPWeight << "] SimDur [" << g_simTime << "] simName["
-      << g_simName << "] SamInterval[" << g_samplingInterval << "]";
-  string tmp = oss.str ();
-  oss.str ("");
-  return tmp;
-}
-
-void
-QueueMonitor ()
-{
-  uint32_t T = (uint32_t) Simulator::Now ().GetSeconds ();
-  Ptr<Queue> txQueue = FindQueue (Edge_dst_c.Get (0)->GetDevice (Core_c.GetN()+1));
-  if (g_queueModeBytes)
-    RedTxQueue.push_back (make_pair (Simulator::Now ().GetSeconds (), txQueue->GetNBytes ()));
-  else
-    RedTxQueue.push_back (make_pair (Simulator::Now ().GetSeconds (), txQueue->GetNPackets ()));
-
-  txQueue->ResetStatistics ();
-
-  if (T < g_simTime)
-    Simulator::Schedule (Seconds (g_samplingInterval), &QueueMonitor);
-}
-
-bool
-sortbysec (const pair<double, double> &a, const pair<double, double> &b)
-{
-  return (a.second < b.second);
-}
-void
-GenerateQueueCDFPlot ()
-{
-  string file = SetupQueueFileName() + "_QUEUE_CDF.data";
-  Ptr<OutputStreamWrapper> stream = Create<OutputStreamWrapper> (file, std::ios::out);
-  ostream* os = stream->GetStream ();
-
-  std::sort(RedTxQueue.begin (), RedTxQueue.end(), sortbysec);
-  for (uint32_t i = 0; i < RedTxQueue.size(); i++)
-    *os << (i + 1) / (double)RedTxQueue.size() << "\t" << RedTxQueue[i].second << endl;
-}
-//<< "set output \"fairnessOutput.eps\"\n"
-void
-GenerateQueuePlot ()
-{
-  Gnuplot queueTracerGraph;
-  ostringstream oss;
-  oss << "set terminal postscript eps noenhanced color solid font 'Times-Bold,30'\n"
-      << "set output\""
-      << SetupQueueFileName() << "_QUEUE.eps" << "\"\n"
-      << "set xlabel \"Time (s)\"           offset 0,0.8,0\n"
-      << "set ylabel \"Queue Size (pkts)\"  offset 3,0.0,0\n"
-      << "set lmargin 5.0\n"
-      << "set rmargin 1.5\n"
-      << "set tmargin 1.0\n"
-      << "set bmargin 2.5\n"
-      << "set yrange [:" << GetYrange() << "]\n"
-      << "set xrange [:" << GetXrange() << "]\n"
-      << "set xtics offset 0,0.3,0 nomirror\n"
-      << "set ytics offset 0.3,0,0 nomirror\n"
-      << "set mytics 2\n"
-      << "set mxtics 2\n"
-      << "set title font ',20' offset 0,-0.6,0 noenhanced\n"
-      << "unset grid\n"
-      << "unset key\n";
-  queueTracerGraph.AppendExtra (oss.str()
-  /*"set key bmargin center horizontal Left reverse noenhanced autotitles columnhead nobox\n"*/);
-  oss.str("");
-  oss << SetupQueueFileName();
-  queueTracerGraph.SetTitle (oss.str());
-//queueTracerGraph.SetTitle ("RedQueue \\n\\n" + GeneratePlotDetail ());
-
-  Gnuplot2dDataset dataSet;
-  dataSet.SetStyle (Gnuplot2dDataset::LINES_POINTS);
-//  std::stringstream title;
-//  title << "QueueSize ";
-//  dataSet.SetTitle (title.str ());
-  vector<pair<double, double> >::iterator it = RedTxQueue.begin ();
-  while (it != RedTxQueue.end ())
-    {
-      dataSet.Add (it->first, it->second);
-      it++;
-    }
-  if (RedTxQueue.size () > 0)
-    queueTracerGraph.AddDataset (dataSet);
-  gnu.AddPlot (queueTracerGraph);
-
-  string file = SetupQueueFileName() + "_QUEUE.data";
-  Ptr<OutputStreamWrapper> stream = Create<OutputStreamWrapper> (file, std::ios::out);
-  ostream* os = stream->GetStream ();
-  gnu.GenerateOutput (*os);
-}
-
-void
-PrintParams ()
-{
-  cout << "-------------------------------" << endl;
-  cout << "Senders          : " << Sender_c.GetN ()   << endl;
-  cout << "Edges            : " << Edge_src_c.GetN () << endl;
-  cout << "Cores            : " << Core_c.GetN ()     << endl;
-  cout << "Edges            : " << Edge_dst_c.GetN () << endl;
-  cout << "Receivers        : " << Receiver_c.GetN () << endl;
-  cout << "Total            : " << total_c.GetN ()    << endl;
-  cout << "-------------------------------" << endl;
-  cout << "FlowType[" << g_flowType << "] FlowNumber[" << g_flowNumber <<"] FlowGap[" <<g_flowgap << "] SF[" << g_subflows << "] QMB[" << IsActive (g_queueModeBytes) << "]" << endl;
-  cout << "Red[" << IsActive (g_enableRED) << "] " << "K[" << g_REDmaxTh << "] QueueSampling[" << g_samplingInterval<< "] SimEnd[" << g_simTime << "]" << endl;
-  cout << "SpecialSource[" << IsActive(g_specialSource) << "] SpecialFlowNum[" << g_specialFlowNumber << "] SpecialFlowType[" << g_specialFlowType <<"] SpecialSubflow[" << IsActive(g_specialSubflow) << "]"<< endl;
-  cout << "CwndMin[" << g_cwndMin << "] RwndScale[" << g_rwndScale << "] Default_CC[" << g_cc << "]"<< endl;
-  cout << "DynamicSubflow[" << IsActive(g_dynamicSubflow) << "] IncastThresh[" << g_incastThreshold << "]" <<endl;
-  cout << "-------------------------------" << endl;
-}
-
-bool
-SetSimName (std::string input)
-{
-  cout << "SimName          : " << g_simName << " -> " << input << endl;
-  g_simName = input;
-  return true;
-}
-
-bool
-SetSimInstance (std::string input)
-{
-  cout << "SimInstance      : " << g_simInstance << " -> " << input << endl;
-  g_simInstance = input;
-  return true;
-}
-
-bool
-SetRatePlot (std::string input)
-{
-  cout << "RatePlotting     : " << g_enableRatePlotting << " -> " << input << endl;
-  g_enableRatePlotting = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetRateBeat (std::string input)
-{
-  cout << "RateBeat         : " << g_rateBeat << " -> " << input << endl;
-  g_rateBeat = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetLfPlot (std::string input)
-{
-  cout << "LargeFlowPlotting: " << g_enableLfPlotting << " -> " << input << endl;
-  g_enableLfPlotting = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetSfPlot (std::string input)
-{
-  cout << "ShortFlowPlotting: " << g_enableSfPlotting << " -> " << input << endl;
-  g_enableSfPlotting = atoi (input.c_str ());
-  return true;
-}
-bool
-SetRED (std::string input)
-{
-  cout << "Enable RED Queue : " << g_enableRED << " -> " << input << endl;
-  g_enableRED = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetDCTCP (std::string input)
-{
-  cout << "Enable DCTCP     : " << g_enableDCTCP << " -> " << input << endl;
-  g_enableDCTCP = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetREDmin (std::string input)
-{
-  cout << "RED Min Threshold: " << g_REDminTh << " -> " << input << endl;
-  g_REDminTh = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetREDmax (std::string input)
-{
-  cout << "RED Max Threshold: " << g_REDmaxTh << " -> " << input << endl;
-  g_REDmaxTh = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetDCTCPweight (std::string input)
-{
-  cout << "DCTCP Weight     : " << g_DCTCPWeight << " -> " << input << endl;
-  g_DCTCPWeight = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetREDweight (std::string input)
-{
-  cout << "RED Max Weight   : " << g_REDWeight << " -> " << input << endl;
-  g_REDWeight = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetREDQueueLimit (std::string input)
-{
-  cout << "RED Queue Limit  : " << g_REDQueueLimit << " -> " << input << endl;
-  g_REDQueueLimit = atof (input.c_str ());
-  return true;
-}
-bool
-SetSimTime (std::string input)
-{
-  cout << "SimDuration      : " << g_simTime << " -> " << input << endl;
-  g_simTime = atof (input.c_str ());
-  return true;
-}
-bool
-SetNetAnim (std::string input)
-{
-  cout << "NetAnim          : " << g_enableAnim << " -> " << input << endl;
-  g_enableAnim = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetXmpGamma (std::string input)
-{
-  cout << "XMP's Gamma      : " << g_XmpGamma << " -> " << input << endl;
-  g_XmpGamma = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetXmpBeta (std::string input)
-{
-  cout << "XMP's Beta       : " << g_XmpBeta << " -> " << input << endl;
-  g_XmpBeta = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetCongestionControl (std::string input)
-{
-  cout << "CongestionControl: " << g_cc << " -> " << input << endl;
-  g_cc = input;
-  if (g_cc == "XMP")
-    {
-      g_enableDCTCP = false;
-      g_SDEL = false;
-    }
-  return true;
-}
-
-bool
-SetNumSubflow (std::string input)
-{
-  cout << "Subflows         : " << g_subflows << " -> " << input << endl;
-  g_subflows = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetLinkDelay (std::string input)
-{
-  cout << "LinkDelay        : " << g_linkDelay << " -> " << input+"us" << endl;
-  g_linkDelay = input+"us";
-  g_rtt = 8*Time(g_linkDelay).GetMicroSeconds();
-  return true;
-}
-bool
-SetECN (std::string input)
-{
-  cout << "ECN              : " << g_ecn << " -> " << input << endl;
-  g_ecn = atoi (input.c_str ());
-  return true;
-}
-bool
-SetSDXL (std::string input)
-{
-  cout << "SlowDownXMPLike  : " << g_slowDownXmpLike << " -> " << input << endl;
-  g_slowDownXmpLike = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetQueueMode (std::string input)
-{
-  cout << "QueueModeBytes   : " << g_queueModeBytes << " -> " << input << endl;
-  g_queueModeBytes = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetQueueSamplingInterval (std::string input)
-{
-  cout << "QueueSamplingInte: " << g_samplingInterval << " -> " << input << endl;
-  g_samplingInterval = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetDctcpAlphaPerAck (std::string input)
-{
-  cout << "DctcpAlphaPerAck : " << g_dctcpAlphaPerAck << " -> " << input << endl;
-  g_dctcpAlphaPerAck = atoi (input.c_str ());
-  return true;
-}
-bool
-SetDctcpFastAlpha (std::string input)
-{
-  cout << "DctcpFastAlpha   : " << g_dctcpFastAlpha << " -> " << input << endl;
-  g_dctcpFastAlpha = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetDTQMarkTh(std::string input)
-{
-  cout << "DTQmarkTh        : " << g_DTQmarkTh << " -> " << input << endl;
-  g_DTQmarkTh = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetFlowGap(std::string input)
-{
-  cout << "FlowGap          : " << g_flowgap << " -> " << input << endl;
-  g_flowgap = atof (input.c_str ());
-  return true;
-}
-
-bool
-SetSDEL(std::string input)
-{
-  cout << "SDXL::ECN        : " << g_SDEL << " -> " << input << endl;
-  g_SDEL = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetFlowType (std::string input)
-{
-  cout << "FlowType         : " << g_flowType << " -> " << input << endl;
-  g_flowType = input.c_str ();
-  return true;
-}
-
-bool
-SetFlowNumber (std::string input)
-{
-  cout << "FlowNumber       : " << g_flowNumber << " -> " << input << endl;
-  g_flowNumber = atoi (input.c_str ());
-  g_senders = g_flowNumber;
-  g_receivers = g_flowNumber;
-  cout << "Update # senders : " << g_senders   << endl;
-  cout << "Update # receiver: " << g_receivers << endl;
-  return true;
-}
-
-bool
-SetSpecialFlowNumber (std::string input)
-{
-  cout << "SpecialFlowNumber: " << g_specialFlowNumber << " -> " << input << endl;
-  g_specialFlowNumber = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetSpecialFlowType (std::string input)
-{
-  cout << "SpecialFlowType  : " << g_specialFlowType << " -> " << input << endl;
-  g_specialFlowType = input.c_str ();
-  return true;
-}
-
-bool
-SetSpecialSource (std::string input)
-{
-  cout << "SpecialSource    : " << g_specialSource << " -> " << input << endl;
-  g_specialSource = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetRcwndScale (std::string input)
-{
-  cout << "RwndScale        : " << g_rwndScale << " -> " << input << endl;
-  g_rwndScale = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetCwndMin (std::string input)
-{
-  cout << "CwndMin          : " << g_cwndMin << " -> " << input << endl;
-  g_cwndMin = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetSpecialSubflow (std::string input)
-{
-  cout << "SpecialSubflow   : " << g_specialSubflow << " -> " << input << endl;
-  g_specialSubflow = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetDynamicSubflow (std::string input)
-{
-  cout << "DynamicSubflow   : " << g_dynamicSubflow << " -> " << input << endl;
-  g_dynamicSubflow = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetIncastThreshold (std::string input)
-{
-  cout << "Incast Threshold : " << g_incastThreshold << " -> " << input << endl;
-  g_incastThreshold = atoi (input.c_str ());
-  return true;
-}
-bool
-SetDisjoinedPath (std::string input)
-{
-  cout << "Disjoined Paths  : " << g_disjoinedPath << " -> " << input << endl;
-  g_disjoinedPath = atoi (input.c_str ());
-  return true;
-}
-
-bool
-SetEdgeSwitches (std::string input)
-{
-  cout << "Edge Switches    : " << g_edge_switches << " -> " << input << endl;
-  g_edge_switches = atoi (input.c_str ());
-  return true;
-}
-bool
-SetCoreSwitches (std::string input)
-{
-  cout << "Core Switches    : " << g_core_switches << " -> " << input << endl;
-  g_edge_switches = atoi (input.c_str ());
-  return true;
-}
-bool
-SetSenders (std::string input)
-{
-  cout << "No. Senders      : " << g_senders << " -> " << input << endl;
-  g_senders = atoi (input.c_str ());
-  return true;
-}
-bool
-SetReceivers (std::string input)
-{
-  cout << "No. Receivers    : " << g_receivers << " -> " << input << endl;
-  g_receivers = atoi (input.c_str ());
-  return true;
-}
-bool
-SetLinkRate(std::string input)
-{
-  cout << "Link rate        : " << g_linkCapacity << " -> " << input+"Mbps" << endl;
-  g_linkCapacity = input+"Mbps";
-  return true;
-}
-
-int
-main (int argc, char *argv[])
-{
-  // Add some logging
-  LogComponentEnable ("trash", LOG_ALL);
-
-  // First record of RedTxQueue container, should be 0 because Gnuplot is mad!!
-  RedTxQueue.push_back (make_pair (Simulator::Now ().GetSeconds (), 0));
-
-  CommandLine cmd;
-  cmd.AddValue ("lr", "Set p2p link rate", MakeCallback(SetLinkRate));
-  cmd.AddValue ("receivers", "No. of receivers", MakeCallback (SetReceivers));
-  cmd.AddValue ("senders", "No. of senders", MakeCallback (SetSenders));
-  cmd.AddValue ("core", "No. of core switches", MakeCallback (SetCoreSwitches));
-  cmd.AddValue ("edge", "No. of edge switches", MakeCallback (SetEdgeSwitches));
-  cmd.AddValue ("djp", "Long flow use disjoined ecmp paths at aggrs", MakeCallback (SetDisjoinedPath));
-  cmd.AddValue ("it", "Incast Threshold ", MakeCallback(SetIncastThreshold));
-  cmd.AddValue ("ds", "Dynamic Subflow ", MakeCallback(SetDynamicSubflow));
-  cmd.AddValue ("cwndmin", "Flows", MakeCallback (SetCwndMin));
-  cmd.AddValue ("rwndscale", "Flows", MakeCallback (SetRcwndScale));
-  cmd.AddValue ("ssf", "Special subflow", MakeCallback (SetSpecialSubflow));
-  cmd.AddValue ("ss",  "Special Source Active", MakeCallback (SetSpecialSource));
-  cmd.AddValue ("sft", "Special FlowType", MakeCallback (SetSpecialFlowType));
-  cmd.AddValue ("sfn", "Special FlowNumber", MakeCallback (SetSpecialFlowNumber));
-  cmd.AddValue ("fn", "Flows", MakeCallback(SetFlowNumber));
-  cmd.AddValue ("ft", "FlowType", MakeCallback(SetFlowType));
-  cmd.AddValue ("sdel", "Set SlowDownEcnLike -- ECN", MakeCallback(SetSDEL));
-  cmd.AddValue ("fg", "Flow Gap", MakeCallback(SetFlowGap));
-  cmd.AddValue ("dtqmt", "DropTailQueue Marking Threshold", MakeCallback(SetDTQMarkTh));
-  cmd.AddValue ("dfa", " DCTCP Non-Smoothed Alpha", MakeCallback (SetDctcpFastAlpha));
-  cmd.AddValue ("dapa", "DCTCP ALPHA PER ACK", MakeCallback (SetDctcpAlphaPerAck));
-  cmd.AddValue ("qsi", "queue sampling interval", MakeCallback (SetQueueSamplingInterval));
-  cmd.AddValue ("qmb", "QUEUE_MODE_BYTES", MakeCallback (SetQueueMode));
-  cmd.AddValue ("sdxl", " slow down xmp like", MakeCallback (SetSDXL));
-  cmd.AddValue ("ecn", " enable ECN", MakeCallback (SetECN));
-  cmd.AddValue ("ld", " Set Link Delay", MakeCallback (SetLinkDelay));
-  cmd.AddValue ("sim", "Set sim name", MakeCallback (SetSimName));
-  cmd.AddValue ("sf", "Number of MPTCP SubFlows", MakeCallback (SetNumSubflow));
-  cmd.AddValue ("i", "Set simulation instance number as a string", MakeCallback (SetSimInstance));
-  cmd.AddValue ("red", "Enable RED Queue Disiplone", MakeCallback (SetRED));
-  cmd.AddValue ("dctcp", "Enable DCTCP Capability", MakeCallback (SetDCTCP));
-  cmd.AddValue ("redmax", "RED Max Threshold", MakeCallback (SetREDmax));
-  cmd.AddValue ("redmin", "RED min Threshold", MakeCallback (SetREDmin));
-  cmd.AddValue ("redql", "RED Queue Limit", MakeCallback (SetREDQueueLimit));
-  cmd.AddValue ("redweight", "RED Weight", MakeCallback (SetREDweight));
-  cmd.AddValue ("DCTCPweight", "DCTCP Weight", MakeCallback (SetDCTCPweight));
-  cmd.AddValue ("lfplot", "Activate plotting at MpTcpSocketBase", MakeCallback (SetLfPlot));
-  cmd.AddValue ("sfplot", "Activate short flow plotting at MpTcpSocketBase", MakeCallback (SetSfPlot));
-  cmd.AddValue ("st", "Simulation Time", MakeCallback (SetSimTime));
-  cmd.AddValue ("na", "NetAnim: 1=enable, 0=disable", MakeCallback (SetNetAnim));
-  cmd.AddValue ("cc", "MPTCP Congestion Control algorithm", MakeCallback (SetCongestionControl));
-  cmd.AddValue ("gamma", " XMP's gamma", MakeCallback (SetXmpGamma));
-  cmd.AddValue ("beta", " XMP's beta", MakeCallback (SetXmpBeta));
-  cmd.AddValue ("rateplot", " Activate Rate Plotting", MakeCallback (SetRatePlot));
-  cmd.AddValue ("ratebeat", " Activate Rate Plotting", MakeCallback (SetRateBeat));
-
-  cmd.Parse (argc, argv);
-  Config::SetDefault ("ns3::MpTcpSocketBase::DisjoinedPath", BooleanValue (g_disjoinedPath));
-  Config::SetDefault ("ns3::MpTcpSocketBase::IncastThresh", UintegerValue(g_incastThreshold));
-  Config::SetDefault ("ns3::MpTcpSocketBase::DynamicSubflow", BooleanValue(g_dynamicSubflow));
-  Config::SetDefault ("ns3::MpTcpSocketBase::CwndMin", UintegerValue (g_cwndMin));
-  Config::SetDefault ("ns3::MpTcpSocketBase::RwndScale", UintegerValue (g_rwndScale));
-  Config::SetDefault ("ns3::MpTcpSocketBase::DctcpAlphaPerAck", BooleanValue (g_dctcpAlphaPerAck)); //SHOULD BE FALSE!!!
-  Config::SetDefault ("ns3::MpTcpSocketBase::SlowDownXmpLike", BooleanValue (g_slowDownXmpLike));
-  Config::SetDefault ("ns3::MpTcpSocketBase::ECN", BooleanValue (g_ecn));
-  Config::SetDefault ("ns3::MpTcpSocketBase::LargePlotting", BooleanValue (g_enableLfPlotting));
-  Config::SetDefault ("ns3::MpTcpSocketBase::ShortPlotting", BooleanValue (g_enableSfPlotting));
-  Config::SetDefault ("ns3::MpTcpSocketBase::RatePlotSf", BooleanValue (g_enableRatePlotting));
-  Config::SetDefault ("ns3::MpTcpSocketBase::RatePlotCl", BooleanValue (g_enableRatePlotting));
-  Config::SetDefault ("ns3::MpTcpSocketBase::RateInterval", DoubleValue (g_rateBeat));
-  Config::SetDefault ("ns3::MpTcpSocketBase::RandomGap", UintegerValue (50));
-  Config::SetDefault ("ns3::DropTailQueue::Mode", StringValue ("QUEUE_MODE_PACKETS"));
-  Config::SetDefault ("ns3::DropTailQueue::MaxPackets", UintegerValue (100));
-//Config::SetDefault ("ns3::DropTailQueue::Marking", BooleanValue(g_enableDCTCP));
-//Config::SetDefault ("ns3::DropTailQueue::MarkingTh", UintegerValue(g_DTQmarkTh));
-  if (g_queueModeBytes)
-    { // DropTailQueue
-    //Config::SetDefault("ns3::DropTailQueue::MarkingTh", UintegerValue(g_DTQmarkTh * 1400));
-      Config::SetDefault("ns3::DropTailQueue::Mode", StringValue("QUEUE_MODE_BYTES"));
-      Config::SetDefault("ns3::DropTailQueue::MaxBytes", UintegerValue(g_REDQueueLimit * 1400));
-    }
-  Config::SetDefault ("ns3::TcpSocket::SegmentSize", UintegerValue (g_segmentSize));
-  Config::SetDefault ("ns3::MpTcpSocketBase::gamma", UintegerValue (g_XmpGamma));
-  Config::SetDefault ("ns3::MpTcpSocketBase::beta", UintegerValue (g_XmpBeta));
-  Config::SetDefault ("ns3::TcpSocket::DelAckCount", UintegerValue (0));
-
-  if (g_enableDCTCP)
-    {
-      Config::SetDefault ("ns3::MpTcpSocketBase::DCTCP", BooleanValue (g_enableDCTCP));
-      Config::SetDefault ("ns3::MpTcpBulkSendApplication::DCTCP", BooleanValue (g_enableDCTCP)); // Source Control
-      Config::SetDefault ("ns3::MpTcpSocketBase::DCTCPWeight", DoubleValue (g_DCTCPWeight));
-      Config::SetDefault ("ns3::RedQueue::UseCurrent", BooleanValue (true));
-    }
-  if (g_enableRED)
-    {
-      assert (g_REDmaxTh == g_REDminTh);
-      Config::SetDefault ("ns3::RedQueue::Mode", StringValue ("QUEUE_MODE_PACKETS"));
-      Config::SetDefault ("ns3::RedQueue::MeanPktSize", UintegerValue (g_REDMeanPktSize));
-      Config::SetDefault ("ns3::RedQueue::Wait", BooleanValue (true));
-      Config::SetDefault ("ns3::RedQueue::Gentle", BooleanValue (g_REDGentle));
-      Config::SetDefault ("ns3::RedQueue::QW", DoubleValue (g_REDWeight));
-      Config::SetDefault ("ns3::RedQueue::MinTh", DoubleValue (g_REDminTh));
-      Config::SetDefault ("ns3::RedQueue::MaxTh", DoubleValue (g_REDmaxTh));
-      Config::SetDefault ("ns3::RedQueue::QueueLimit", UintegerValue (g_REDQueueLimit));
-      Config::SetDefault ("ns3::RedQueue::UseCurrent", BooleanValue (true));
-      if (g_queueModeBytes)
-        {
-          Config::SetDefault("ns3::RedQueue::Mode", StringValue("QUEUE_MODE_BYTES"));
-          Config::SetDefault("ns3::RedQueue::QueueLimit", UintegerValue(g_REDQueueLimit * 1400));
-          Config::SetDefault("ns3::RedQueue::MinTh", DoubleValue(g_REDminTh * 1400));
-          Config::SetDefault("ns3::RedQueue::MaxTh", DoubleValue(g_REDmaxTh * 1400));
-        }
-    }
-  /* Uncoupled_TCPs, Linked_Increases, RTT_Compensator, Fully_Coupled */
-  Config::SetDefault ("ns3::MpTcpSocketBase::CongestionControl", StringValue (g_cc));
-  Config::SetDefault ("ns3::MpTcpBulkSendApplication::CongestionControl", StringValue (g_cc));
-  Config::SetDefault ("ns3::Ipv4GlobalRouting::FlowEcmpRouting", BooleanValue (true));
-  Config::SetDefault ("ns3::TcpL4Protocol::SocketType", TypeIdValue (MpTcpSocketBase::GetTypeId ()));
-  Config::SetDefault ("ns3::MpTcpSocketBase::PathManagement", StringValue ("NdiffPorts"));
-  Config::SetDefault ("ns3::MpTcpSocketBase::MaxSubflows", UintegerValue (g_subflows)); // Sink
-  Config::SetDefault ("ns3::MpTcpBulkSendApplication::MaxSubflows", UintegerValue (g_subflows)); //Source
-
-  g_seed = static_cast<uint32_t> (atoi (g_simInstance.c_str ()));
-  cout << "Seed             : " << g_seed << endl;
-  srand (g_seed);
-
-  // Topology construction
-  NS_LOG_INFO("Create nodes");
-  // senders
-  Sender_c.Create(g_senders);
-  total_c.Add(Sender_c);
-  // sender_edges
-  Edge_src_c.Create(g_edge_switches);
-  total_c.Add(Edge_src_c);
-  // core_switches
-  Core_c.Create(g_core_switches);
-  total_c.Add(Core_c);
-  // receiver_edges
-  Edge_dst_c.Create(g_edge_switches);
-  total_c.Add(Edge_dst_c);
-  // receivers
-  Receiver_c.Create(g_receivers);
-  total_c.Add(Receiver_c);
-
-  AddNameToEdges();
-
-  NS_LOG_INFO("Install network stack");
-  InternetStackHelper netStack;
-  netStack.Install (total_c);
-
-  NS_LOG_INFO("Create channel");
-  PointToPointHelper p2p;
-  p2p.SetQueue ("ns3::DropTailQueue");
-  p2p.SetDeviceAttribute ("DataRate", StringValue (g_linkCapacity));
-  p2p.SetChannelAttribute ("Delay", StringValue (g_linkDelay));
-  if (g_enableRED)
-    {
-      p2p.SetQueue ("ns3::RedQueue", "LinkBandwidth", StringValue (g_linkCapacity), "LinkDelay", StringValue (g_linkDelay));
-      p2p.SetDeviceAttribute ("DataRate", StringValue (g_linkCapacity));
-      p2p.SetChannelAttribute ("Delay", StringValue (g_linkDelay));
-    }
-
-  // Initialized Address Helper
-  NS_LOG_INFO("Assign IP addresses");
-  Ipv4AddressHelper ipv4Address;
-
-  // Connecting Senders to Edge Switches
-  cout << "-------------------------------" << endl;
-  cout << "Sender to Edge" << endl;
-  stringstream ss;
-  for (uint32_t s = 0; s < Sender_c.GetN (); s++)
-    {
-      for (uint32_t e = 0; e < Edge_src_c.GetN (); e++)
-        {
-          ss.str ("");
-          ss << "10." << Sender_c.Get (s)->GetId () << "." << Edge_src_c.Get (e)->GetId () << "." << "0";
-          string tmp = ss.str ();
-          cout << tmp << endl;
-          const char* address = tmp.c_str ();
-          ipv4Address.SetBase (address, "255.255.255.0");
-          ipv4Address.Assign (p2p.Install (NodeContainer (Sender_c.Get (s), Edge_src_c.Get (e))));
-        }
-    }
-  // Connecting Edge Switches to Core Switches
-  cout << "Edge to Core" << endl;
-  for (uint32_t edge = 0; edge < Edge_src_c.GetN (); edge++)
-    {
-      for (uint32_t core = 0; core < Core_c.GetN (); core++)
-        {
-          ss.str ("");
-          ss << "10." << Edge_src_c.Get (edge)->GetId () << "." << Core_c.Get (core)->GetId () << "." << "0";
-          string tmp = ss.str ();
-          cout << tmp << endl;
-          const char* address = tmp.c_str ();
-          ipv4Address.SetBase (address, "255.255.255.0");
-          ipv4Address.Assign (p2p.Install (NodeContainer (Edge_src_c.Get (edge), Core_c.Get(core))));
-        }
-    }
-  // Connecting core switches to receiver edge switches
-  cout << "Core to Edge" << endl;
-  for (uint32_t core = 0; core < Core_c.GetN (); core++)
-    {
-      for (uint32_t edge = 0; edge < Edge_dst_c.GetN (); edge++)
-        {
-          ss.str ("");
-          ss << "10." << Core_c.Get (core)->GetId () << "." << Edge_dst_c.Get (edge)->GetId () << "." << "0";
-          string tmp = ss.str ();
-          cout << tmp << endl;
-          const char* address = tmp.c_str ();
-          ipv4Address.SetBase (address, "255.255.255.0");
-          ipv4Address.Assign (p2p.Install (NodeContainer (Core_c.Get (core), Edge_dst_c.Get(edge))));
-        }
-    }
-  // Connecting receiver edge switches to receivers
-  cout << "Edge to Receivers" << endl;
-  for (uint32_t e = 0; e < Edge_dst_c.GetN (); e++)
-    {
-      for (uint32_t r = 0; r < Receiver_c.GetN (); r++)
-        {
-          ss.str ("");
-          ss << "10." << Edge_dst_c.Get (e)->GetId () << "." << Receiver_c.Get (r)->GetId () << "." << "0";
-          string tmp = ss.str ();
-          cout << tmp << endl;
-          const char* address = tmp.c_str ();
-          ipv4Address.SetBase (address, "255.255.255.0");
-          ipv4Address.Assign (p2p.Install (NodeContainer (Edge_dst_c.Get (e), Receiver_c.Get(r))));
-        }
-    }
-
-  NS_LOG_INFO("Install Routing tables");
-  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();
-
-  QueueMonitor ();
-
-  NS_LOG_INFO("Create Applications");
-  // MPTCP SINK
-  uint32_t servPort = 5000;
-  for (uint32_t i = 0; i < Receiver_c.GetN (); i++)
-    {
-      MpTcpPacketSinkHelper sink ("ns3::TcpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), servPort));
-      ApplicationContainer sinkApp = sink.Install (Receiver_c.Get (i));
-      sinkApp.Start (Seconds (0.0));
-    }
-
-  PrintParams();
-
-  // MPTCP SOURCE
-  for (uint32_t i = 0; i < g_flowNumber; i++)
-    {
-      string tmpFlowType = "";
-      MpTcpBulkSendHelper source ("ns3::TcpSocketFactory", InetSocketAddress (GetIpAddr(Receiver_c, i), servPort));
-      source.SetAttribute ("FlowId", UintegerValue (i + 1));
-      source.SetAttribute ("MaxBytes", UintegerValue (g_flowSize));
-
-      if (g_specialSource && i < g_specialFlowNumber)
-        tmpFlowType = SetupSpecialSource (source , i);
-      else
-        tmpFlowType = SetupSource (source, i);
-
-//      source.SetAttribute ("OutputFileName", StringValue (SetupSimFileName (i + 1)));
-//      ApplicationContainer sourceApps = source.Install (Sender_c.Get (i));
-//      sourceApps.Start (Seconds (i * g_flowgap));
-//      sourceApps.Stop (Seconds (g_simTime));
-
-      cout << "Flow " << i << " [" << tmpFlowType << "] Installed on server " << i << " [" << GetIpAddr (Sender_c, i) << " -> "
-           << GetIpAddr (Receiver_c, i) << "] start at " << i * g_flowgap << endl;
-     }
-
-  // NetAnim
-  if (g_enableAnim)
-    { // Create Animation object and configure for specified output
-      AnimationInterface anim ("trash-animation", 1000000000);
-      anim.EnablePacketMetadata (true);
-    }
-
-  NS_LOG_INFO("Simulation run");
-  SimTimeMonitor();//Simulator::Schedule (Seconds (1), &SimTimeMonitor);
-  Simulator::Run ();
-  Simulator::Stop (Seconds (100));
-  GenerateQueuePlot ();
-  Simulator::Destroy ();
-  NS_LOG_INFO("Simulation End");
-}
diff --git a/src/applications/model/mp-tcp-bulk-send-application.cc b/src/applications/model/mp-tcp-bulk-send-application.cc
index 00d7c5f..8a38164 100644
--- a/src/applications/model/mp-tcp-bulk-send-application.cc
+++ b/src/applications/model/mp-tcp-bulk-send-application.cc
@@ -212,6 +212,7 @@ void MpTcpBulkSendApplication::StartApplication (void) // Called at time specifi
       m_socket->SetOutputFileNameDctcp(m_outputFileNameDctcp);
       m_socket->SetDctcp(m_DCTCP);
       m_socket->SetFlowSize(m_maxBytes);
+      NS_LOG_UNCOND ("SEND app:" << m_cc);
       m_socket->SetCCAlgo(m_cc);
       m_socket->SetDctcpFastAlpha(m_dctcpFastAlpha);
       m_socket->SetSlowDownEcnLike(m_slowDownEcnLike);
diff --git a/src/internet/helper/stone-acl-helper.cc b/src/internet/helper/stone-acl-helper.cc
new file mode 100644
index 0000000..684cea0
--- /dev/null
+++ b/src/internet/helper/stone-acl-helper.cc
@@ -0,0 +1,41 @@
+/*
+ * Stone ACL implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+
+#include "ns3/stone-acl-helper.h"
+#include "ns3/log.h"
+#include "ns3/ipv4-header.h"
+
+NS_LOG_COMPONENT_DEFINE ("StoneACLHelper");
+using namespace std;
+namespace ns3
+{
+
+
+StoneACLHelper::StoneACLHelper()
+{
+  
+}
+
+void
+StoneACLHelper::CreateAndAggregateObjectFromTypeId (Ptr<Node> node, const std::string typeId)
+{
+  ObjectFactory factory;
+  factory.SetTypeId (typeId);
+  Ptr<Object> obj = factory.Create <Object> ();
+  node->AggregateObject (obj);
+}
+
+void
+StoneACLHelper::Install(Ptr<Node> node, Ipv4Address address, int32_t maxDownlink)
+{
+   NS_LOG_FUNCTION (node->GetId() << address);
+   CreateAndAggregateObjectFromTypeId (node, "ns3::StoneACL");
+   Ptr<StoneACL> stoneACL = node->GetObject<StoneACL> ();
+   stoneACL->SetNetwork (address);
+   stoneACL->SetNode (node);
+   stoneACL->SetMaxDownlink (maxDownlink);
+}
+}//namespace ns3
diff --git a/src/internet/helper/stone-acl-helper.h b/src/internet/helper/stone-acl-helper.h
new file mode 100644
index 0000000..bae2828
--- /dev/null
+++ b/src/internet/helper/stone-acl-helper.h
@@ -0,0 +1,36 @@
+/*
+ * Stone ACL implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+#ifndef STONE_ACL_HELPER_H
+#define STONE_ACL_HELPER_H
+
+#include "ns3/stone-acl.h"
+#include <stdint.h>
+#include <string>
+#include "ns3/object-factory.h"
+#include "ns3/address.h"
+#include "ns3/attribute.h"
+#include "ns3/net-device.h"
+#include "ns3/node-container.h"
+#include "ns3/ipv4-header.h"
+
+using namespace std;
+namespace ns3
+{
+
+class StoneACLHelper
+{
+public:
+  
+  StoneACLHelper ();
+  void Install (Ptr<Node> node, Ipv4Address address, int32_t maxDownlink);
+  void CreateAndAggregateObjectFromTypeId (Ptr<Node> node, const std::string typeId);
+
+};
+
+
+} // namespace ns3
+
+#endif /* IPV4_ADDRESS_HELPER_H */
diff --git a/src/internet/helper/tracc-acl-helper.cc b/src/internet/helper/tracc-acl-helper.cc
new file mode 100644
index 0000000..494b0fe
--- /dev/null
+++ b/src/internet/helper/tracc-acl-helper.cc
@@ -0,0 +1,43 @@
+/*
+ * Tracc ACL implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+
+#include "ns3/tracc-acl-helper.h"
+#include "ns3/log.h"
+#include "ns3/ipv4-header.h"
+
+NS_LOG_COMPONENT_DEFINE ("TraccACLHelper");
+using namespace std;
+namespace ns3
+{
+
+
+TraccACLHelper::TraccACLHelper()
+{
+  
+}
+
+void
+TraccACLHelper::CreateAndAggregateObjectFromTypeId (Ptr<Node> node, const std::string typeId)
+{
+  ObjectFactory factory;
+  factory.SetTypeId (typeId);
+  Ptr<Object> obj = factory.Create <Object> ();
+  node->AggregateObject (obj);
+}
+
+void
+TraccACLHelper::Install (Ptr<Node> node, uint32_t numLeaf, uint32_t numHost, uint32_t numSpine, Ipv4Address address)
+{
+  NS_LOG_FUNCTION (node->GetId() << numLeaf << numHost << numSpine);
+  CreateAndAggregateObjectFromTypeId (node, "ns3::TraccACL");
+  Ptr<TraccACL> traccACL = node->GetObject<TraccACL> ();
+  traccACL->Install (node, numLeaf, numHost, numSpine);
+  traccACL->SetNetwork (address);
+  traccACL->SetTimer ();
+}
+
+
+}//namespace ns3
diff --git a/src/internet/helper/tracc-acl-helper.h b/src/internet/helper/tracc-acl-helper.h
new file mode 100644
index 0000000..31715dc
--- /dev/null
+++ b/src/internet/helper/tracc-acl-helper.h
@@ -0,0 +1,36 @@
+/*
+ * Tracc ACL implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+#ifndef TRACC_ACL_HELPER_H
+#define TRACC_ACL_HELPER_H
+
+#include "ns3/tracc-acl.h"
+#include <stdint.h>
+#include <string>
+#include "ns3/object-factory.h"
+#include "ns3/address.h"
+#include "ns3/attribute.h"
+#include "ns3/net-device.h"
+#include "ns3/node-container.h"
+#include "ns3/ipv4-header.h"
+
+using namespace std;
+namespace ns3
+{
+
+class TraccACLHelper
+{
+public:
+  
+  TraccACLHelper ();
+  void CreateAndAggregateObjectFromTypeId (Ptr<Node> node, const std::string typeId);
+  void Install (Ptr<Node> node, uint32_t numLeaf, uint32_t numHost, uint32_t numSpine, Ipv4Address address);
+
+};
+
+
+} // namespace ns3
+
+#endif /* STONE_ACL_HELPER_H */
diff --git a/src/internet/model/ipv4-global-routing.cc b/src/internet/model/ipv4-global-routing.cc
index 8e6f33e..bfc4b54 100644
--- a/src/internet/model/ipv4-global-routing.cc
+++ b/src/internet/model/ipv4-global-routing.cc
@@ -35,6 +35,7 @@
 #include "ns3/ecmp-tag.h"
 //#include "ns3/hash.h"
 //#include <functional>
+#include "ns3/stone-acl.h"
 
 NS_LOG_COMPONENT_DEFINE ("Ipv4GlobalRouting");
 
@@ -236,7 +237,8 @@ Ipv4GlobalRouting::GetTupleValue(const Ipv4Header &header, Ptr<const Packet> ipP
 Ptr<Ipv4Route>
 Ipv4GlobalRouting::LookupGlobal(const Ipv4Header &header, Ptr<const Packet> ipPayload, Ptr<NetDevice> oif)
 {
-
+  Ptr<Node> node = m_ipv4->GetObject<Node>();
+  
   NS_LOG_FUNCTION (this << header.GetDestination() << oif);
   NS_LOG_LOGIC ("Looking for route for destination " << header.GetDestination());
   Ptr<Ipv4Route> rtentry = 0;
@@ -620,6 +622,10 @@ Ipv4GlobalRouting::RouteInput  (Ptr<const Packet> p, const Ipv4Header &header, P
                                 LocalDeliverCallback lcb,
                                 ErrorCallback ecb)
 { 
+  Ptr<Node> node = m_ipv4->GetObject<Node>();
+  NS_LOG_INFO("routeinput: " << node->GetId());
+
+  
   NS_LOG_FUNCTION (this << p << header << header.GetSource () << header.GetDestination () << idev << &lcb << &ecb);
   // Check if input device supports IP
   NS_ASSERT (m_ipv4->GetInterfaceForDevice (idev) >= 0);
diff --git a/src/internet/model/ipv4-l3-protocol.cc b/src/internet/model/ipv4-l3-protocol.cc
index 61f5862..dd6c41b 100644
--- a/src/internet/model/ipv4-l3-protocol.cc
+++ b/src/internet/model/ipv4-l3-protocol.cc
@@ -32,6 +32,8 @@
 #include "ns3/ipv4-header.h"
 #include "ns3/boolean.h"
 #include "ns3/ipv4-routing-table-entry.h"
+#include "ns3/stone-acl.h"
+#include "ns3/tracc-acl.h"
 
 #include "loopback-net-device.h"
 #include "arp-l3-protocol.h"
@@ -526,6 +528,7 @@ Ipv4L3Protocol::Receive ( Ptr<NetDevice> device, Ptr<const Packet> p, uint16_t p
       socket->ForwardUp (packet, ipHeader, ipv4Interface);
     }
 
+  NS_LOG_LOGIC ("hehehe");
   NS_ASSERT_MSG (m_routingProtocol != 0, "Need a routing protocol object to process packets");
   if (!m_routingProtocol->RouteInput (packet, ipHeader, device,
                                       MakeCallback (&Ipv4L3Protocol::IpForward, this),
@@ -883,6 +886,14 @@ Ipv4L3Protocol::IpForward (Ptr<Ipv4Route> rtentry, Ptr<const Packet> p, const Ip
       m_dropTrace (header, packet, DROP_TTL_EXPIRED, m_node->GetObject<Ipv4> (), interface);
       return;
     }
+    
+  Ptr<StoneACL> stoneAcl = m_node->GetObject<StoneACL>();
+  if (stoneAcl)
+    stoneAcl->ConductTag(packet, header, interface);
+  Ptr<TraccACL> traccACL = m_node->GetObject<TraccACL>();
+  if (traccACL)
+    traccACL->TagCount(packet, header, interface);
+  
   m_unicastForwardTrace (ipHeader, packet, interface);
   SendRealOut (rtentry, packet, ipHeader);
 }
diff --git a/src/internet/model/mp-tcp-socket-base.cc b/src/internet/model/mp-tcp-socket-base.cc
index 322d030..b3807d6 100644
--- a/src/internet/model/mp-tcp-socket-base.cc
+++ b/src/internet/model/mp-tcp-socket-base.cc
@@ -30,6 +30,10 @@
 #include "ns3/ect-tag.h"
 #include "ns3/control-tag.h"
 #include "ns3/ecmp-tag.h"
+#include "ns3/rl-tag.h"
+#include "ns3/li-cx-tag.h"
+#include "ns3/fb-li-tag.h"
+#include "ns3/fb-tag.h"
 
 //#define PLOT
 //#define PLOT_DCTCP
@@ -54,14 +58,14 @@ MpTcpSocketBase::GetTypeId (void)
                      "Congestion control algorithm",
                      EnumValue (Linked_Increases),
                      MakeEnumAccessor (&MpTcpSocketBase::SetCongestionCtrlAlgo),
-                     MakeEnumChecker (Uncoupled_TCPs, "Uncoupled_TCPs", Fully_Coupled, "Fully_Coupled", RTT_Compensator, "RTT_Compensator",
+                     MakeEnumChecker (Uncoupled_TCPs, "Uncoupled_TCPs", Fully_Coupled, "Fully_Coupled", RTT_Compensator, "RTT_Compensator", DCMPTCP, "DCMPTCP",
                            Linked_Increases, "Linked_Increases", COUPLED_INC, "COUPLED_INC", COUPLED_EPSILON, "COUPLED_EPSILON",
                            COUPLED_SCALABLE_TCP, "COUPLED_SCALABLE_TCP", COUPLED_FULLY, "COUPLED_FULLY", UNCOUPLED, "UNCOUPLED", XMP, "XMP", Fast_Uncoupled, "Fast_Uncoupled", Fast_Increases, "Fast_Increases", XCA, "XCA"))
       .AddAttribute ("SchedulingAlgorithm",
                      "Algorithm for data distribution between sub-flows",
                      EnumValue (Round_Robin),
                      MakeEnumAccessor (&MpTcpSocketBase::SetDataDistribAlgo),
-                     MakeEnumChecker (Round_Robin, "Round_Robin"))
+                     MakeEnumChecker (Round_Robin, "Round_Robin", DC_SCHE, "DC_SCHE"))
       .AddAttribute ("PathManagement",
                      "Mechanism for establishing new sub-flows",
                      EnumValue (NdiffPorts),
@@ -202,6 +206,21 @@ MpTcpSocketBase::GetTypeId (void)
                    UintegerValue (10000000), // 10MB
                    MakeUintegerAccessor (&MpTcpSocketBase::m_ADCTthresh),
                    MakeUintegerChecker<uint32_t> ())
+    .AddAttribute ("SlaveIW",
+                   "Initial cwnd size",
+                   UintegerValue (2),
+                   MakeUintegerAccessor (&MpTcpSocketBase::m_slaveIW),
+                   MakeUintegerChecker<uint32_t> ())
+    .AddAttribute ("DCSCHEthresh",
+                   "Threshold of DCSCHE",
+                   UintegerValue (100),
+                   MakeUintegerAccessor (&MpTcpSocketBase::m_dcsche_th),
+                   MakeUintegerChecker<uint32_t> ())
+    .AddAttribute ("DCPerSubflow",
+                   "To use DCMPTCP variant",
+                   BooleanValue (false),
+                   MakeBooleanAccessor (&MpTcpSocketBase::m_dcpersub),
+                   MakeBooleanChecker ())
 //     .AddAttribute ("SlowDownEcnLike",
 //                    "Slow down sending rate based on ECN",
 //                    BooleanValue (false),
@@ -249,6 +268,8 @@ MpTcpSocketBase::MpTcpSocketBase () :
   FullAcks = 0;
   pAck = 0;
   TimeOuts = 0;
+  DCMPTCPCutDowns = 0;
+  DCMPTCPECNCutDowns = 0;
   FastReTxs = 0;
   FastRecoveries = 0;
   SlowDownHits = 0;
@@ -439,11 +460,23 @@ MpTcpSocketBase::ReadOptions (Ptr<Packet> pkt, const TcpHeader& mptcpHeader)
       opt = mp_options[j];
       if ((opt->optName == OPT_MPC) && hasSyn && (mpRecvState == MP_NONE))
         { // SYN+ACK would be send later on by ProcessSynRcvd(...)
-          mpRecvState = MP_MPC;
-          mpEnabled = true;
-          remoteToken = ((OptMultipathCapable *) opt)->senderToken;
-          if (remoteToken == 0)
-            NS_ASSERT(remoteToken != 0); // Correct condition
+          if (!m_rlBit)
+          {
+            mpRecvState = MP_MPC;
+            mpEnabled = true;
+            remoteToken = ((OptMultipathCapable *) opt)->senderToken;
+            if (remoteToken == 0)
+              NS_ASSERT(remoteToken != 0); // Correct condition
+          }
+          else
+          {
+            NS_LOG_INFO("With RL_Tag. Degrade now!");
+            oldAlgoCC = AlgoCC;
+            oldMaxSubflows = maxSubflows;
+            
+            maxSubflows = 1;
+            AlgoCC = Uncoupled_TCPs;
+          }
           return true;
         }
       else
@@ -725,6 +758,12 @@ MpTcpSocketBase::ProcessSynSent (uint8_t sFlowIdx, Ptr<Packet> packet, const Tcp
           fLowStartTime = Simulator::Now ().GetSeconds ();     // It seems to be in right location for FCT!!
           if ((m_ratePlotCl && (flowType.compare ("Short") != 0)) || (m_largePlotting && (flowType.compare ("Short") != 0)))
             RateTracerCl ();
+          if (!mpEnabled)
+          {
+            NS_LOG_INFO("SYN+ACK w/o OPT_MPC. Degrade now!");
+            maxSubflows = 1;
+            AlgoCC = Uncoupled_TCPs;
+          }
         }NS_LOG_INFO("(" << sFlow->routeId << ") "<< TcpStateName[sFlow->state] << " -> ESTABLISHED");
       sFlow->state = ESTABLISHED;
       sFlow->retxEvent.Cancel ();
@@ -1095,6 +1134,8 @@ MpTcpSocketBase::ReceivedData (uint8_t sFlowIdx, Ptr<Packet> p, const TcpHeader&
           else if (optDSN->subflowSeqNumber > sFlow->RxSeqNumber)
             { /* Received packet is out of order at sub-flow level */
               // This condition might occurs when a packet get drop...Does this condition mean that packet should be out of order at connection level? YES
+              NS_LOG_INFO(optDSN->dataSeqNumber << " " << nextRxSequence);
+              NS_LOG_INFO(optDSN->subflowSeqNumber << " " << sFlow->RxSeqNumber);
               NS_ASSERT(optDSN->dataSeqNumber > nextRxSequence);
               StoreUnOrderedData (
                   new DSNMapping (sFlowIdx, optDSN->dataSeqNumber, optDSN->dataLevelLength, optDSN->subflowSeqNumber,
@@ -1140,6 +1181,8 @@ MpTcpSocketBase::ReceivedAck (uint8_t sFlowIdx, Ptr<Packet> packet, const TcpHea
   Ptr<MpTcpSubFlow> sFlow = subflows[sFlowIdx];
   uint32_t ack = (mptcpHeader.GetAckNumber ()).GetValue ();
   sFlow->g_AckSeqNumber = ack;
+  
+  NS_LOG_INFO ("sf:" << sFlowIdx <<" cwnd:"<< sFlow->cwnd.Get());
 
   if ((m_DCTCP && sFlow->state == ESTABLISHED) || m_dctcpFastReTxRecord)
     { // Danger: m_dctcpFastReTxRecord should off in normal run
@@ -1151,6 +1194,10 @@ MpTcpSocketBase::ReceivedAck (uint8_t sFlowIdx, Ptr<Packet> packet, const TcpHea
         }
       CalculateDCTCPAlpha (sFlowIdx, ack);
     }
+  if (AlgoCC == DCMPTCP && sFlow->state == ESTABLISHED && m_dcpersub)
+    {
+      CalculateDCMPTCPAlpha (sFlowIdx, ack);
+    }
 
 #ifdef PLOT
   uint32_t tmp = ((ack - sFlow->initialSequnceNumber) / sFlow->MSS) % mod;
@@ -1219,12 +1266,30 @@ MpTcpSocketBase::ReceivedAck (uint8_t sFlowIdx, Ptr<Packet> packet, const TcpHea
 
 }
 
+void
+MpTcpSocketBase::DCMPTCPECNSlowDown (uint8_t sFlowIdx)
+{
+  NS_ASSERT(client);
+  Ptr<MpTcpSubFlow> sFlow = subflows[sFlowIdx];
+  int32_t old_cwnd = sFlow->cwnd.Get ();
+  
+  double tmp = old_cwnd * 0.5;
+
+  if (tmp < 0)
+    tmp = 0;
+  sFlow->cwnd = std::max ((uint32_t) tmp, (m_cwndMin * sFlow->MSS));
+  sFlow->ssthresh = std::max (sFlow->MSS, sFlow->cwnd.Get ());
+  NS_LOG_INFO ("DCMPTCP ECN Slow Down o:" << old_cwnd << " n:" << sFlow->cwnd.Get () << " maxseq:" <<subflows[sFlowIdx]->dcmptcp_maxseq<< " "<< subflows[sFlowIdx]->TxSeqNumber << " highestackp1:"<< (subflows[sFlowIdx]->highestAck + 1));
+}
+
+
 // XMP: Congestion Window Decrease Multiplicatively
 void
 MpTcpSocketBase::DoXMPEnterCWR (uint8_t sFlowIdx)
 {
   assert (!m_DCTCP);
   NS_LOG_FUNCTION((int) sFlowIdx);
+  NS_LOG_INFO("XMP decrease");
   SlowDownHits++;
   Ptr<MpTcpSubFlow> subflow = subflows[sFlowIdx];
   uint32_t cwnd = subflow->cwnd.Get () / subflow->MSS;
@@ -1505,6 +1570,49 @@ MpTcpSocketBase::CalculateDCTCPAlpha (uint8_t sFlowIdx, uint32_t ack)
 }
 
 void
+MpTcpSocketBase::CalculateDCMPTCPAlpha (uint8_t sFlowIdx, uint32_t ack)
+{
+  NS_LOG_FUNCTION((int) sFlowIdx << ack);
+  Ptr<MpTcpSubFlow> sFlow = subflows[sFlowIdx];
+
+  sFlow->dcmptcp_total++;
+  if (m_eceBit > 0)
+    {
+      sFlow->dcmptcp_marked++;
+    }
+  /* Check for barrier indicating its time to recalculate alpha.
+   * This code basically updated alpha roughly once per RTT.
+   */
+
+  NS_LOG_INFO ("CalculateDCMPTCPAlpha sf:" << (uint32_t) sFlowIdx <<" "<< sFlow->dcmptcp_marked << " " 
+        << sFlow->dcmptcp_total << " " << ack << " " << sFlow->dcmptcp_alpha_update_seq);
+  if (ack > sFlow->dcmptcp_alpha_update_seq)
+    {
+      double temp_alpha;
+      if (sFlow->dcmptcp_total > 0)
+        {
+          temp_alpha = ((double) sFlow->dcmptcp_marked) / sFlow->dcmptcp_total;
+        }
+      else
+        {
+          temp_alpha = 0.0;
+        }
+  
+      NS_LOG_INFO ("CalculateDCMPTCPAlpha temp_alpha:" << temp_alpha <<" "<< sFlow->dcmptcp_alpha);
+      sFlow->dcmptcp_alpha = (1 - m_g) * sFlow->dcmptcp_alpha + m_g * temp_alpha;
+
+      if (sFlow->dcmptcp_alpha > 1.0)
+        sFlow->dcmptcp_alpha = 1.0;
+
+
+      NS_LOG_INFO ("CalculateDCMPTCPAlpha temp_alpha:" << temp_alpha <<" "<< sFlow->dcmptcp_alpha);
+      sFlow->dcmptcp_marked = 0;
+      sFlow->dcmptcp_total = 0;
+      sFlow->dcmptcp_alpha_update_seq = sFlow->TxSeqNumber;
+    }
+}
+
+void
 MpTcpSocketBase::SetSegSize (uint32_t size)
 {
   segmentSize = size;
@@ -1582,9 +1690,13 @@ MpTcpSocketBase::SendDataPacket (uint8_t sFlowIdx, uint32_t size, bool withAck)
   NS_ASSERT(packetSize <= size);
   NS_ASSERT(packetSize == p->GetSize ());
 
+  NS_LOG_INFO ("CC:" << AlgoCC);
   // @SendDataPacket -> Add ECT Tag on every data packet... We do this for ack packets as well
-  if (m_DCTCP || AlgoCC == XMP || m_ecn)
+  if (m_DCTCP || AlgoCC == XMP || m_ecn || AlgoCC == DCMPTCP)
+  {
+    //NS_LOG_INFO ("Data packets with ECT." << (AlgoCC == DCMPTCP));
     AddPacketTag(p, ECT_TAG); //AddEctTag(p);
+  }
   // @SendDataPacket
   if (m_disjoinPath && flowType.compare ("Large") == 0)
     AddEcmpTag(p, sFlow->routeId);
@@ -1678,7 +1790,7 @@ MpTcpSocketBase::SendDataPacket (uint8_t sFlowIdx, uint32_t size, bool withAck)
   sFlow->DATA.push_back (make_pair (Simulator::Now ().GetSeconds (), tmp));
 #endif
 
-  NS_LOG_LOGIC(Simulator::Now().GetSeconds() << " ["<< m_node->GetId()<< "] SendDataPacket->  " << header <<" dSize: " << packetSize<< " sFlow: " << sFlow->routeId);
+  NS_LOG_LOGIC(Simulator::Now().GetSeconds() << " ["<< m_node->GetId()<< "] SendDataPacket->  " << sFlow->sAddr<<" "<<sFlow->dAddr<<" "<< header <<" dSize: " << packetSize<< " sFlow: " << sFlow->routeId);
 
   // Do some updates.....
   sFlow->rtt->SentSeq (SequenceNumber32 (sFlow->TxSeqNumber), packetSize); // Notify the RTT of a data packet sent
@@ -1856,7 +1968,7 @@ MpTcpSocketBase::DoRetransmit (uint8_t sFlowIdx)
   header.SetPaddingLength (plen);
 
   // @DoRetransmit -> Add ECT Tag on every data packet... We do this for ack packets as well
-  if (m_DCTCP || AlgoCC == XMP || m_ecn)
+  if (m_DCTCP || AlgoCC == XMP || m_ecn || AlgoCC == DCMPTCP)
     AddPacketTag(pkt, ECT_TAG);
   // @DoRetransmit
   if (m_disjoinPath && flowType.compare ("Large") == 0)
@@ -1926,7 +2038,7 @@ MpTcpSocketBase::DoRetransmit (uint8_t sFlowIdx, DSNMapping* ptrDSN)
   header.SetPaddingLength (plen);
 
   // @DoRetransmit -> Add ECT Tag on every data packet... We do this for ack packets as well
-  if (m_DCTCP || AlgoCC == XMP || m_ecn)
+  if (m_DCTCP || AlgoCC == XMP || m_ecn || AlgoCC == DCMPTCP)
     AddPacketTag (pkt, ECT_TAG);
   // @DoRetransmit
   if (m_disjoinPath && flowType.compare ("Large") == 0)
@@ -2095,7 +2207,8 @@ MpTcpSocketBase::Connect (Ipv4Address servAddr, uint16_t servPort)
   sFlow->sAddr = m_endPoint->GetLocalAddress ();
   sFlow->sPort = m_endPoint->GetLocalPort ();
   sFlow->MSS = segmentSize;
-  sFlow->cwnd = sFlow->MSS;
+  //sFlow->cwnd = sFlow->MSS;
+  sFlow->cwnd = this->GetInitialCwnd() * sFlow->MSS;
   NS_LOG_UNCOND ("Connect -> SegmentSize: " << sFlow->MSS << " tcpSegmentSize: " << m_segmentSize << " segmentSize: " << segmentSize << "SendingBufferSize: " << sendingBuffer.bufMaxSize);
 
   // This is master subsocket (master subflow) then its endpoint is the same as connection endpoint.
@@ -2264,7 +2377,60 @@ MpTcpSocketBase::SendPendingData (uint8_t sFlowIdx)
         SlowDownEcnLike (sFlowIdx);
       else
         SlowDown (sFlowIdx);
+      
+      DCMPTCPCutDowns++;
     }
+    //DCMPTCP
+
+  if (!m_dcpersub)
+    {
+      if (AlgoCC == DCMPTCP && sFlowIdx < maxSubflows && m_licx > 0 && m_fb > 0 && subflows[sFlowIdx]->state == ESTABLISHED
+          && subflows[sFlowIdx]->dcmptcp_maxseq < (subflows[sFlowIdx]->highestAck + 1))
+        {
+          NS_LOG_INFO ("Cutting down CWND because we've received LICX:" << "sub" << (int32_t)sFlowIdx << " licx" << (int32_t)m_licx);
+          NS_ASSERT(client);
+          Ptr<MpTcpSubFlow> sFlow = subflows[sFlowIdx];
+          int32_t old_cwnd = sFlow->cwnd.Get ();
+          
+          double tmp = old_cwnd * (1 - 1.0 * m_licx / 16 / 2);
+
+          if (tmp < 0)
+            tmp = 0;
+          sFlow->cwnd = std::max ((uint32_t) tmp, (m_cwndMin * sFlow->MSS));
+          sFlow->ssthresh = std::max (sFlow->MSS, sFlow->cwnd.Get ());
+          
+          NS_LOG_INFO ("o:" << old_cwnd << " n:" << sFlow->cwnd.Get () << " maxseq:" <<subflows[sFlowIdx]->dcmptcp_maxseq<< " "<< subflows[sFlowIdx]->TxSeqNumber << " highestackp1:"<< (subflows[sFlowIdx]->highestAck + 1));
+          subflows[sFlowIdx]->dcmptcp_maxseq = subflows[sFlowIdx]->TxSeqNumber;
+          
+          DCMPTCPCutDowns++;
+        }
+    }
+  else
+    {
+      if (AlgoCC == DCMPTCP && sFlowIdx < maxSubflows && m_eceBit > 0 && subflows[sFlowIdx]->state == ESTABLISHED
+          && subflows[sFlowIdx]->dcmptcp_maxseq < (subflows[sFlowIdx]->highestAck + 1))
+        {
+          NS_LOG_INFO ("PerSub Cutting down CWND:" << "sub" << (int32_t)sFlowIdx);
+          NS_ASSERT(client);
+          Ptr<MpTcpSubFlow> sFlow = subflows[sFlowIdx];
+          int32_t old_cwnd = sFlow->cwnd.Get ();
+
+          double alpha = sFlow->dcmptcp_alpha;
+
+          double tmp = sFlow->cwnd.Get () * (1 - alpha / 2);
+          if (tmp < 0) 
+            tmp = 0;
+          sFlow->cwnd = std::max ((uint32_t) tmp, (m_cwndMin * sFlow->MSS));
+          sFlow->ssthresh = std::max (sFlow->MSS, sFlow->cwnd.Get ());
+          sFlow->dcmptcp_maxseq = sFlow->TxSeqNumber;
+
+          NS_LOG_INFO ("o:" << old_cwnd << " n:" << sFlow->cwnd.Get () << " alpha:" << sFlow->dcmptcp_alpha << " maxseq:" <<subflows[sFlowIdx]->dcmptcp_maxseq<< " "<< subflows[sFlowIdx]->TxSeqNumber << " highestackp1:"<< (subflows[sFlowIdx]->highestAck + 1));
+
+          DCMPTCPCutDowns++;
+        }
+    }
+  
+    
   /*
   // XMP: If we have received ECN echo in some of the received ACKs, cut the cwnd by half only once per round
   if (AlgoCC == XMP && sFlowIdx < maxSubflows && m_eceBit > 0 && subflows[sFlowIdx]->state == ESTABLISHED)
@@ -2397,6 +2563,13 @@ MpTcpSocketBase::getSubflowToUse ()
   case Round_Robin:
     nextSubFlow = (lastUsedsFlowIdx + 1) % subflows.size ();
     break;
+  case DC_SCHE:
+    if (nextTxSequence <= m_dcsche_th * 1024)
+      nextSubFlow = 0;
+    else
+      nextSubFlow = (lastUsedsFlowIdx + 1) % subflows.size ();
+    NS_LOG_INFO("DC_SCHE:" << nextTxSequence << " " << m_dcsche_th << " " << (uint32_t) nextSubFlow);
+    break;
   default:
     break;
     }
@@ -2459,6 +2632,7 @@ MpTcpSocketBase::ReduceCWND (uint8_t sFlowIdx, DSNMapping* ptrDSN)
   case UNCOUPLED:
   case XMP:
   case XCA:
+  case DCMPTCP:
   //sFlow->ssthresh = std::max (2 * mss, BytesInFlight (sFlowIdx) / 2);
     sFlow->ssthresh = std::max (2 * mss, flightSize/2);
     sFlow->cwnd = sFlow->ssthresh + 3 * mss;
@@ -2568,6 +2742,13 @@ MpTcpSocketBase::Retransmit (uint8_t sFlowIdx)
       //sFlow->m_sumRTT = 0;
       //sFlow->m_nECE = 0;
     }
+    //DCMPTCP
+    if (AlgoCC == DCMPTCP)
+    {
+      if (m_dcpersub)
+          sFlow->dcmptcp_alpha_update_seq = sFlow->TxSeqNumber;
+      sFlow->dcmptcp_maxseq = sFlow->TxSeqNumber;
+    }
 
   //if (!(sendingBuffer->Empty() && sFlow->mapDSN.size() > 0))
   sFlow->rtt->IncreaseMultiplier ();  // Double the next RTO
@@ -2843,14 +3024,37 @@ MpTcpSocketBase::SendEmptyPacket (uint8_t sFlowIdx, uint8_t flags)
   header.SetPaddingLength (plen);
   // @SendEmptyPacket
   if (m_ceBit > 0 && isAck && sFlow->state == ESTABLISHED && server)
+  {
     AddPacketTag (p, ECE_TAG);
+    NS_LOG_INFO ("ECE marked at receiver");
+  }
+  
+  if (m_licx > 0 && isAck && sFlow->state == ESTABLISHED && server)
+  {
+    FBLITag fbliTag;
+    fbliTag.SetFBLI (m_licx - 1);
+    p->AddPacketTag (fbliTag);
+    NS_LOG_INFO ("FBLI marked at receiver:" << (int32_t)m_licx);
+  }
+  
+  if (isAck && sFlow->state == ESTABLISHED && server)
+  {    
+    FBTag fbTag;
+    fbTag.SetFB (1);
+    p->AddPacketTag (fbTag);
+    NS_LOG_INFO ("FB marked at receiver");
+  }
+  else if (server)
+    NS_LOG_INFO ("No FB marked at receiver");
+  
+  
 
   // @SendEmptyPacket -> Add control packet tag
   if (hasSyn || hasFin || (isAck && client))
     AddPacketTag (p, CP_TAG); //AddContPktTag(p);
 
   // @SendEmptyPacket -> Add ECT Tag on ACK packet of DCTCP/XMP traffic... We do this for ack data packet as well.
-  if (m_DCTCP || AlgoCC == XMP || m_ecn)
+  if (m_DCTCP || AlgoCC == XMP || m_ecn || AlgoCC == DCMPTCP)
     AddPacketTag (p, ECT_TAG); //AddEctTag(p);
 
   m_tcp->SendPacket (p, header, sFlow->sAddr, sFlow->dAddr, FindOutputNetDevice (sFlow->sAddr));
@@ -2872,7 +3076,7 @@ MpTcpSocketBase::SendEmptyPacket (uint8_t sFlowIdx, uint8_t flags)
     }
 
   //if (!isAck)
-  NS_LOG_INFO("("<< (int)sFlowIdx<<") SendEmptyPacket-> "<< header <<" Length: "<< (int)header.GetLength());
+  NS_LOG_INFO("("<< (int)sFlowIdx<<") SendEmptyPacket-> "<< sFlow->sAddr << sFlow->dAddr <<header <<" Length: "<< (int)header.GetLength());
 }
 
 //void
@@ -2954,18 +3158,47 @@ MpTcpSocketBase::ExtractPacketTags (Ptr<Packet> p)
 {
   m_ceBit = 0;
   m_eceBit = 0;
+  m_rlBit = 0;
+  m_licx = 0;
+  m_fb = 0;
+  FBTag fb;
+  bool fb_exist = p->RemovePacketTag (fb);
+  if (fb_exist)
+  {
+    m_fb = fb.GetFB ();
+  }
+  
+  RLTag rlTag;
+  bool done = p->RemovePacketTag (rlTag);
+  if (done)
+  {
+    m_rlBit = rlTag.GetRL ();
+  }
+  
   CeTag tag;
-  bool done = p->RemovePacketTag (tag);
+  done = p->RemovePacketTag (tag);
   if (done)
     {
       m_ceBit = tag.GetCe ();
+      NS_LOG_INFO ("ce marked receive");
     }
+    
   EceTag ece;
   done = p->RemovePacketTag (ece);
   if (done)
     {
       m_eceBit = ece.GetEce ();
+      NS_LOG_INFO("ECE received at sender");
     }
+  
+  LICXTag licx;
+  done = p->RemovePacketTag (licx);
+  if (done)
+  {
+    m_licx = licx.GetLICX ();
+    NS_LOG_INFO ("Got licx:" << (int32_t)m_licx);
+  }
+    
   ControlTag ct; // Just remove it from packet.
   p->RemovePacketTag (ct);
   EctTag ect;
@@ -2983,13 +3216,16 @@ MpTcpSocketBase::DoForwardUp (Ptr<Packet> p, Ipv4Header header, uint16_t port, P
     }NS_LOG_FUNCTION(this<< " SubflowSize["<<subflows.size() << "]");
   Address fromAddress = InetSocketAddress (header.GetSource (), port);
   Address toAddress = InetSocketAddress (header.GetDestination (), m_endPoint->GetLocalPort ());
-
+  
+  NS_LOG_INFO(header.GetSource () << "->" << header.GetDestination ());
   m_localAddress = header.GetDestination ();
   m_remoteAddress = header.GetSource ();
 
   // Peel off TCP header and do validity checking
   TcpHeader mptcpHeader;
+  NS_LOG_INFO(mptcpHeader);
   p->RemoveHeader (mptcpHeader);
+  NS_LOG_INFO(mptcpHeader);
 
   // DCTCP
   ExtractPacketTags(p);
@@ -3006,6 +3242,10 @@ MpTcpSocketBase::DoForwardUp (Ptr<Packet> p, Ipv4Header header, uint16_t port, P
       NS_ASSERT(server && m_state == LISTEN); NS_LOG_UNCOND("Listening socket receives SYN packet, it need to be CLONED... " << mptcpHeader);
       // Update the flow control window
       remoteRecvWnd = (uint32_t) mptcpHeader.GetWindowSize ();
+ 
+      oldAlgoCC = AlgoCC;
+      oldMaxSubflows = maxSubflows;
+      
       // We need to define another ReadOption with no subflow in it
       if (ReadOptions (p, mptcpHeader) == false)
         return;
@@ -3018,6 +3258,8 @@ MpTcpSocketBase::DoForwardUp (Ptr<Packet> p, Ipv4Header header, uint16_t port, P
       remoteToken = 0;
       localToken = 0;
       remoteRecvWnd = 1;
+      AlgoCC = oldAlgoCC;
+      maxSubflows = oldMaxSubflows;
       return;
     }
   // Accepted sockets being dealt with from here on .......
@@ -3027,6 +3269,7 @@ MpTcpSocketBase::DoForwardUp (Ptr<Packet> p, Ipv4Header header, uint16_t port, P
 
   if (client && sFlowIdx > maxSubflows)
     exit (20);
+  //NS_LOG_UNCOND(sFlowIdx << " " << (uint32_t)maxSubflows);
   NS_ASSERT_MSG(sFlowIdx <= maxSubflows, "Subflow number should be smaller than MaxNumOfSubflows");
   NS_ASSERT_MSG(
       sFlowIdx >= 0,
@@ -3045,6 +3288,21 @@ MpTcpSocketBase::DoForwardUp (Ptr<Packet> p, Ipv4Header header, uint16_t port, P
   if (ReadOptions (sFlowIdx, p, mptcpHeader) == false)
     return;
 
+  if (!m_dcpersub)
+    {
+      if (AlgoCC == DCMPTCP && sFlowIdx < maxSubflows && m_eceBit > 0 && (m_licx == 0 || m_fb == 0) && subflows[sFlowIdx]->state == ESTABLISHED
+            && subflows[sFlowIdx]->dcmptcp_maxseq < (subflows[sFlowIdx]->highestAck + 1))
+        {
+          assert(!m_DCTCP);
+          NS_ASSERT(client);
+          DCMPTCPECNSlowDown (sFlowIdx);
+          subflows[sFlowIdx]->dcmptcp_maxseq = subflows[sFlowIdx]->TxSeqNumber;
+          
+          DCMPTCPECNCutDowns++;
+        }
+    }
+
+
   if (AlgoCC == XMP && m_eceBit > 0 && sFlow->m_cwr == 1 && sFlow->state == ESTABLISHED && sFlow->routeId < maxSubflows && client)
     { // XMP
       assert(!m_DCTCP);
@@ -3155,7 +3413,11 @@ MpTcpSocketBase::InitiateSubflows ()
         sFlow->dAddr = remote;
         sFlow->dPort = m_remotePort; // TODO Is this right?
         sFlow->MSS = segmentSize;
-        sFlow->cwnd = sFlow->MSS;               // We should do this ... since cwnd is 0
+        //sFlow->cwnd = sFlow->MSS;               // We should do this ... since cwnd is 0
+        if (AlgoCC == DCMPTCP)
+          sFlow->cwnd = m_slaveIW * sFlow->MSS;
+        else
+          sFlow->cwnd = this->GetInitialCwnd() * sFlow->MSS;
         sFlow->state = SYN_SENT;
         sFlow->cnTimeout = m_cnTimeout;
         sFlow->cnRetries = m_cnRetries;
@@ -3211,7 +3473,11 @@ MpTcpSocketBase::InitiateSingleSubflows (uint16_t randomPort)
   sFlow->dAddr = m_endPoint->GetPeerAddress ();
   sFlow->dPort = m_endPoint->GetPeerPort ();
   sFlow->MSS = segmentSize;
-  sFlow->cwnd = sFlow->MSS;
+  //sFlow->cwnd = sFlow->MSS;
+  if (AlgoCC == DCMPTCP)
+    sFlow->cwnd = m_slaveIW * sFlow->MSS;
+  else
+    sFlow->cwnd = this->GetInitialCwnd() * sFlow->MSS;
   sFlow->state = SYN_SENT;
   sFlow->cnTimeout = m_cnTimeout;
   sFlow->cnRetries = m_cnRetries;
@@ -3393,7 +3659,10 @@ MpTcpSocketBase::ReadUnOrderedData ()
               sFlow->AccumulativeAck = true; //TODO TEMP
             }
           else
-            NS_ASSERT(ptrDSN->subflowSeqNumber < sFlow->RxSeqNumber);
+            {
+              NS_LOG_INFO(ptrDSN->subflowSeqNumber << sFlow->RxSeqNumber);
+              NS_ASSERT(ptrDSN->subflowSeqNumber < sFlow->RxSeqNumber);
+            }
 
           NotifyDataRecv ();
           unOrdered.erase (current);
@@ -3511,38 +3780,42 @@ MpTcpSocketBase::PrintCC (uint32_t cc)
     return "LI"; //1
     break;
   case 2:
-    return "RC"; //2
+    return "DCMPTCP";           //2
     break;
   case 3:
-    return "FC"; //3
+    return "RC"; //
     break;
   case 4:
-    return "CST";            //4
+    return "FC"; //
     break;
   case 5:
-    return "UC";             //5
+    return "CST";            //
     break;
   case 6:
-    return "CE";             //6
+    return "UC";             //
     break;
   case 7:
-    return "CI";             //7
+    return "CE";             //
     break;
   case 8:
-    return "CF";             //8
+    return "CI";             //
     break;
   case 9:
-    return "XMP";            //9
+    return "CF";             //
     break;
   case 10:
-    return "FU";            //10
+    return "XMP";            //
     break;
   case 11:
-    return "FI";            //11
+    return "FU";            //
     break;
   case 12:
-    return "XCA";           //12
+    return "FI";            //
     break;
+  case 13:
+    return "XCA";           //
+  break;
+
   default:
     exit (200);
     return "Unknown";
@@ -3812,6 +4085,10 @@ MpTcpSocketBase::GetSocketModel()
     {
       tmpSocket = ft + "XMP";
     }
+   else if (AlgoCC == DCMPTCP)
+    {
+      tmpSocket = ft + "DCMPTCP";
+    }
   else
     {
       tmpSocket = ft + "UN";
@@ -3836,8 +4113,12 @@ MpTcpSocketBase::DoDoGenerateOutPutFile(TypeId tid)
       //<< "[."  << IsActive(m_DCTCP)  << ".]"
         << "[#"  << goodput / 1000000  << "#]"
         << "[*"  << (Simulator::Now ().GetSeconds () - fLowStartTime)       << "*]"
+        << "[T"  << fLowStartTime      << "T]"
+        << "[S"  << nextTxSequence - 1 << "S]"
         << "[$"  << TimeOuts           << "$]"
         << "[!"  << FastReTxs          << "!]"
+        << "[x"  << DCMPTCPCutDowns    << "x]"
+        << "[e"  << DCMPTCPECNCutDowns << "e]"
         << "[("  << pAck               << ")]"
         << "[@"  << FullAcks           << "@]"
         << "[^"  << FastRecoveries     << "^]"
@@ -3855,14 +4136,14 @@ MpTcpSocketBase::DoDoGenerateOutPutFile(TypeId tid)
       //<< "[{SDEL:"  << m_slowDownEcnLike  << "}]"
       //<< "[{XMP:"   << (AlgoCC == XMP)    << "}]"
         << "[{"  << GetSocketModel()   << "}]"
-        << "["  << PrintCC(AlgoCC)    << "]"
+        << "[{"  << PrintCC(AlgoCC)    << "}]"
         << "[-"  << SlowDownHits       << "-]"
         << "[{DS"<< m_dynamicSubflow   << "}]"
         << "[{IT"<< m_incastThreshold  << "}]"
         << "[{ET"<< m_incastExitThreshold << "}]"
         << "[{IC"<< m_incastCounter    << "}]"
         << "[."  << m_incastEnterHits  << ".]"
-        << "["  << m_incastExitHits   << "]"
+        << "[{"  << m_incastExitHits   << "}]"
         << "[{CM"<< m_cwndMin          << "}]"
         << "[{RS"<< m_rwndScale        << "}]"
         << "[{B" << m_backoffBeta      << "_G" << m_initGamma << "}]"
@@ -5157,7 +5438,7 @@ MpTcpSocketBase::Close (uint8_t sFlowIdx)
 {
   NS_LOG_FUNCTION (this << (int)sFlowIdx);
   Ptr<MpTcpSubFlow> sFlow = subflows[sFlowIdx];
-
+  cout << "[" << m_node->GetId () << "]{" << flowId << "}(" << flowType << ") -> Close()" << endl;
   // First we check to see if there is any unread rx data. Bug number 426 claims we should send reset in this case.
   if (unOrdered.size () > 0 && FindPacketFromUnOrdered (sFlowIdx) && !sFlow->Finished ()) /* && recvingBuffer->PendingData() != 0 */
     {  // I don't expect this to happens in normal scenarios!
@@ -5713,7 +5994,11 @@ MpTcpSocketBase::LookupSubflow (Ipv4Address src, uint32_t srcPort, Ipv4Address d
   sFlow->sAddr = src;
   sFlow->sPort = srcPort;
   sFlow->MSS = segmentSize;
-  sFlow->cwnd = sFlow->MSS;
+  if (AlgoCC == DCMPTCP)
+    sFlow->cwnd = m_slaveIW * sFlow->MSS;
+  else
+    sFlow->cwnd = this->GetInitialCwnd() * sFlow->MSS;
+  //sFlow->cwnd = sFlow->MSS;
   sFlow->state = LISTEN;
   sFlow->cnTimeout = m_cnTimeout;
   sFlow->cnRetries = m_cnRetries;
@@ -5873,6 +6158,7 @@ MpTcpSocketBase::OpenCWND (uint8_t sFlowIdx, uint32_t ackedBytes)
         sFlow->cwnd += static_cast<double> (adder);
         break;
       case RTT_Compensator:
+      case DCMPTCP:
         calculateAlpha (); // Calculate alpha per drop or RTT...RFC 6356 (Section 4.1)
         adder = std::min (alpha * sFlow->MSS * sFlow->MSS / totalCwnd, static_cast<double> (sFlow->MSS * sFlow->MSS) / cwnd);
         adder = std::max (1.0, adder);
@@ -6121,6 +6407,9 @@ MpTcpSocketBase::SetCCAlgo (string cc)
     AlgoCC = Fast_Increases;
   else if (cc == "XCA")
     AlgoCC = XCA;
+  else if (cc == "DCMPTCP")
+    AlgoCC = DCMPTCP;
+  NS_LOG_INFO (AlgoCC << cc <<DCMPTCP);
 }
 
 void
@@ -6504,6 +6793,8 @@ MpTcpSocketBase::SlowDown (uint8_t sFlowIdx)
   assert(!m_slowDownXmpLike);
 //assert(!m_slowDownEcnLike); // Should be turn of for MMPTCP if 1st phase need dctcp and 2th phase ecn
   assert(AlgoCC != XMP && m_DCTCP);
+  
+  NS_LOG_FUNCTION(this);
   SlowDownHits++;
 
   Ptr<MpTcpSubFlow> sFlow = subflows[sFlowIdx];
diff --git a/src/internet/model/mp-tcp-socket-base.h b/src/internet/model/mp-tcp-socket-base.h
index b619dbc..98a81e5 100644
--- a/src/internet/model/mp-tcp-socket-base.h
+++ b/src/internet/model/mp-tcp-socket-base.h
@@ -103,6 +103,8 @@ public: // public variables
   uint32_t FullAcks;
   uint32_t TimeOuts;
   uint32_t FastReTxs;
+  uint32_t DCMPTCPCutDowns;
+  uint32_t DCMPTCPECNCutDowns;
   uint32_t FastRecoveries;
   uint64_t SlowDownHits;
   bool flowCompletionTime;
@@ -298,6 +300,7 @@ protected: // protected methods
   void SlowDownEcnLike (uint8_t sFlowIdx); // DCTCP
   void SlowDownFastReTx (uint8_t sFlowIdx, DSNMapping* ptrDSN, string sockName); // DCTCP
   void CalculateDCTCPAlpha(uint8_t sFlowIdx, uint32_t); // Calculating fraction of Marked pkt and alpha once per rtt
+  void CalculateDCMPTCPAlpha (uint8_t sFlowIdx, uint32_t ack); // For MPTCP variant. Calculating fraction of Marked pkt and alpha once per rtt
   void ExtractPacketTags(Ptr<Packet> p);
   void AddPacketTag (Ptr<Packet> p, PacketTag_t pt);
 //  virtual void AddEctTag(Ptr<Packet> p);
@@ -313,6 +316,8 @@ protected: // protected methods
   string CutFileName(std::string::size_type &position);
   string CutFileNameOnly();
 
+  void DCMPTCPECNSlowDown (uint8_t sFlowIdx);
+
 protected: // protected variables
   //XMP Parameters
   double             m_instRate;
@@ -338,6 +343,9 @@ protected: // protected variables
   uint8_t            currentSublow;
   uint8_t			m_ceBit;
   uint8_t			m_eceBit;
+  uint8_t			m_rlBit;  
+  uint8_t			m_licx;
+  uint8_t			m_fb;
   bool              m_DCTCP;      		//< Socket DCTCP capability
   double            m_g;
   bool              m_dctcpAlphaPerAck;
@@ -374,6 +382,15 @@ protected: // protected variables
   CongestionCtrl_t AlgoCC;       // Algorithm for Congestion Control
   DataDistribAlgo_t distribAlgo; // Algorithm for Data Distribution
   PathManager_t pathManager;        // Mechanism for subflow establishement
+  
+  // For DCMPTCP handshake
+  CongestionCtrl_t oldAlgoCC;
+  uint8_t oldMaxSubflows;
+  
+  //DCMPTCP
+  uint32_t m_slaveIW;
+  uint32_t m_dcsche_th;
+  bool m_dcpersub;
 
   // Window management variables
   uint32_t m_ssThresh;           // Slow start threshold
diff --git a/src/internet/model/mp-tcp-subflow.cc b/src/internet/model/mp-tcp-subflow.cc
index 90a50c9..59eede3 100644
--- a/src/internet/model/mp-tcp-subflow.cc
+++ b/src/internet/model/mp-tcp-subflow.cc
@@ -80,7 +80,12 @@ MpTcpSubFlow::MpTcpSubFlow() :
   dctcp_marked = 0;
   dctcp_alpha_update_seq = 0;
   dctcp_maxseq = 0;
+  dcmptcp_maxseq = 0;
+  dcmptcp_alpha_update_seq = 0;
+  dcmptcp_total = 0;
+  dcmptcp_marked = 0;
   dctcp_alpha = 0.0;
+  dcmptcp_alpha = 0.0;
   fast_alpha = 0.0;
   curEcnState = false;
   g_AckSeqNumber = 0;
diff --git a/src/internet/model/mp-tcp-subflow.h b/src/internet/model/mp-tcp-subflow.h
index f91a0d7..bc8ebf1 100644
--- a/src/internet/model/mp-tcp-subflow.h
+++ b/src/internet/model/mp-tcp-subflow.h
@@ -99,6 +99,11 @@ public:
   uint32_t dctcp_marked;
   uint32_t dctcp_alpha_update_seq;
   uint32_t dctcp_maxseq;
+  uint32_t dcmptcp_maxseq;
+  double dcmptcp_alpha; // For the variant of DCMPTCP, which reduces window per subflow.
+  uint32_t dcmptcp_alpha_update_seq;
+  uint32_t dcmptcp_total;
+  uint32_t dcmptcp_marked;
   double dctcp_alpha;
   double fast_alpha;
   bool curEcnState;
diff --git a/src/internet/model/mp-tcp-typedefs.h b/src/internet/model/mp-tcp-typedefs.h
index 18fce7e..5fe77fe 100644
--- a/src/internet/model/mp-tcp-typedefs.h
+++ b/src/internet/model/mp-tcp-typedefs.h
@@ -36,22 +36,24 @@ typedef enum
 {
   Uncoupled_TCPs,         // 0
   Linked_Increases,       // 1
-  RTT_Compensator,        // 2
-  Fully_Coupled,          // 3
-  COUPLED_SCALABLE_TCP,   // 4
-  UNCOUPLED,              // 5
-  COUPLED_EPSILON,        // 6
-  COUPLED_INC,            // 7
-  COUPLED_FULLY,          // 8
-  XMP,                    // 9
-  Fast_Uncoupled,         // 10
-  Fast_Increases,         // 11
-  XCA                     // 12
+  DCMPTCP,// 2
+  RTT_Compensator,        // 3
+  Fully_Coupled,          // 4
+  COUPLED_SCALABLE_TCP,   // 5
+  UNCOUPLED,              // 6
+  COUPLED_EPSILON,        // 7
+  COUPLED_INC,            // 8
+  COUPLED_FULLY,          // 9
+  XMP,                    // 10
+  Fast_Uncoupled,         // 11
+  Fast_Increases,         // 12
+  XCA                     // 13
 } CongestionCtrl_t;
 
 typedef enum
 {
-  Round_Robin
+  Round_Robin,
+  DC_SCHE
 } DataDistribAlgo_t;
 
 typedef enum
diff --git a/src/internet/model/stone-acl.cc b/src/internet/model/stone-acl.cc
new file mode 100644
index 0000000..b051647
--- /dev/null
+++ b/src/internet/model/stone-acl.cc
@@ -0,0 +1,108 @@
+/*
+ * Stone ACL implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+
+#include "ns3/stone-acl.h"
+#include "ns3/log.h"
+#include "ns3/node.h"
+#include "ns3/packet.h"
+#include "ns3/log.h"
+#include "ns3/callback.h"
+#include "ns3/ipv4-address.h"
+#include "ns3/ipv4-route.h"
+#include "ns3/node.h"
+#include "ns3/socket.h"
+#include "ns3/net-device.h"
+#include "ns3/uinteger.h"
+#include "ns3/trace-source-accessor.h"
+#include "ns3/object-vector.h"
+#include "ns3/ipv4-header.h"
+#include "ns3/boolean.h"
+#include "ns3/ipv4-routing-table-entry.h"
+#include "ns3/tcp-header.h"
+#include "ns3/rl-tag.h"
+
+#include "loopback-net-device.h"
+#include "arp-l3-protocol.h"
+#include "ipv4-l3-protocol.h"
+#include "icmpv4-l4-protocol.h"
+#include "ipv4-interface.h"
+#include "ipv4-raw-socket-impl.h"
+
+NS_LOG_COMPONENT_DEFINE ("StoneACL");
+using namespace std;
+namespace ns3
+{
+NS_OBJECT_ENSURE_REGISTERED (StoneACL);
+
+TypeId StoneACL::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::StoneACL")
+                      .SetParent<Object> ()
+                      .AddConstructor<StoneACL> ()
+                      ;
+  return tid;
+}
+
+StoneACL::StoneACL()
+{
+  
+}
+StoneACL::~StoneACL()
+{
+  
+}
+
+void
+StoneACL::SetNetwork(Ipv4Address address)
+{
+  NS_LOG_FUNCTION (this << address);
+  m_networkIPAddr = address;
+}
+
+void
+StoneACL::SetNode (Ptr<Node> node)
+{
+  NS_LOG_FUNCTION (this << "Node"<< node->GetId());
+  m_node = node;
+}
+
+void
+StoneACL::SetMaxDownlink (int32_t maxDownlink)
+{
+  NS_LOG_FUNCTION (this << maxDownlink);
+  m_maxDownlink = maxDownlink;
+}
+
+void
+StoneACL::ConductTag(Ptr<Packet> packet, Ipv4Header const &ipHeader, int32_t interface)
+{
+  NS_LOG_FUNCTION (packet << interface);
+  NS_LOG_INFO ("Node:" << m_node->GetId() << " Network:" << m_networkIPAddr << " Inf:"<< interface << " MaxDownlink:" << m_maxDownlink);
+  NS_LOG_INFO ("Protocol:" << int32_t(ipHeader.GetProtocol ()));
+  // Stone ACL filter is only for downlinks
+  if ((interface <= m_maxDownlink) && (ipHeader.GetProtocol () == 6))
+  {
+    TcpHeader tcpHeader;
+    packet->PeekHeader (tcpHeader);
+    NS_LOG_INFO(tcpHeader);
+    
+    NS_LOG_INFO(ipHeader.GetSource().CombineMask(Ipv4Mask("255.255.0.0")));
+    if ((!(tcpHeader.GetFlags () & TcpHeader::ACK)) 
+        && (tcpHeader.GetFlags () & TcpHeader::SYN) 
+        && (ipHeader.GetSource().CombineMask(Ipv4Mask("255.255.0.0")) == m_networkIPAddr))
+    {
+      RLTag rlTag;
+      bool exist = packet->PeekPacketTag (rlTag);
+      NS_ASSERT (!exist);
+      rlTag.SetRL (1);
+      packet->AddPacketTag (rlTag);
+      NS_LOG_INFO ("RL marked!");
+    }
+   
+  }
+}
+
+}//namespace ns3
diff --git a/src/internet/model/stone-acl.h b/src/internet/model/stone-acl.h
new file mode 100644
index 0000000..adfb5a8
--- /dev/null
+++ b/src/internet/model/stone-acl.h
@@ -0,0 +1,43 @@
+/*
+ * Stone ACL implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+#ifndef STONE_ACL_H
+#define STONE_ACL_H
+
+#include "ns3/object.h"
+#include <stdint.h>
+#include <string>
+#include "ns3/object-factory.h"
+#include "ns3/address.h"
+#include "ns3/attribute.h"
+#include "ns3/net-device.h"
+#include "ns3/node-container.h"
+#include "ns3/ipv4-header.h"
+
+using namespace std;
+namespace ns3
+{
+
+class StoneACL : public Object
+{
+public:
+  static TypeId GetTypeId(void);
+  
+  StoneACL();
+  virtual ~StoneACL();
+  void SetNetwork(Ipv4Address address);
+  void SetNode (Ptr<Node> node);
+  void SetMaxDownlink (int32_t maxDownlink);
+  void ConductTag(Ptr<Packet> packet, Ipv4Header const &ipHeader, int32_t interface);
+  
+private:
+  Ipv4Address m_networkIPAddr;
+  Ptr<Node> m_node;
+  int32_t m_maxDownlink;
+};
+
+}   //namespace ns3
+
+#endif /* STONE_ACL_H */
diff --git a/src/internet/model/tcp-socket.cc b/src/internet/model/tcp-socket.cc
index e230d7c..eb0c09f 100644
--- a/src/internet/model/tcp-socket.cc
+++ b/src/internet/model/tcp-socket.cc
@@ -67,7 +67,7 @@ TcpSocket::GetTypeId (void)
                    MakeUintegerChecker<uint32_t> ())
     .AddAttribute ("InitialCwnd",
                    "TCP initial congestion window size (segments)",
-                   UintegerValue (1),
+                   UintegerValue (10),
                    MakeUintegerAccessor (&TcpSocket::GetInitialCwnd,
                                          &TcpSocket::SetInitialCwnd),
                    MakeUintegerChecker<uint32_t> ())
diff --git a/src/internet/model/tracc-acl.cc b/src/internet/model/tracc-acl.cc
new file mode 100644
index 0000000..51108cd
--- /dev/null
+++ b/src/internet/model/tracc-acl.cc
@@ -0,0 +1,217 @@
+/*
+ * Tracc ACL implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+
+#include "ns3/tracc-acl.h"
+#include "ns3/log.h"
+#include "ns3/node.h"
+#include "ns3/packet.h"
+#include "ns3/log.h"
+#include "ns3/callback.h"
+#include "ns3/ipv4-address.h"
+#include "ns3/ipv4-route.h"
+#include "ns3/node.h"
+#include "ns3/socket.h"
+#include "ns3/net-device.h"
+#include "ns3/uinteger.h"
+#include "ns3/trace-source-accessor.h"
+#include "ns3/object-vector.h"
+#include "ns3/ipv4-header.h"
+#include "ns3/boolean.h"
+#include "ns3/ipv4-routing-table-entry.h"
+#include "ns3/tcp-header.h"
+#include "ns3/rl-tag.h"
+#include "ns3/li-cx-tag.h"
+#include "ns3/fb-li-tag.h"
+#include "ns3/fb-tag.h"
+#include "ns3/ece-tag.h"
+#include "ns3/double.h"
+
+#include "loopback-net-device.h"
+#include "arp-l3-protocol.h"
+#include "ipv4-l3-protocol.h"
+#include "icmpv4-l4-protocol.h"
+#include "ipv4-interface.h"
+#include "ipv4-raw-socket-impl.h"
+
+NS_LOG_COMPONENT_DEFINE ("TraccACL");
+using namespace std;
+namespace ns3
+{
+NS_OBJECT_ENSURE_REGISTERED (TraccACL);
+
+TypeId TraccACL::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::TraccACL")
+                      .SetParent<Object> ()
+                      .AddConstructor<TraccACL> ()
+                      .AddAttribute ("UseFBForOutFilter",
+                                     "Use FB_Tag to filter outgoing traffic.",
+                                     BooleanValue (false),
+                                     MakeBooleanAccessor (&TraccACL::m_useFBForOutFilter),
+                                     MakeBooleanChecker ())
+                      .AddAttribute ("TimeInterval", "Time interval to update tables.",
+                                     TimeValue (MicroSeconds (200)), // One RTT
+                                     MakeTimeAccessor (&TraccACL::m_timeInterval),
+                                     MakeTimeChecker ())
+                      .AddAttribute ("AlphaWeight",
+                                     "Weight for calculating alpha parameter",
+                                     DoubleValue (1.0 / 16.0), MakeDoubleAccessor (&TraccACL::m_g),
+                                     MakeDoubleChecker<double> (0, 1))
+                      ;
+  return tid;
+}
+
+TraccACL::TraccACL()
+{
+  
+}
+TraccACL::~TraccACL()
+{
+  
+}
+
+void
+TraccACL::MatrixIni()
+{
+  for (int i = 0; i < m_numLeaf; i++)
+  {
+    for (int j = 0; j < m_numSpine; j++)
+    {
+      m_N[i][j] = 0;
+      m_M[i][j] = 0;
+      m_alpha[i][j] = 0.0;
+    }
+  }
+}
+
+void
+TraccACL::Install (Ptr<Node> node, int32_t numLeaf, int32_t numHost, int32_t numSpine)
+{
+  NS_LOG_FUNCTION (node->GetId() << numLeaf << numHost << numSpine);
+  m_node = node;
+  m_numLeaf = numLeaf;
+  m_numHost = numHost;
+  m_numSpine = numSpine;
+  
+  m_N.resize (numLeaf, vector<int32_t>(numSpine));
+  m_M.resize (numLeaf, vector<int32_t>(numSpine));
+  m_alpha.resize (numLeaf, vector<double>(numSpine));
+  
+  MatrixIni();
+}
+
+void
+TraccACL::SetNetwork(Ipv4Address address)
+{
+  NS_LOG_FUNCTION (this << address);
+  m_networkIPAddr = address;
+}
+
+void
+TraccACL::CalculateClean()
+{
+  NS_LOG_FUNCTION (m_node->GetId());
+  NS_LOG_INFO ("Node:" << m_node->GetId() << " Matrix:\n");
+  for (int i = 0; i < m_numLeaf; i++)
+  {
+    if (m_node->GetId() == 256)
+    {
+      NS_LOG_INFO ("N:" << m_N[i][0] << " " << m_N[i][1] << " " << m_N[i][2] << " " << m_N[i][3]);
+      NS_LOG_INFO ("M:" << m_M[i][0] << " " << m_M[i][1] << " " << m_M[i][2] << " " << m_M[i][3]);
+      NS_LOG_INFO ("A:" << m_alpha[i][0] << " " << m_alpha[i][1] << " " << m_alpha[i][2] << " " << m_alpha[i][3]);
+    }
+    for (int j = 0; j < m_numSpine; j++)
+    {
+      if ((m_N[i][j] > 0) || (m_M[i][j] > 0))
+        m_alpha[i][j] = (1 - m_g) * m_alpha[i][j] + m_g * (m_M[i][j] * 1.0 / (m_M[i][j] + m_N[i][j]));
+      else
+        m_alpha[i][j] = (1 - m_g) * m_alpha[i][j];
+      
+      m_N[i][j] = 0;
+      m_M[i][j] = 0;
+    }
+  }
+  
+  Simulator::ScheduleWithContext(m_node->GetId(), m_timeInterval, &TraccACL::CalculateClean, this);
+}
+
+void
+TraccACL::SetTimer ()
+{
+  NS_LOG_FUNCTION(m_node->GetId());
+  Simulator::ScheduleWithContext(m_node->GetId(), Seconds(0.0), &TraccACL::CalculateClean, this);
+}
+
+void
+TraccACL::TagCount(Ptr<Packet> packet, Ipv4Header const &ipHeader, int32_t interface)
+{
+  NS_LOG_FUNCTION (m_node->GetId () << m_networkIPAddr << m_timeInterval);
+  if ((interface <= m_numHost) && (ipHeader.GetSource().CombineMask(Ipv4Mask("255.255.0.0")) != m_networkIPAddr))
+  {
+    FBTag fb;
+    bool fb_exist = packet->PeekPacketTag (fb);
+    if (!fb_exist)
+    {
+      return;
+    }
+    
+    FBLITag fbli;
+    int32_t li;
+    bool fbli_exist = packet->RemovePacketTag (fbli);
+    if (fbli_exist)
+    {
+      li = fbli.GetFBLI ();
+      int32_t src_l = ((ipHeader.GetSource().Get() >> 16 ) & 0xff);
+      NS_LOG_INFO ("Got li:" << (int32_t)li);
+      
+      EceTag ece;
+      bool ece_exist = packet->PeekPacketTag (ece);
+      
+      if (ece_exist)
+        m_M[src_l][li]++; //W/ ECE
+      else
+        m_N[src_l][li]++; ////W/o ECE
+      
+      uint8_t cx = (uint8_t)(m_alpha[src_l][li] * 16);
+      
+      LICXTag licxTag;
+      packet->RemovePacketTag (licxTag);
+
+      licxTag.SetLICX (cx);
+      packet->AddPacketTag (licxTag);
+      NS_LOG_INFO ("Sent licx to sender:" << (uint32_t)cx << " " << m_alpha[src_l][li]<< " " << src_l << " " << li << " "<<ipHeader.GetSource());
+    }
+    
+    return;
+  }
+  
+  if (interface <= m_numHost) //RL traffic
+      return;
+  // ipHeader.GetDestination().CombineMask(Ipv4Mask("0.255.0.0"))
+  //
+  int32_t l = ((ipHeader.GetDestination().Get() >> 16 ) & 0xff);
+  int32_t p = interface - m_numHost - 1;
+  
+  NS_ASSERT (p < m_numSpine);
+  NS_ASSERT (l < m_numLeaf);
+  
+  NS_LOG_FUNCTION ("Filtered!" << l << p);
+  
+  LICXTag licxTag;
+  bool exist = packet->RemovePacketTag (licxTag);
+  if (exist)
+  {
+    NS_LOG_INFO ("LICX Tag already exists!");
+  }
+  licxTag.SetLICX (p + 1);
+  packet->AddPacketTag (licxTag);
+  NS_LOG_INFO ("Sent licx to receiver:" << p + 1);
+  
+}
+
+
+
+}//namespace ns3
diff --git a/src/internet/model/tracc-acl.h b/src/internet/model/tracc-acl.h
new file mode 100644
index 0000000..dc800ec
--- /dev/null
+++ b/src/internet/model/tracc-acl.h
@@ -0,0 +1,57 @@
+/*
+ * Tracc ACL implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+#ifndef TRACC_ACL_H
+#define TRACC_ACL_H
+
+#include "ns3/object.h"
+#include <stdint.h>
+#include <string>
+#include <vector>
+#include "ns3/object-factory.h"
+#include "ns3/address.h"
+#include "ns3/attribute.h"
+#include "ns3/net-device.h"
+#include "ns3/node-container.h"
+#include "ns3/ipv4-header.h"
+#include "ns3/nstime.h"
+
+using namespace std;
+namespace ns3
+{
+
+class TraccACL : public Object
+{
+public:
+  static TypeId GetTypeId(void);
+  
+  TraccACL();
+  virtual ~TraccACL();
+  
+  void Install (Ptr<Node> node, int32_t numLeaf, int32_t numHost, int32_t numSpine);
+  void SetNetwork(Ipv4Address address);
+  void TagCount(Ptr<Packet> packet, Ipv4Header const &ipHeader, int32_t interface);
+  void SetTimer ();
+  void CalculateClean();
+private:
+  void MatrixIni();
+  
+  Ipv4Address m_networkIPAddr;
+  double m_g;
+  Ptr<Node> m_node;
+  int32_t m_numLeaf;
+  int32_t m_numHost;
+  int32_t m_numSpine;
+  vector<vector<int32_t> > m_N; 
+  vector<vector<int32_t> > m_M;
+  vector<vector<double> > m_alpha;
+  
+  bool m_useFBForOutFilter;
+  Time m_timeInterval;
+};
+
+}   //namespace ns3
+
+#endif /* TRACC_ACL_H */
diff --git a/src/internet/wscript b/src/internet/wscript
index f1fee5c..2b49de0 100644
--- a/src/internet/wscript
+++ b/src/internet/wscript
@@ -198,6 +198,10 @@ def build(bld):
         'model/mp-tcp-typedefs.cc',
         'model/tcp-options.cc',
         'model/mp-tcp-subflow.cc',
+        'model/stone-acl.cc',                           # Enhuan Dong
+        'helper/stone-acl-helper.cc',                   # Enhuan Dong
+        'model/tracc-acl.cc',                           # Enhuan Dong
+        'helper/tracc-acl-helper.cc',                   # Enhuan Dong
         ]
 
     internet_test = bld.create_ns3_module_test_library('internet')
@@ -319,6 +323,10 @@ def build(bld):
         'model/mp-tcp-subflow.h',             # Morteza Kheirkhah
         'model/mmp-tcp-socket-base.h',        # Morteza Kheirkhah
         'model/packet-scatter-socket-base.h',
+        'model/stone-acl.h',                  # Enhuan Dong
+        'helper/stone-acl-helper.h',          # Enhuan Dong    
+        'model/tracc-acl.h',                  # Enhuan Dong
+        'helper/tracc-acl-helper.h',          # Enhuan Dong    
        ]
 
     if bld.env['NSC_ENABLED']:
diff --git a/src/network/utils/fb-li-tag.cc b/src/network/utils/fb-li-tag.cc
new file mode 100644
index 0000000..79a8db4
--- /dev/null
+++ b/src/network/utils/fb-li-tag.cc
@@ -0,0 +1,71 @@
+/*
+ * FB_LI tag implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+#include "fb-li-tag.h"
+#include "ns3/log.h"
+
+NS_LOG_COMPONENT_DEFINE ("FBLITag");
+
+namespace ns3 {
+
+NS_OBJECT_ENSURE_REGISTERED (FBLITag);
+
+TypeId 
+FBLITag::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::FBLITag")
+    .SetParent<Tag> ()
+    .AddConstructor<FBLITag> ()
+  ;
+  return tid;
+}
+TypeId 
+FBLITag::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+uint32_t 
+FBLITag::GetSerializedSize (void) const
+{
+  NS_LOG_FUNCTION (this);
+  return 1;
+}
+void 
+FBLITag::Serialize (TagBuffer buf) const
+{
+  NS_LOG_FUNCTION (this << &buf);
+  buf.WriteU8 (m_fb_li);
+}
+void 
+FBLITag::Deserialize (TagBuffer buf)
+{
+  NS_LOG_FUNCTION (this << &buf);
+  m_fb_li = buf.ReadU8();
+}
+void 
+FBLITag::Print (std::ostream &os) const
+{
+  NS_LOG_FUNCTION (this << &os);
+  os << "FB LI Tag  = " << (int)m_fb_li;
+}
+FBLITag::FBLITag ()
+  : Tag () 
+{
+  NS_LOG_FUNCTION (this);
+}
+void
+FBLITag::SetFBLI (uint8_t fbli)
+{
+  NS_LOG_FUNCTION (this << fbli);
+  m_fb_li = fbli;
+}
+uint8_t
+FBLITag::GetFBLI (void) const
+{
+  NS_LOG_FUNCTION (this);
+  return m_fb_li;
+}
+
+} // namespace ns3
diff --git a/src/network/utils/fb-li-tag.h b/src/network/utils/fb-li-tag.h
new file mode 100644
index 0000000..3ed4bd0
--- /dev/null
+++ b/src/network/utils/fb-li-tag.h
@@ -0,0 +1,33 @@
+/*
+ * FB_LI tag implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+#ifndef FB_LI_TAG_H
+#define FB_LI_TAG_H
+
+#include "ns3/tag.h"
+
+namespace ns3 {
+
+class FBLITag : public Tag
+{
+public:
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (TagBuffer buf) const;
+  virtual void Deserialize (TagBuffer buf);
+  virtual void Print (std::ostream &os) const;
+
+  FBLITag ();
+  void SetFBLI (uint8_t ce);
+  uint8_t GetFBLI (void) const;
+
+private:
+  uint8_t m_fb_li;
+};
+
+} // namespace ns3
+
+#endif /* FB_LI_TAG_H */
diff --git a/src/network/utils/fb-tag.cc b/src/network/utils/fb-tag.cc
new file mode 100644
index 0000000..ed0c164
--- /dev/null
+++ b/src/network/utils/fb-tag.cc
@@ -0,0 +1,71 @@
+/*
+ * FB tag implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+#include "fb-tag.h"
+#include "ns3/log.h"
+
+NS_LOG_COMPONENT_DEFINE ("FBTag");
+
+namespace ns3 {
+
+NS_OBJECT_ENSURE_REGISTERED (FBTag);
+
+TypeId 
+FBTag::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::FBTag")
+    .SetParent<Tag> ()
+    .AddConstructor<FBTag> ()
+  ;
+  return tid;
+}
+TypeId 
+FBTag::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+uint32_t 
+FBTag::GetSerializedSize (void) const
+{
+  NS_LOG_FUNCTION (this);
+  return 1;
+}
+void 
+FBTag::Serialize (TagBuffer buf) const
+{
+  NS_LOG_FUNCTION (this << &buf);
+  buf.WriteU8 (m_fb);
+}
+void 
+FBTag::Deserialize (TagBuffer buf)
+{
+  NS_LOG_FUNCTION (this << &buf);
+  m_fb = buf.ReadU8();
+}
+void 
+FBTag::Print (std::ostream &os) const
+{
+  NS_LOG_FUNCTION (this << &os);
+  os << "FB Tag  = " << (int)m_fb;
+}
+FBTag::FBTag ()
+  : Tag () 
+{
+  NS_LOG_FUNCTION (this);
+}
+void
+FBTag::SetFB (uint8_t fb)
+{
+  NS_LOG_FUNCTION (this << fb);
+  m_fb = fb;
+}
+uint8_t
+FBTag::GetFB (void) const
+{
+  NS_LOG_FUNCTION (this);
+  return m_fb;
+}
+
+} // namespace ns3
diff --git a/src/network/utils/fb-tag.h b/src/network/utils/fb-tag.h
new file mode 100644
index 0000000..4f4744f
--- /dev/null
+++ b/src/network/utils/fb-tag.h
@@ -0,0 +1,33 @@
+/*
+ * FB tag implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+#ifndef FB_TAG_H
+#define FB_TAG_H
+
+#include "ns3/tag.h"
+
+namespace ns3 {
+
+class FBTag : public Tag
+{
+public:
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (TagBuffer buf) const;
+  virtual void Deserialize (TagBuffer buf);
+  virtual void Print (std::ostream &os) const;
+
+  FBTag ();
+  void SetFB (uint8_t fb);
+  uint8_t GetFB (void) const;
+
+private:
+  uint8_t m_fb;
+};
+
+} // namespace ns3
+
+#endif /* FB_LI_TAG_H */
diff --git a/src/network/utils/li-cx-tag.cc b/src/network/utils/li-cx-tag.cc
new file mode 100644
index 0000000..3744e99
--- /dev/null
+++ b/src/network/utils/li-cx-tag.cc
@@ -0,0 +1,71 @@
+/*
+ * LI-CX tag implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+#include "li-cx-tag.h"
+#include "ns3/log.h"
+
+NS_LOG_COMPONENT_DEFINE ("LICXTag");
+
+namespace ns3 {
+
+NS_OBJECT_ENSURE_REGISTERED (LICXTag);
+
+TypeId 
+LICXTag::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::LICXTag")
+    .SetParent<Tag> ()
+    .AddConstructor<LICXTag> ()
+  ;
+  return tid;
+}
+TypeId 
+LICXTag::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+uint32_t 
+LICXTag::GetSerializedSize (void) const
+{
+  NS_LOG_FUNCTION (this);
+  return 1;
+}
+void 
+LICXTag::Serialize (TagBuffer buf) const
+{
+  NS_LOG_FUNCTION (this << &buf);
+  buf.WriteU8 (m_li_cx);
+}
+void 
+LICXTag::Deserialize (TagBuffer buf)
+{
+  NS_LOG_FUNCTION (this << &buf);
+  m_li_cx = buf.ReadU8();
+}
+void 
+LICXTag::Print (std::ostream &os) const
+{
+  NS_LOG_FUNCTION (this << &os);
+  os << "LI CX Tag  = " << (int)m_li_cx;
+}
+LICXTag::LICXTag ()
+  : Tag () 
+{
+  NS_LOG_FUNCTION (this);
+}
+void
+LICXTag::SetLICX (uint8_t licx)
+{
+  NS_LOG_FUNCTION (this << licx);
+  m_li_cx = licx;
+}
+uint8_t
+LICXTag::GetLICX (void) const
+{
+  NS_LOG_FUNCTION (this);
+  return m_li_cx;
+}
+
+} // namespace ns3
diff --git a/src/network/utils/li-cx-tag.h b/src/network/utils/li-cx-tag.h
new file mode 100644
index 0000000..2c2d1aa
--- /dev/null
+++ b/src/network/utils/li-cx-tag.h
@@ -0,0 +1,33 @@
+/*
+ * LI_CX tag implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+#ifndef LI_CX_TAG_H
+#define LI_CX_TAG_H
+
+#include "ns3/tag.h"
+
+namespace ns3 {
+
+class LICXTag : public Tag
+{
+public:
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (TagBuffer buf) const;
+  virtual void Deserialize (TagBuffer buf);
+  virtual void Print (std::ostream &os) const;
+
+  LICXTag ();
+  void SetLICX (uint8_t ce);
+  uint8_t GetLICX (void) const;
+
+private:
+  uint8_t m_li_cx;
+};
+
+} // namespace ns3
+
+#endif /* LI_CX_TAG_H */
diff --git a/src/network/utils/red-queue.cc b/src/network/utils/red-queue.cc
index bb54565..f4d118d 100644
--- a/src/network/utils/red-queue.cc
+++ b/src/network/utils/red-queue.cc
@@ -324,6 +324,8 @@ RedQueue::DoEnqueue (Ptr<Packet> p)
   // Extract ECT bit
   EctTag ectTag;
   bool isEct =  p->PeekPacketTag(ectTag);
+  if (!isEct)
+    NS_LOG_INFO ("\t No ECT");
 	// Try to mark ECN bits first
   if (dropType == DTYPE_UNFORCED_SOFT || dropType == DTYPE_UNFORCED_HARD)
     {
@@ -338,6 +340,7 @@ RedQueue::DoEnqueue (Ptr<Packet> p)
             }
           m_stats.marked++;
           dropType = DTYPE_NONE; // We marked ECN bits! Packet shouldn't be dropped
+          NS_LOG_INFO ("\t ECN marked");
         }
       else if (m_useCurrent && isControlPkt)
         { // Control packets
diff --git a/src/network/utils/rl-tag.cc b/src/network/utils/rl-tag.cc
new file mode 100644
index 0000000..03ab686
--- /dev/null
+++ b/src/network/utils/rl-tag.cc
@@ -0,0 +1,71 @@
+/*
+ * RL tag implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+#include "rl-tag.h"
+#include "ns3/log.h"
+
+NS_LOG_COMPONENT_DEFINE ("RLTag");
+
+namespace ns3 {
+
+NS_OBJECT_ENSURE_REGISTERED (RLTag);
+
+TypeId 
+RLTag::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::RLTag")
+    .SetParent<Tag> ()
+    .AddConstructor<RLTag> ()
+  ;
+  return tid;
+}
+TypeId 
+RLTag::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+uint32_t 
+RLTag::GetSerializedSize (void) const
+{
+  NS_LOG_FUNCTION (this);
+  return 1;
+}
+void 
+RLTag::Serialize (TagBuffer buf) const
+{
+  NS_LOG_FUNCTION (this << &buf);
+  buf.WriteU8 (m_rl);
+}
+void 
+RLTag::Deserialize (TagBuffer buf)
+{
+  NS_LOG_FUNCTION (this << &buf);
+  m_rl = buf.ReadU8();
+}
+void 
+RLTag::Print (std::ostream &os) const
+{
+  NS_LOG_FUNCTION (this << &os);
+  os << "RL Tag  = " << (int)m_rl;
+}
+RLTag::RLTag ()
+  : Tag () 
+{
+  NS_LOG_FUNCTION (this);
+}
+void
+RLTag::SetRL (uint8_t rl)
+{
+  NS_LOG_FUNCTION (this << rl);
+  m_rl = rl;
+}
+uint8_t
+RLTag::GetRL (void) const
+{
+  NS_LOG_FUNCTION (this);
+  return m_rl;
+}
+
+} // namespace ns3
diff --git a/src/network/utils/rl-tag.h b/src/network/utils/rl-tag.h
new file mode 100644
index 0000000..e5c9be8
--- /dev/null
+++ b/src/network/utils/rl-tag.h
@@ -0,0 +1,33 @@
+/*
+ * RL tag implementation.
+ * Enhuan Dong
+ * Email: deh13@mails.tsinghua.edu.cn
+ */
+#ifndef RL_TAG_H
+#define RL_TAG_H
+
+#include "ns3/tag.h"
+
+namespace ns3 {
+
+class RLTag : public Tag
+{
+public:
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (TagBuffer buf) const;
+  virtual void Deserialize (TagBuffer buf);
+  virtual void Print (std::ostream &os) const;
+
+  RLTag ();
+  void SetRL (uint8_t ce);
+  uint8_t GetRL (void) const;
+
+private:
+  uint8_t m_rl;
+};
+
+} // namespace ns3
+
+#endif /* RL_TAG_H */
diff --git a/src/network/wscript b/src/network/wscript
index 0907bd5..a5a77e2 100644
--- a/src/network/wscript
+++ b/src/network/wscript
@@ -66,6 +66,10 @@ def build(bld):
         'helper/packet-socket-helper.cc',
         'helper/trace-helper.cc',
         'helper/delay-jitter-estimation.cc',
+        'utils/rl-tag.cc',
+        'utils/li-cx-tag.cc',
+        'utils/fb-li-tag.cc',
+        'utils/fb-tag.cc',
         ]
 
     network_test = bld.create_ns3_module_test_library('network')
@@ -153,6 +157,10 @@ def build(bld):
         'helper/packet-socket-helper.h',
         'helper/trace-helper.h',
         'helper/delay-jitter-estimation.h',
+        'utils/rl-tag.h',
+        'utils/li-cx-tag.h',
+        'utils/fb-li-tag.h',
+        'utils/fb-tag.h',
         ]
 
     if (bld.env['ENABLE_EXAMPLES']):
diff --git a/src/point-to-point/helper/point-to-point-helper.cc b/src/point-to-point/helper/point-to-point-helper.cc
index 1bd25cc..7a39705 100644
--- a/src/point-to-point/helper/point-to-point-helper.cc
+++ b/src/point-to-point/helper/point-to-point-helper.cc
@@ -51,13 +51,15 @@ PointToPointHelper::SetQueue (std::string type,
                               std::string n1, const AttributeValue &v1,
                               std::string n2, const AttributeValue &v2,
                               std::string n3, const AttributeValue &v3,
-                              std::string n4, const AttributeValue &v4)
+                              std::string n4, const AttributeValue &v4,
+                              std::string n5, const AttributeValue &v5)
 {
   m_queueFactory.SetTypeId (type);
   m_queueFactory.Set (n1, v1);
   m_queueFactory.Set (n2, v2);
   m_queueFactory.Set (n3, v3);
   m_queueFactory.Set (n4, v4);
+  m_queueFactory.Set (n5, v5);
 }
 
 void 
diff --git a/src/point-to-point/helper/point-to-point-helper.h b/src/point-to-point/helper/point-to-point-helper.h
index 55dea00..be1a064 100644
--- a/src/point-to-point/helper/point-to-point-helper.h
+++ b/src/point-to-point/helper/point-to-point-helper.h
@@ -74,7 +74,8 @@ public:
                  std::string n1 = "", const AttributeValue &v1 = EmptyAttributeValue (),
                  std::string n2 = "", const AttributeValue &v2 = EmptyAttributeValue (),
                  std::string n3 = "", const AttributeValue &v3 = EmptyAttributeValue (),
-                 std::string n4 = "", const AttributeValue &v4 = EmptyAttributeValue ());
+                 std::string n4 = "", const AttributeValue &v4 = EmptyAttributeValue (),
+                 std::string n5 = "", const AttributeValue &v5 = EmptyAttributeValue ());
 
   /**
    * Set an attribute value to be propagated to each NetDevice created by the
diff --git a/workloads/datamining.txt b/workloads/datamining.txt
new file mode 100644
index 0000000..229908f
--- /dev/null
+++ b/workloads/datamining.txt
@@ -0,0 +1,8 @@
+0.5	1
+0.6	2
+0.7	3
+0.8	7
+0.9	267
+0.95	2107
+0.99	66667
+1	666667
diff --git a/workloads/websearch.txt b/workloads/websearch.txt
new file mode 100644
index 0000000..25421a4
--- /dev/null
+++ b/workloads/websearch.txt
@@ -0,0 +1,11 @@
+0.15	6
+0.2	13
+0.3	19
+0.4	33
+0.53	53
+0.6	133
+0.7	667
+0.8	1333
+0.9	3333
+0.97	6667
+1	20000
